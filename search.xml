<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<p>Ollama 命令行工具 (<code>ollama</code>) 的主要实现代码，使用 Go 语言编写。它定义了 <code>ollama</code> 命令及其所有子命令（如 <code>run</code>, <code>pull</code>, <code>create</code> 等）的行为。</p><p>根据代码分析，以下是所有命令行操作及其具体含义：</p><ol><li><p><strong><code>ollama</code> (根命令)</strong></p><ul><li><strong>用途</strong>: 显示 Ollama CLI 的基本使用信息和可用命令列表。</li><li><strong>参数</strong>:<ul><li><code>-v, --version</code>: 显示 Ollama 客户端和服务端（如果正在运行）的版本信息。</li></ul></li></ul></li><li><p><strong><code>ollama serve</code> (或 <code>ollama start</code>)</strong></p><ul><li><strong>用途</strong>: 在前台启动 Ollama 服务。这通常在后台运行，以提供 API 服务供 <code>ollama run</code> 等命令使用。如果需要，它还会生成用于安全通信的 SSH 密钥对。</li><li><strong>参数</strong>: 无</li><li><strong>相关环境变量</strong>: 控制服务行为，如 <code>OLLAMA_HOST</code> (监听地址), <code>OLLAMA_DEBUG</code> (调试模式), <code>OLLAMA_MODELS</code> (模型存储路径) 等。</li></ul></li><li><p><strong><code>ollama create MODEL</code></strong></p><ul><li><strong>用途</strong>: 从指定的 <code>Modelfile</code> 创建一个新的本地模型。</li><li><strong>参数</strong>:<ul><li><code>MODEL</code>: 要创建的模型的名称。</li><li><code>-f, --file string</code>: 指定 <code>Modelfile</code> 的路径（默认为当前目录下的 <code>Modelfile</code>）。</li><li><code>-q, --quantize string</code>: （代码中定义但帮助文本未明确显示）指定量化模型的级别（例如 <code>q4_K_M</code>）。</li></ul></li></ul></li><li><p><strong><code>ollama run MODEL [PROMPT]</code></strong></p><ul><li><strong>用途</strong>: 运行指定的模型。如果提供了 <code>PROMPT</code>，则执行一次生成；如果没有提供或在交互模式下，则启动一个交互式会话。</li><li><strong>参数</strong>:<ul><li><code>MODEL</code>: 要运行的模型名称。</li><li><code>PROMPT</code>: （可选）传递给模型的初始提示文本。</li><li><code>--format string</code>: 指定响应的格式（例如 <code>json</code>）。</li><li><code>--keepalive string</code>: 指定模型在空闲状态下保持加载的持续时间（例如 <code>5m</code>）。</li><li><code>--nowordwrap</code>: 禁用自动换行显示响应。</li><li><code>--verbose</code>: 显示响应的计时信息。</li><li><code>--think [string]</code>: 启用模型的“思考”模式。可以是 <code>true</code>, <code>false</code>, <code>high</code>, <code>medium</code>, <code>low</code>。不带值时默认为 <code>true</code>。</li><li><code>--hidethinking</code>: 隐藏模型的“思考”输出（如果模型产生）。</li></ul></li><li><strong>交互模式特殊命令</strong>:<ul><li>在 <code>ollama run</code> 启动的交互会话中，可以输入 <code>/help</code> 查看帮助，包括 <code>/set</code>, <code>/show</code>, <code>/load</code>, <code>/bye</code> 等命令（虽然 <code>/load</code>, <code>/set</code>, <code>/show</code> 在代码中定义，但 <code>/help</code> 和 <code>/bye</code> 未在提供的代码片段中明确显示，但属于标准交互功能）。</li></ul></li></ul></li><li><p><strong><code>ollama stop MODEL</code></strong></p><ul><li><strong>用途</strong>: 停止指定模型的运行实例（将其从内存中卸载）。</li><li><strong>参数</strong>:<ul><li><code>MODEL</code>: 要停止的模型名称。</li></ul></li></ul></li><li><p><strong><code>ollama pull MODEL</code></strong></p><ul><li><strong>用途</strong>: 从模型库（默认是 ollama.com/library）下载指定的模型到本地。</li><li><strong>参数</strong>:<ul><li><code>MODEL</code>: 要下载的模型名称。</li><li><code>--insecure</code>: 使用不安全的 HTTP 连接（而非 HTTPS）。</li></ul></li></ul></li><li><p><strong><code>ollama push MODEL</code></strong></p><ul><li><strong>用途</strong>: 将本地自定义模型推送到模型库（需要先登录）。</li><li><strong>参数</strong>:<ul><li><code>MODEL</code>: 要推送的模型名称（格式通常为 <code>username/model_name:tag</code>）。</li><li><code>--insecure</code>: 使用不安全的 HTTP 连接。</li></ul></li></ul></li><li><p><strong><code>ollama list</code> (或 <code>ollama ls</code>)</strong></p><ul><li><strong>用途</strong>: 列出所有已下载到本地的模型及其基本信息（名称、ID、大小、修改时间）。</li><li><strong>参数</strong>: 无</li></ul></li><li><p><strong><code>ollama ps</code></strong></p><ul><li><strong>用途</strong>: 列出当前正在运行（已加载到内存中）的模型及其状态信息（名称、ID、大小、处理器使用情况、上下文长度、过期时间）。</li><li><strong>参数</strong>: 无</li></ul></li><li><p><strong><code>ollama show MODEL</code></strong></p><ul><li><strong>用途</strong>: 显示指定模型的详细信息。</li><li><strong>参数</strong>:<ul><li><code>MODEL</code>: 要显示信息的模型名称。</li><li><code>--license</code>: 仅显示模型的许可证信息。</li><li><code>--modelfile</code>: 仅显示模型的 <code>Modelfile</code> 内容。</li><li><code>--parameters</code>: 仅显示模型的参数设置。</li><li><code>--system</code>: 仅显示模型的系统消息。</li><li><code>--template</code>: 仅显示模型的提示模板。</li><li><code>-v, --verbose</code>: 显示更详细的模型元数据。</li></ul></li></ul></li><li><p><strong><code>ollama cp SOURCE DESTINATION</code> (或 <code>ollama copy SOURCE DESTINATION</code>)</strong></p><ul><li><strong>用途</strong>: 在本地复制或重命名一个已存在的模型。</li><li><strong>参数</strong>:<ul><li><code>SOURCE</code>: 源模型名称。</li><li><code>DESTINATION</code>: 目标模型名称。</li></ul></li></ul></li><li><p><strong><code>ollama rm MODEL [MODEL...]</code> (或 <code>ollama delete MODEL [MODEL...]</code>)</strong></p><ul><li><strong>用途</strong>: 从本地删除一个或多个已下载的模型。</li><li><strong>参数</strong>:<ul><li><code>MODEL</code>: 要删除的一个或多个模型名称。</li></ul></li></ul></li></ol><p>这些命令共同构成了 Ollama CLI 的核心功能，允许用户管理、运行和与本地大型语言模型进行交互。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Rust 异步机制的详细讲解</title>
      <link href="/posts/4ee2f4d7.html"/>
      <url>/posts/4ee2f4d7.html</url>
      
        <content type="html"><![CDATA[<h3 id="Rust-异步机制的详细讲解（原理、流程、系统级概念）"><a href="#Rust-异步机制的详细讲解（原理、流程、系统级概念）" class="headerlink" title="Rust 异步机制的详细讲解（原理、流程、系统级概念）"></a>Rust 异步机制的详细讲解（原理、流程、系统级概念）</h3><hr><h3 id="1-异步机制的核心目标"><a href="#1-异步机制的核心目标" class="headerlink" title="1. 异步机制的核心目标"></a><strong>1. 异步机制的核心目标</strong></h3><p>Rust 的异步机制旨在解决 <strong>高并发场景下的性能问题</strong>，尤其是 <strong>IO 密集型任务</strong>（如网络请求、文件读写）。其核心目标是：</p><ul><li><strong>避免线程切换的开销</strong>：传统多线程（如 Java）依赖操作系统线程，每个线程有固定栈空间（约 1MB），且线程切换需要上下文保存和恢复，导致性能损耗。</li><li><strong>高效利用 CPU 资源</strong>：通过 <strong>无栈协程（Green Thread）</strong> 实现用户态调度，减少系统资源占用。</li><li><strong>非阻塞编程模型</strong>：通过 <code>async/await</code> 语法糖，将阻塞操作转化为非阻塞的异步任务，避免阻塞整个线程。</li></ul><hr><h3 id="2-核心概念与组件"><a href="#2-核心概念与组件" class="headerlink" title="2. 核心概念与组件"></a><strong>2. 核心概念与组件</strong></h3><p>Rust 的异步机制涉及以下关键概念：</p><h4 id="2-1-Future（未来）"><a href="#2-1-Future（未来）" class="headerlink" title="2.1 Future（未来）"></a><strong>2.1 Future（未来）</strong></h4><ul><li><strong>定义</strong>：<code>Future</code> 是一个 <strong>状态机</strong>，表示一个可能尚未完成的异步操作。</li><li><strong>核心方法</strong>：<code>poll()</code>，用于轮询任务的执行状态。<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Future</span> {</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(</span><br><span class="line">        <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;,</span><br><span class="line">        cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">'_</span>&gt;,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt;;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>Poll</strong>：返回 <code>Ready</code>（任务完成）或 <code>Pending</code>（任务未完成，需等待）。</li><li><strong>Context</strong>：包含 <code>Waker</code>，用于在任务可执行时唤醒调度器。</li></ul></li></ul><h4 id="2-2-Executor（执行器）"><a href="#2-2-Executor（执行器）" class="headerlink" title="2.2 Executor（执行器）"></a><strong>2.2 Executor（执行器）</strong></h4><ul><li><strong>作用</strong>：负责调度和驱动 <code>Future</code> 的执行。</li><li><strong>工作流程</strong>：<ol><li>轮询所有注册的 <code>Future</code>。</li><li>若 <code>Future</code> 返回 <code>Pending</code>，则注册其 <code>Waker</code>。</li><li>当异步操作完成（如 IO 就绪），通过 <code>Waker</code> 唤醒 <code>Future</code> 重新轮询。</li></ol></li><li><strong>常见实现</strong>：<code>tokio</code>、<code>async-std</code> 等运行时（Runtime）。</li></ul><h4 id="2-3-Waker（唤醒器）"><a href="#2-3-Waker（唤醒器）" class="headerlink" title="2.3 Waker（唤醒器）"></a><strong>2.3 Waker（唤醒器）</strong></h4><ul><li><strong>作用</strong>：将异步操作完成的事件通知给 <code>Executor</code>。</li><li><strong>关键操作</strong>：<ul><li><code>wake()</code>：触发 <code>Future</code> 的重新轮询。</li><li><code>clone()</code>：允许在多线程环境下安全传递唤醒请求。</li></ul></li><li><strong>底层实现</strong>：通常基于 <code>Arc</code> 和原子操作，确保跨线程唤醒的安全性。</li></ul><h4 id="2-4-Reactor（反应堆）"><a href="#2-4-Reactor（反应堆）" class="headerlink" title="2.4 Reactor（反应堆）"></a><strong>2.4 Reactor（反应堆）</strong></h4><ul><li><strong>作用</strong>：监听系统级的 IO 事件（如网络连接、文件读写）。</li><li><strong>实现原理</strong>：<ul><li>使用 <strong>IO 多路复用</strong>（如 Linux 的 <code>epoll</code>、Windows 的 <code>IOCP</code>）。</li><li>当事件触发时（如套接字可读），通知对应的 <code>Waker</code>。</li></ul></li><li><strong>与 Future 的关联</strong>：<code>Future</code> 的 <code>poll()</code> 会通过 <code>Reactor</code> 注册事件监听。</li></ul><h4 id="2-5-无栈协程（Green-Thread）"><a href="#2-5-无栈协程（Green-Thread）" class="headerlink" title="2.5 无栈协程（Green Thread）"></a><strong>2.5 无栈协程（Green Thread）</strong></h4><ul><li><strong>与 OS 线程的区别</strong>：<ul><li><strong>无栈协程</strong>：由用户态库（如 <code>tokio</code>）管理，<strong>无需操作系统参与</strong>，开销极小。</li><li><strong>OS 线程</strong>：由操作系统调度，每个线程有独立栈，切换开销大。</li></ul></li><li><strong>实现方式</strong>：通过 <strong>状态机</strong> 和 <strong>异步语法糖</strong>（<code>async/await</code>）实现。</li></ul><hr><h3 id="3-异步机制的底层原理"><a href="#3-异步机制的底层原理" class="headerlink" title="3. 异步机制的底层原理"></a><strong>3. 异步机制的底层原理</strong></h3><h4 id="3-1-语法糖-async-await-的转换"><a href="#3-1-语法糖-async-await-的转换" class="headerlink" title="3.1 语法糖 async/await 的转换"></a><strong>3.1 语法糖 <code>async/await</code> 的转换</strong></h4><ul><li><strong><code>async</code> 函数</strong>：编译器将其转换为实现 <code>Future</code> 的状态机。<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">my_async_func</span>() {</span><br><span class="line">    <span class="comment">// 异步代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>编译后</strong>：生成一个包含状态机的结构体，每个 <code>await</code> 对应状态机的一个状态。</li></ul></li><li><strong><code>await</code> 关键字</strong>：暂停当前 <code>Future</code> 的执行，注册 <code>Waker</code>，并返回 <code>Pending</code>。</li></ul><h4 id="3-2-状态机（State-Machine）"><a href="#3-2-状态机（State-Machine）" class="headerlink" title="3.2 状态机（State Machine）"></a><strong>3.2 状态机（State Machine）</strong></h4><ul><li><strong>作用</strong>：保存 <code>Future</code> 的执行上下文（如变量、执行位置）。</li><li><strong>实现</strong>：通过 <code>enum</code> 或 <code>struct</code> 记录不同阶段的执行状态。<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyFutureState</span> {</span><br><span class="line">    Start,</span><br><span class="line">    <span class="title function_ invoke__">AfterFirstAwait</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Completed</span>(<span class="type">i32</span>),</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><strong>轮询逻辑</strong>：<code>poll()</code> 根据当前状态决定下一步操作。</li></ul><h4 id="3-3-异步任务的生命周期"><a href="#3-3-异步任务的生命周期" class="headerlink" title="3.3 异步任务的生命周期"></a><strong>3.3 异步任务的生命周期</strong></h4><ol><li><strong>创建 Future</strong>：通过 <code>async</code> 函数生成 <code>Future</code> 实例。</li><li><strong>注册到 Executor</strong>：将 <code>Future</code> 放入 <code>Executor</code> 的任务队列。</li><li><strong>首次轮询</strong>：<ul><li><code>poll()</code> 执行到第一个 <code>await</code> 时，返回 <code>Pending</code>。</li><li>注册 <code>Waker</code> 到 <code>Reactor</code>（如监听网络套接字的可读事件）。</li></ul></li><li><strong>等待事件</strong>：<ul><li><code>Reactor</code> 监听系统事件（如 <code>epoll</code>）。</li><li>当事件触发（如数据到达），通过 <code>Waker</code> 唤醒 <code>Executor</code>。</li></ul></li><li><strong>重新轮询</strong>：<ul><li><code>Executor</code> 重新调用 <code>poll()</code>，继续执行 <code>Future</code> 的后续代码。</li></ul></li><li><strong>完成或继续等待</strong>：<ul><li>若任务完成，返回 <code>Ready</code>；否则重复步骤 3-5。</li></ul></li></ol><hr><h3 id="4-系统级交互与性能优势"><a href="#4-系统级交互与性能优势" class="headerlink" title="4. 系统级交互与性能优势"></a><strong>4. 系统级交互与性能优势</strong></h3><h4 id="4-1-与操作系统的交互"><a href="#4-1-与操作系统的交互" class="headerlink" title="4.1 与操作系统的交互"></a><strong>4.1 与操作系统的交互</strong></h4><ul><li><strong>Reactor 模式</strong>：<ul><li><strong>Linux</strong>：通过 <code>epoll</code> 监听文件描述符（如套接字、文件）。</li><li><strong>Windows</strong>：通过 <code>IO Completion Port (IOCP)</code>。</li></ul></li><li><strong>避免系统线程切换</strong>：<ul><li>一个 OS 线程可以驱动多个无栈协程（如 <code>tokio</code> 默认使用少量线程池）。</li><li>仅在实际需要时（如计算密集型任务）切换线程。</li></ul></li></ul><h4 id="4-2-性能对比"><a href="#4-2-性能对比" class="headerlink" title="4.2 性能对比"></a><strong>4.2 性能对比</strong></h4><div class="table-container"><table><thead><tr><th><strong>指标</strong></th><th><strong>Rust 异步</strong></th><th><strong>Java 多线程</strong></th></tr></thead><tbody><tr><td><strong>线程开销</strong></td><td>无栈协程（KB 级）</td><td>每线程 1MB 栈空间</td></tr><tr><td><strong>上下文切换</strong></td><td>用户态（极低开销）</td><td>系统调用（高开销）</td></tr><tr><td><strong>并发能力</strong></td><td>十万级并发（如 <code>tokio</code>）</td><td>千级并发（受限于线程数）</td></tr><tr><td><strong>内存占用</strong></td><td>低（无额外线程栈）</td><td>高（线程栈占用内存）</td></tr></tbody></table></div><h4 id="4-3-适用场景"><a href="#4-3-适用场景" class="headerlink" title="4.3 适用场景"></a><strong>4.3 适用场景</strong></h4><ul><li><strong>高并发 IO</strong>：Web 服务器（如 <code>Actix-Web</code>）、网络爬虫。</li><li><strong>非阻塞任务</strong>：文件读写、数据库查询、HTTP 请求。</li><li><strong>避免阻塞主线程</strong>：UI 框架（如 <code>Tauri</code>）的后台任务。</li></ul><hr><h3 id="5-典型流程示例"><a href="#5-典型流程示例" class="headerlink" title="5. 典型流程示例"></a><strong>5. 典型流程示例</strong></h3><h4 id="5-1-示例代码"><a href="#5-1-示例代码" class="headerlink" title="5.1 示例代码"></a><strong>5.1 示例代码</strong></h4><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::net::TcpStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">connect</span>(host: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> std::io::<span class="type">Result</span>&lt;()&gt; {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stream</span> = TcpStream::<span class="title function_ invoke__">connect</span>(host).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="comment">// 使用 stream 的逻辑...</span></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="title function_ invoke__">connect</span>(<span class="string">"example.com:8080"</span>).<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="5-2-流程分解"><a href="#5-2-流程分解" class="headerlink" title="5.2 流程分解"></a><strong>5.2 流程分解</strong></h4><ol><li><strong>创建 Future</strong>：<ul><li><code>TcpStream::connect</code> 返回一个 <code>Future</code>，表示连接操作。</li></ul></li><li><strong>注册到 Reactor</strong>：<ul><li><code>Future</code> 通过 <code>Reactor</code> 监听 DNS 解析和 TCP 连接完成事件。</li></ul></li><li><strong>首次轮询</strong>：<ul><li><code>poll()</code> 返回 <code>Pending</code>，注册 <code>Waker</code>。</li></ul></li><li><strong>等待事件</strong>：<ul><li><code>Reactor</code> 监听系统事件（如 <code>epoll</code>），等待连接完成。</li></ul></li><li><strong>事件触发</strong>：<ul><li>连接就绪时，<code>Waker</code> 唤醒 <code>Executor</code>。</li></ul></li><li><strong>继续执行</strong>：<ul><li><code>poll()</code> 检查连接成功，返回 <code>Ready</code>，继续后续代码。</li></ul></li></ol><hr><h3 id="6-系统级概念对比：Rust-异步-vs-Java-多线程"><a href="#6-系统级概念对比：Rust-异步-vs-Java-多线程" class="headerlink" title="6. 系统级概念对比：Rust 异步 vs Java 多线程"></a><strong>6. 系统级概念对比：Rust 异步 vs Java 多线程</strong></h3><div class="table-container"><table><thead><tr><th><strong>概念</strong></th><th><strong>Rust 异步</strong></th><th><strong>Java 多线程</strong></th></tr></thead><tbody><tr><td><strong>执行单元</strong></td><td>无栈协程（由用户态库管理）</td><td>系统线程（由 OS 调度）</td></tr><tr><td><strong>调度器</strong></td><td><code>Executor</code>（如 <code>tokio</code>）</td><td>OS 调度器</td></tr><tr><td><strong>IO 处理</strong></td><td><code>Reactor</code> + <code>Waker</code>（非阻塞轮询）</td><td>阻塞线程或 <code>Selector</code>（NIO）</td></tr><tr><td><strong>上下文切换</strong></td><td>用户态（通过状态机）</td><td>系统态（高开销）</td></tr><tr><td><strong>内存占用</strong></td><td>低（无额外栈）</td><td>高（每线程 1MB 栈）</td></tr><tr><td><strong>并发模型</strong></td><td>协程级并发（百万级）</td><td>线程级并发（千级）</td></tr></tbody></table></div><hr><h3 id="7-异步机制的实现细节"><a href="#7-异步机制的实现细节" class="headerlink" title="7. 异步机制的实现细节"></a><strong>7. 异步机制的实现细节</strong></h3><h4 id="7-1-状态机的生成"><a href="#7-1-状态机的生成" class="headerlink" title="7.1 状态机的生成"></a><strong>7.1 状态机的生成</strong></h4><ul><li><strong>编译器优化</strong>：<ul><li><code>async</code> 函数会被编译为一个状态机结构体，每个 <code>await</code> 对应一个状态。</li><li>状态机通过 <code>Pin</code> 和 <code>UnsafeCell</code> 实现可变性控制。</li></ul></li><li><strong>示例</strong>：<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">example</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="keyword">async</span> { <span class="number">2</span> }.<span class="keyword">await</span>;</span><br><span class="line">    a + b</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>编译后生成类似以下结构：<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ExampleFuture</span> {</span><br><span class="line">    state: State,</span><br><span class="line">    a: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;,</span><br><span class="line">    b: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;,</span><br><span class="line">}</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">State</span> {</span><br><span class="line">    Start,</span><br><span class="line">    AfterFirstAwait,</span><br><span class="line">    Completed,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h4 id="7-2-Waker-的底层实现"><a href="#7-2-Waker-的底层实现" class="headerlink" title="7.2 Waker 的底层实现"></a><strong>7.2 Waker 的底层实现</strong></h4><ul><li><strong><code>Arc&lt;Waker&gt;</code></strong>：通过原子引用计数实现跨线程安全传递。</li><li><strong><code>waker_ref</code></strong>：轻量级的 <code>Waker</code> 引用，用于避免频繁克隆。</li><li><strong><code>RawWaker</code></strong>：FFI 接口，与 C 语言的 <code>epoll</code> 等系统调用交互。</li></ul><h4 id="7-3-Reactor-的系统调用"><a href="#7-3-Reactor-的系统调用" class="headerlink" title="7.3 Reactor 的系统调用"></a><strong>7.3 Reactor 的系统调用</strong></h4><ul><li><strong>Linux 的 <code>epoll</code></strong>：<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> epoll_fd = epoll_create1(<span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">event.events = EPOLLIN;</span><br><span class="line">event.data.fd = socket_fd;</span><br><span class="line">epoll_ctl(epoll_fd, EPOLL_CTL_ADD, socket_fd, &amp;event);</span><br></pre></td></tr></tbody></table></figure></li><li><strong>事件触发时</strong>：<ul><li><code>epoll_wait</code> 返回就绪的文件描述符，触发对应 <code>Waker</code>。</li></ul></li></ul><hr><h3 id="8-常见问题与最佳实践"><a href="#8-常见问题与最佳实践" class="headerlink" title="8. 常见问题与最佳实践"></a><strong>8. 常见问题与最佳实践</strong></h3><h4 id="8-1-为什么-Rust-的异步性能更高？"><a href="#8-1-为什么-Rust-的异步性能更高？" class="headerlink" title="8.1 为什么 Rust 的异步性能更高？"></a><strong>8.1 为什么 Rust 的异步性能更高？</strong></h4><ul><li><strong>无栈协程</strong>：减少线程切换开销。</li><li><strong>零成本抽象</strong>：状态机由编译器优化，无运行时开销。</li><li><strong>Reactor 模式</strong>：直接复用操作系统高效 IO 多路复用机制。</li></ul><h4 id="8-2-如何避免阻塞异步任务？"><a href="#8-2-如何避免阻塞异步任务？" class="headerlink" title="8.2 如何避免阻塞异步任务？"></a><strong>8.2 如何避免阻塞异步任务？</strong></h4><ul><li><strong>避免 <code>std::thread::sleep</code></strong>：改用 <code>tokio::time::sleep</code>。</li><li><strong>避免计算密集型操作</strong>：将耗时计算放入线程池（<code>tokio::task::spawn_blocking</code>）。</li></ul><h4 id="8-3-如何调试异步代码？"><a href="#8-3-如何调试异步代码？" class="headerlink" title="8.3 如何调试异步代码？"></a><strong>8.3 如何调试异步代码？</strong></h4><ul><li><strong>日志</strong>：使用 <code>tracing</code> 记录 <code>Future</code> 的状态。</li><li><strong>可视化工具</strong>：<code>tokio-console</code> 监控任务调度。</li></ul><hr><h3 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a><strong>9. 总结</strong></h3><p>Rust 的异步机制通过 <strong>无栈协程、状态机、Reactor 模式</strong>，实现了 <strong>高效、轻量级的并发</strong>。其核心是将阻塞操作转化为非阻塞的 <code>Future</code>，并通过 <code>Executor</code> 和 <code>Waker</code> 协调任务执行。与 Java 多线程相比，Rust 的异步更适用于 <strong>高并发 IO 场景</strong>，在性能和资源占用上具有显著优势。理解其底层原理有助于开发者编写高效、可维护的异步代码。</p><h3 id="用户态协程的实现机制：轮询、线程模型与调度方式"><a href="#用户态协程的实现机制：轮询、线程模型与调度方式" class="headerlink" title="用户态协程的实现机制：轮询、线程模型与调度方式"></a><strong>用户态协程的实现机制：轮询、线程模型与调度方式</strong></h3><hr><h4 id="1-用户态协程的核心特性"><a href="#1-用户态协程的核心特性" class="headerlink" title="1. 用户态协程的核心特性"></a><strong>1. 用户态协程的核心特性</strong></h4><p>用户态协程（如协程、纤程、虚拟线程）的核心特点包括：</p><ul><li><strong>非抢占式调度</strong>：协程的切换由程序显式控制（如 <code>await</code>、<code>yield</code>），而非操作系统强制切换。</li><li><strong>轻量级</strong>：创建和切换开销极低，无需系统级上下文切换。</li><li><strong>状态保存与恢复</strong>：通过保存当前执行上下文（寄存器、栈状态等）实现暂停和恢复。</li></ul><hr><h4 id="2-用户态协程是否仅使用单线程？"><a href="#2-用户态协程是否仅使用单线程？" class="headerlink" title="2. 用户态协程是否仅使用单线程？"></a><strong>2. 用户态协程是否仅使用单线程？</strong></h4><p><strong>答案：不一定</strong>。用户态协程的线程模型取决于具体实现，主要有以下两种模式：</p><hr><h5 id="2-1-单线程模型（纯用户态协程）"><a href="#2-1-单线程模型（纯用户态协程）" class="headerlink" title="2.1 单线程模型（纯用户态协程）"></a><strong>2.1 单线程模型（纯用户态协程）</strong></h5><ul><li><strong>实现方式</strong>：<br>所有协程在同一个线程内运行，通过事件循环（Event Loop）轮询任务状态，主动切换协程。  </li><li><strong>典型场景</strong>：  <ul><li><strong>Node.js</strong>：单线程事件循环处理所有 I/O 事件。  </li><li><strong>Python 的 <code>asyncio</code></strong>：默认单线程事件循环调度协程。  </li></ul></li><li><strong>优势</strong>：<br>极低的切换开销，适合纯 I/O 密集型任务。  </li><li><strong>局限性</strong>：<br>单线程无法利用多核 CPU，且计算密集型任务会阻塞整个事件循环。</li></ul><hr><h5 id="2-2-多线程模型（N-M-线程模型）"><a href="#2-2-多线程模型（N-M-线程模型）" class="headerlink" title="2.2 多线程模型（N:M 线程模型）"></a><strong>2.2 多线程模型（N:M 线程模型）</strong></h5><ul><li><strong>实现方式</strong>：<br>协程与操作系统线程解耦，多个协程（N）映射到少量线程（M），由运行时（如 Tokio、Go 运行时、Java 虚拟线程）管理调度。  </li><li><strong>典型场景</strong>：  <ul><li><strong>Go 的 Goroutine</strong>：Goroutine 被调度到多个 OS 线程（P 和 M 模型）。  </li><li><strong>Java 虚拟线程（Project Loom）</strong>：虚拟线程由 JVM 管理，运行在少量 OS 线程上。  </li><li><strong>Rust 的 Tokio</strong>：通过事件循环和线程池结合，支持多线程执行计算任务。  </li></ul></li><li><strong>优势</strong>：  <ul><li><strong>高并发</strong>：可支持百万级协程。  </li><li><strong>多核利用</strong>：通过线程池分配 CPU 密集型任务。  </li></ul></li><li><strong>调度流程</strong>：  <ol><li>协程在用户态切换（如等待 I/O 时挂起）。  </li><li>I/O 事件就绪后，通过 <code>Waker</code> 或调度器唤醒协程。  </li><li>运行时将协程分配到可用的 OS 线程继续执行。</li></ol></li></ul><hr><h4 id="3-轮询机制的作用"><a href="#3-轮询机制的作用" class="headerlink" title="3. 轮询机制的作用"></a><strong>3. 轮询机制的作用</strong></h4><p>用户提到的“轮询”通常指 <strong>事件循环（Event Loop）</strong>，它是用户态协程调度的核心机制：</p><ul><li><strong>事件循环的核心职责</strong>：  <ol><li><strong>轮询任务状态</strong>：通过 <code>Future::poll()</code>（如 Rust）或 <code>select</code>（如 Go）检查协程是否就绪。  </li><li><strong>驱动任务执行</strong>：当协程准备好（如 I/O 完成），事件循环将其重新调度到线程执行。  </li><li><strong>I/O 多路复用</strong>：通过 <code>epoll</code>、<code>kqueue</code> 等系统调用监听 I/O 事件，减少轮询开销。  </li></ol></li></ul><p><strong>示例（Rust 的 Tokio）</strong>：<br></p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件循环通过 epoll 监听 I/O 事件</span></span><br><span class="line"><span class="keyword">loop</span> {</span><br><span class="line">    <span class="comment">// 轮询所有注册的 Future</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">task</span> <span class="keyword">in</span> ready_tasks {</span><br><span class="line">        <span class="keyword">if</span> task.<span class="title function_ invoke__">poll</span>().<span class="title function_ invoke__">is_ready</span>() {</span><br><span class="line">            <span class="comment">// 任务完成，执行后续逻辑</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 挂起任务，注册 Waker</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 使用 epoll 等待新事件</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">events</span> = epoll.<span class="title function_ invoke__">poll</span>(...);</span><br><span class="line">    <span class="comment">// 处理事件并唤醒相关协程</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><hr><h4 id="4-用户态协程的线程模型对比"><a href="#4-用户态协程的线程模型对比" class="headerlink" title="4. 用户态协程的线程模型对比"></a><strong>4. 用户态协程的线程模型对比</strong></h4><div class="table-container"><table><thead><tr><th><strong>模式</strong></th><th><strong>线程数</strong></th><th><strong>适用场景</strong></th><th><strong>典型实现</strong></th></tr></thead><tbody><tr><td><strong>单线程</strong></td><td>1 线程</td><td>纯 I/O 密集型任务（如 Web 服务器）</td><td>Node.js、Python <code>asyncio</code></td></tr><tr><td><strong>多线程（N:M）</strong></td><td>多线程（如 CPU 核数）</td><td>需要多核利用或混合任务（I/O + CPU）</td><td>Go、Java 虚拟线程、Rust Tokio</td></tr></tbody></table></div><hr><h4 id="5-关键细节：用户态协程的线程协作"><a href="#5-关键细节：用户态协程的线程协作" class="headerlink" title="5. 关键细节：用户态协程的线程协作"></a><strong>5. 关键细节：用户态协程的线程协作</strong></h4><p>即使采用多线程模型，用户态协程的 <strong>切换仍发生在用户态</strong>，无需操作系统参与。系统线程的作用是：</p><ol><li><strong>承载协程执行</strong>：协程的代码在 OS 线程上实际运行。  </li><li><strong>I/O 处理</strong>：通过 <code>Reactor</code> 或 <code>Proactor</code> 模式监听系统事件。  </li><li><strong>计算任务</strong>：线程池处理 CPU 密集型任务（如 <code>tokio::task::spawn_blocking</code>）。</li></ol><hr><h4 id="6-例子：Rust-Tokio-的线程模型"><a href="#6-例子：Rust-Tokio-的线程模型" class="headerlink" title="6. 例子：Rust Tokio 的线程模型"></a><strong>6. 例子：Rust Tokio 的线程模型</strong></h4><p>Rust 的 Tokio 运行时默认使用以下线程模型：</p><ol><li><strong>主线程（Event Loop）</strong>：  <ul><li>运行事件循环，轮询 <code>Future</code> 状态。  </li><li>通过 <code>epoll</code> 监听 I/O 事件。  </li></ul></li><li><strong>I/O 线程</strong>：  <ul><li>处理阻塞 I/O 操作（如文件读写）。  </li></ul></li><li><strong>工作线程池</strong>：  <ul><li>处理通过 <code>spawn_blocking</code> 提交的计算任务。  </li></ul></li></ol><p><strong>代码示例</strong>：<br></p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="comment">// 主线程事件循环自动启动</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = tokio::runtime::Handle::<span class="title function_ invoke__">current</span>();</span><br><span class="line">    handle.<span class="title function_ invoke__">spawn_blocking</span>(|| {</span><br><span class="line">        <span class="comment">// 运行在工作线程池中</span></span><br><span class="line">        <span class="title function_ invoke__">heavy_computation</span>();</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><hr><h4 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><strong>7. 总结</strong></h4><p>用户态协程的线程模型取决于具体实现，可以是：</p><ul><li><strong>单线程</strong>：通过事件循环轮询任务，适合纯 I/O 场景。  </li><li><strong>多线程（N:M）</strong>：利用少量 OS 线程承载大量协程，结合事件循环和线程池，适合复杂场景。  </li></ul><p><strong>轮询机制（事件循环）</strong> 是用户态协程调度的核心，但线程的使用并非仅限于单线程，而是根据需求灵活选择模型。</p><p>你的问题涉及到用户态协程与线程切换的底层机制，我将通过详细解释来澄清这一概念。</p><hr><h3 id="1-核心问题：用户态协程的切换是否需要内核态参与？"><a href="#1-核心问题：用户态协程的切换是否需要内核态参与？" class="headerlink" title="1. 核心问题：用户态协程的切换是否需要内核态参与？"></a><strong>1. 核心问题：用户态协程的切换是否需要内核态参与？</strong></h3><p><strong>答案：不需要</strong>。即使采用多线程模型，用户态协程的<strong>切换始终发生在用户态</strong>，无需操作系统参与。<br><strong>关键点</strong>：  </p><ul><li><strong>用户态协程的切换</strong>：由用户程序自己控制，通过保存和恢复寄存器、栈等上下文实现。  </li><li><strong>线程切换</strong>：由操作系统调度，涉及内核态（如 <code>context_switch</code> 系统调用）。  </li><li><strong>两者是独立的</strong>：协程切换与线程切换是两个不同的概念，即使协程分布在多个线程上，协程的切换本身仍由用户态完成。</li></ul><hr><h3 id="2-用户态协程切换的实现细节"><a href="#2-用户态协程切换的实现细节" class="headerlink" title="2. 用户态协程切换的实现细节"></a><strong>2. 用户态协程切换的实现细节</strong></h3><h4 id="2-1-协程切换的底层原理（以-x86-64-架构为例）"><a href="#2-1-协程切换的底层原理（以-x86-64-架构为例）" class="headerlink" title="2.1 协程切换的底层原理（以 x86-64 架构为例）"></a><strong>2.1 协程切换的底层原理（以 x86-64 架构为例）</strong></h4><p>根据知识库[6]和[7]，协程切换的步骤如下：</p><ol><li><strong>保存当前协程的上下文</strong>：  <ul><li>保存 <strong>寄存器状态</strong>（如 <code>rip</code>、<code>rsp</code>、<code>rbp</code>、通用寄存器等）到协程的上下文结构中。  </li><li>这些寄存器决定了协程的执行位置和栈状态。  </li></ul></li><li><strong>恢复目标协程的上下文</strong>：  <ul><li>将目标协程的寄存器状态从其上下文结构加载到 CPU 寄存器中。  </li><li>这一步通过用户态的 <strong>汇编代码</strong> 实现，无需内核干预。  </li></ul></li></ol><p><strong>示例代码（知识库[6]）</strong>：<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.globl ctx_swap</span><br><span class="line">ctx_swap:</span><br><span class="line">    pushq %rdi        # 保存调用者寄存器到当前栈</span><br><span class="line">    pushq %r12-15, %rbx, %rbp</span><br><span class="line">    movq %rsp, (%rdi)  # 保存当前栈顶指针到源协程的上下文</span><br><span class="line">    movq (%rsi), %rsp  # 将目标栈顶指针加载到 %rsp</span><br><span class="line">    popq %rbp-%rdi     # 恢复目标协程的寄存器</span><br><span class="line">    ret</span><br></pre></td></tr></tbody></table></figure><p></p><hr><h4 id="2-2-协程切换的时机"><a href="#2-2-协程切换的时机" class="headerlink" title="2.2 协程切换的时机"></a><strong>2.2 协程切换的时机</strong></h4><ul><li><strong>显式触发</strong>：通过代码中的 <code>yield</code>、<code>await</code> 或类似语法（如 Rust 的 <code>async/await</code>）。  </li><li><strong>非抢占式</strong>：协程主动让出控制权，而非被操作系统强制中断。  </li><li><strong>无需内核参与</strong>：切换逻辑完全由用户态库（如 Tokio、Go 运行时）管理。</li></ul><hr><h3 id="3-多线程模型中的协程与线程的关系"><a href="#3-多线程模型中的协程与线程的关系" class="headerlink" title="3. 多线程模型中的协程与线程的关系"></a><strong>3. 多线程模型中的协程与线程的关系</strong></h3><h4 id="3-1-线程的作用"><a href="#3-1-线程的作用" class="headerlink" title="3.1 线程的作用"></a><strong>3.1 线程的作用</strong></h4><p>在多线程模型（如 Rust 的 Tokio 或 Go 的 Goroutine）中：  </p><ul><li><strong>线程是协程的执行载体</strong>：协程在某个线程上运行，但线程本身由操作系统调度。  </li><li><strong>协程与线程的解耦</strong>：  <ul><li>协程的切换由用户态调度器管理，无需内核参与。  </li><li>线程的切换由操作系统决定（如 CPU 时间片耗尽或 I/O 事件触发）。  </li></ul></li></ul><p><strong>示例场景</strong>：  </p><ol><li>协程 A 在线程 T1 上运行，执行到 <code>await</code> 时主动挂起。  </li><li>用户态调度器选择协程 B（可能在 T1 或其他线程 T2）继续执行。  </li><li><strong>若协程 B 在 T1 上</strong>：直接切换用户态上下文（无需内核）。  </li><li><strong>若协程 B 在 T2 上</strong>：  <ul><li>调度器将协程 B 的上下文绑定到 T2。  </li><li>线程 T2 的事件循环会自动执行协程 B。  </li><li><strong>线程 T1 和 T2 的切换由操作系统调度，但协程本身的切换仍是用户态的</strong>。</li></ul></li></ol><hr><h4 id="3-2-线程切换与协程切换的区别"><a href="#3-2-线程切换与协程切换的区别" class="headerlink" title="3.2 线程切换与协程切换的区别"></a><strong>3.2 线程切换与协程切换的区别</strong></h4><div class="table-container"><table><thead><tr><th><strong>维度</strong></th><th><strong>用户态协程切换</strong></th><th><strong>操作系统线程切换</strong></th></tr></thead><tbody><tr><td><strong>触发方式</strong></td><td>显式触发（如 <code>await</code>）</td><td>隐式触发（如时间片耗尽）</td></tr><tr><td><strong>上下文保存</strong></td><td>仅保存用户态寄存器和栈</td><td>保存全部寄存器，包括内核状态</td></tr><tr><td><strong>是否需内核</strong></td><td>否（纯用户态操作）</td><td>是（需陷入内核，调用 <code>context_switch</code>）</td></tr><tr><td><strong>开销</strong></td><td>纳秒级（几十 ns）</td><td>微秒级（几千 ns）</td></tr></tbody></table></div><hr><h3 id="4-为什么用户态协程的切换不需要内核参与？"><a href="#4-为什么用户态协程的切换不需要内核参与？" class="headerlink" title="4. 为什么用户态协程的切换不需要内核参与？"></a><strong>4. 为什么用户态协程的切换不需要内核参与？</strong></h3><h4 id="4-1-协程切换的自主性"><a href="#4-1-协程切换的自主性" class="headerlink" title="4.1 协程切换的自主性"></a><strong>4.1 协程切换的自主性</strong></h4><ul><li><strong>无需系统调用</strong>：协程的切换逻辑完全由用户态代码实现，无需通过 <code>syscall</code> 进入内核。  </li><li><strong>寄存器直接操作</strong>：通过汇编代码直接操作寄存器（如 <code>movq</code>），无需内核干预。  </li></ul><h4 id="4-2-线程切换的必要性"><a href="#4-2-线程切换的必要性" class="headerlink" title="4.2 线程切换的必要性"></a><strong>4.2 线程切换的必要性</strong></h4><ul><li><strong>线程是内核资源</strong>：线程由操作系统创建和管理，其切换必须通过内核调度。  </li><li><strong>协程与线程的关系</strong>：  <ul><li>协程的切换不改变线程的运行状态，仅改变用户态的执行上下文。  </li><li>线程切换（如 T1 → T2）由操作系统触发，但这是独立于协程调度的事件。  </li></ul></li></ul><hr><h3 id="5-典型场景：Rust-Tokio-的多线程模型"><a href="#5-典型场景：Rust-Tokio-的多线程模型" class="headerlink" title="5. 典型场景：Rust Tokio 的多线程模型"></a><strong>5. 典型场景：Rust Tokio 的多线程模型</strong></h3><h4 id="5-1-执行流程"><a href="#5-1-执行流程" class="headerlink" title="5.1 执行流程"></a><strong>5.1 执行流程</strong></h4><ol><li><strong>协程 A 在线程 T1 上运行</strong>：  <ul><li>执行到 <code>await TcpStream::connect</code> 时，协程主动挂起。  </li><li>用户态调度器保存协程 A 的上下文（寄存器、栈指针）。  </li></ul></li><li><strong>I/O 事件触发</strong>：  <ul><li>网络连接就绪后，通过 <code>Waker</code> 唤醒协程 A。  </li></ul></li><li><strong>协程 A 的恢复</strong>：  <ul><li>调度器选择线程 T1 或 T2 来恢复协程 A。  </li><li><strong>若选择 T2</strong>：  <ul><li>协程 A 的上下文绑定到 T2。  </li><li>T2 的事件循环直接恢复协程 A 的用户态上下文（无需内核参与）。  </li></ul></li></ul></li><li><strong>线程 T1/T2 的切换</strong>：  <ul><li>由操作系统调度（如 T1 时间片用完），但协程切换本身仍由用户态完成。</li></ul></li></ol><hr><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a><strong>6. 总结</strong></h3><ul><li><strong>用户态协程切换</strong>：  <ul><li>通过保存/恢复寄存器和栈，在用户态完成，无需内核参与。  </li><li>与线程切换无关，即使协程分布在多个线程上。  </li></ul></li><li><strong>线程切换</strong>：  <ul><li>由操作系统管理，涉及内核态，但与协程调度是独立的。  </li><li>协程可以自由分配到不同线程，但切换协程本身不触发线程切换。  </li></ul></li></ul><p><strong>关键结论</strong>：<br>用户态协程的切换始终在用户态完成，即使系统使用多线程模型，协程的切换逻辑仍由用户态代码自主控制，无需操作系统介入。线程切换是独立的事件，用于利用多核资源或处理计算密集型任务。</p><p>在 Rust 开发中，<strong>线程的创建和切换是否直观可见，取决于你选择的并发模型</strong>。以下是详细解释：</p><hr><h3 id="1-线程与协程的区别"><a href="#1-线程与协程的区别" class="headerlink" title="1. 线程与协程的区别"></a><strong>1. 线程与协程的区别</strong></h3><h4 id="1-1-线程（Thread）"><a href="#1-1-线程（Thread）" class="headerlink" title="1.1 线程（Thread）"></a><strong>1.1 线程（Thread）</strong></h4><ul><li><strong>定义</strong>：操作系统级别的资源，由操作系统调度，拥有独立的栈和 CPU 时间片。</li><li><strong>特点</strong>：  <ul><li><strong>显式控制</strong>：通过 <code>std::thread</code> 直接创建和管理线程。  </li><li><strong>开销较大</strong>：创建和切换需要系统调用（如 <code>clone</code> 或 <code>CreateThread</code>）。  </li><li><strong>适合场景</strong>：计算密集型任务或需要独立执行的长期任务。</li></ul></li></ul><h4 id="1-2-协程（Coroutine）"><a href="#1-2-协程（Coroutine）" class="headerlink" title="1.2 协程（Coroutine）"></a><strong>1.2 协程（Coroutine）</strong></h4><ul><li><strong>定义</strong>：用户态的轻量级任务，由运行时（如 Tokio、async-std）管理，无需操作系统介入。</li><li><strong>特点</strong>：  <ul><li><strong>非抢占式</strong>：通过 <code>await</code> 显式切换，无需系统调用。  </li><li><strong>低开销</strong>：切换仅需保存/恢复用户态栈状态。  </li><li><strong>适合场景</strong>：高并发 I/O 操作（如网络请求、文件读写）。</li></ul></li></ul><hr><h3 id="2-显式线程管理（std-thread）"><a href="#2-显式线程管理（std-thread）" class="headerlink" title="2. 显式线程管理（std::thread）"></a><strong>2. 显式线程管理（std::thread）</strong></h3><h4 id="2-1-开发者能直观感受到线程的存在"><a href="#2-1-开发者能直观感受到线程的存在" class="headerlink" title="2.1 开发者能直观感受到线程的存在"></a><strong>2.1 开发者能直观感受到线程的存在</strong></h4><p>通过 <code>std::thread</code>，开发者可以<strong>直接创建、管理线程</strong>，并能感知到线程的切换和执行状态：<br></p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="comment">// 显式创建线程</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Child thread started"</span>);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Child thread exiting"</span>);</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程继续执行</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Main thread is doing something..."</span>);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待子线程完成</span></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Main thread done"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="2-2-线程的可见性"><a href="#2-2-线程的可见性" class="headerlink" title="2.2 线程的可见性"></a><strong>2.2 线程的可见性</strong></h4><ul><li><strong>线程 ID</strong>：可以通过 <code>thread::current().id()</code> 获取线程标识。  </li><li><strong>同步与通信</strong>：需要显式使用 <code>Mutex</code>、<code>Channel</code> 等同步原语。  </li><li><strong>手动调度</strong>：开发者需管理线程的生命周期（如 <code>join</code>、<code>detach</code>）。</li></ul><hr><h3 id="3-异步编程（async-await）"><a href="#3-异步编程（async-await）" class="headerlink" title="3. 异步编程（async/await）"></a><strong>3. 异步编程（async/await）</strong></h3><h4 id="3-1-用户态协程的抽象"><a href="#3-1-用户态协程的抽象" class="headerlink" title="3.1 用户态协程的抽象"></a><strong>3.1 用户态协程的抽象</strong></h4><p>在异步编程中（如 Tokio、async-std 运行时），<strong>线程的管理被抽象</strong>，开发者主要与协程（Future）交互：<br></p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Tokio 运行时</span></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Async task started"</span>);</span><br><span class="line">        tokio::time::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>)).<span class="keyword">await</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Async task exiting"</span>);</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Main task is doing something..."</span>);</span><br><span class="line">    tokio::time::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>)).<span class="keyword">await</span>;</span><br><span class="line"></span><br><span class="line">    handle.<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Main task done"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="3-2-线程的不可见性"><a href="#3-2-线程的不可见性" class="headerlink" title="3.2 线程的不可见性"></a><strong>3.2 线程的不可见性</strong></h4><ul><li><strong>线程由运行时管理</strong>：  <ul><li>协程的切换在用户态完成（无需操作系统参与），但<strong>底层可能运行在多个线程上</strong>。  </li><li>运行时（如 Tokio）会自动分配协程到线程池中的线程。  </li></ul></li><li><strong>开发者感知不到线程切换</strong>：  <ul><li>通过 <code>await</code> 显式让出控制权，但实际线程切换由运行时决定。  </li><li>例如，一个协程可能在线程 A 执行，挂起后被运行时分配到线程 B 继续执行。</li></ul></li></ul><hr><h3 id="4-两种模型的对比"><a href="#4-两种模型的对比" class="headerlink" title="4. 两种模型的对比"></a><strong>4. 两种模型的对比</strong></h3><div class="table-container"><table><thead><tr><th><strong>特性</strong></th><th><strong>显式线程（std::thread）</strong></th><th><strong>异步协程（async/await）</strong></th></tr></thead><tbody><tr><td><strong>线程控制</strong></td><td>显式创建、管理线程</td><td>线程由运行时自动管理</td></tr><tr><td><strong>切换机制</strong></td><td>操作系统调度线程切换</td><td>用户态协程切换（无需内核）</td></tr><tr><td><strong>可见性</strong></td><td>可感知线程 ID 和生命周期</td><td>无法直接感知线程细节</td></tr><tr><td><strong>适用场景</strong></td><td>计算密集型、需要精细控制</td><td>高并发 I/O、网络请求</td></tr><tr><td><strong>代码复杂度</strong></td><td>需处理同步原语（Mutex等）</td><td>通过 <code>await</code> 简化代码</td></tr></tbody></table></div><hr><h3 id="5-是否只能通过-async-await-进行协程切换？"><a href="#5-是否只能通过-async-await-进行协程切换？" class="headerlink" title="5. 是否只能通过 async/await 进行协程切换？"></a><strong>5. 是否只能通过 async/await 进行协程切换？</strong></h3><p><strong>不是</strong>。虽然 <code>async/await</code> 是 Rust 异步编程的主流方式，但协程切换的底层机制可以通过以下方式实现：</p><ol><li><strong>手动实现 <code>Future</code> trait</strong>：<br>定义 <code>Future</code> 的 <code>poll</code> 方法，显式控制任务状态（就绪、挂起）。  </li><li><strong>其他运行时</strong>：<br>如 <code>async-std</code>、<code>smol</code> 等，提供不同的协程调度策略。  </li><li><strong>低级原语</strong>：<br>使用 <code>std::task</code> 模块中的 <code>Waker</code> 和 <code>Context</code> 手动触发协程切换。</li></ol><hr><h3 id="6-总结-1"><a href="#6-总结-1" class="headerlink" title="6. 总结"></a><strong>6. 总结</strong></h3><ul><li><strong>显式线程（std::thread）</strong>：<br>开发者能直接感知线程的创建、切换和生命周期，适合需要精细控制的场景。  </li><li><strong>异步协程（async/await）</strong>：<br>线程管理被抽象，开发者通过 <code>await</code> 简化代码，但底层仍依赖线程池。<br><strong>线程仍然存在</strong>，只是由运行时（如 Tokio）自动分配和调度。</li></ul><hr><h3 id="7-开发建议"><a href="#7-开发建议" class="headerlink" title="7. 开发建议"></a><strong>7. 开发建议</strong></h3><ul><li><strong>选择显式线程</strong>：<br>当需要直接控制线程（如多核计算、自定义线程池）或处理计算密集型任务时。  </li><li><strong>选择异步模型</strong>：<br>当处理高并发 I/O（如 Web 服务器、网络应用）时，优先使用 <code>async/await</code>，通过运行时自动管理线程。  </li><li><strong>混合使用</strong>：<br>对于混合场景（如 I/O + 计算），可通过 <code>tokio::task::spawn_blocking</code> 将计算任务提交到线程池。</li></ul><p>通过理解这两种模型的差异，开发者可以灵活选择最适合的并发策略。</p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Poetry在Mac上构建项目的全流程指南</title>
      <link href="/posts/6821884a.html"/>
      <url>/posts/6821884a.html</url>
      
        <content type="html"><![CDATA[<h1 id="Poetry在Mac上构建项目的全流程指南"><a href="#Poetry在Mac上构建项目的全流程指南" class="headerlink" title="Poetry在Mac上构建项目的全流程指南"></a>Poetry在Mac上构建项目的全流程指南</h1><h2 id="一、安装Poetry"><a href="#一、安装Poetry" class="headerlink" title="一、安装Poetry"></a>一、安装Poetry</h2><p>在Mac上有几种安装Poetry的方法：</p><h3 id="方法1：使用Homebrew（推荐）"><a href="#方法1：使用Homebrew（推荐）" class="headerlink" title="方法1：使用Homebrew（推荐）"></a>方法1：使用Homebrew（推荐）</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装Homebrew（如果尚未安装）</span></span><br><span class="line">/bin/bash -c <span class="string">"<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Homebrew安装Poetry</span></span><br><span class="line">brew install poetry</span><br></pre></td></tr></tbody></table></figure><p>Homebrew是macOS的包管理器，通过它安装Poetry最为便捷。</p><h3 id="方法2：使用官方安装脚本"><a href="#方法2：使用官方安装脚本" class="headerlink" title="方法2：使用官方安装脚本"></a>方法2：使用官方安装脚本</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://install.python-poetry.org | python3 -</span><br></pre></td></tr></tbody></table></figure><p>此命令会下载并运行官方安装脚本。</p><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry --version</span><br></pre></td></tr></tbody></table></figure><h3 id="配置环境变量（如果需要）"><a href="#配置环境变量（如果需要）" class="headerlink" title="配置环境变量（如果需要）"></a>配置环境变量（如果需要）</h3><p>如果使用官方脚本安装，可能需要将Poetry添加到PATH：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于Zsh用户</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH="$HOME/.local/bin:$PATH"'</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></tbody></table></figure><br>这将把Poetry添加到你的shell配置中。<p></p><h2 id="二、创建新项目"><a href="#二、创建新项目" class="headerlink" title="二、创建新项目"></a>二、创建新项目</h2><h3 id="1-创建新项目"><a href="#1-创建新项目" class="headerlink" title="1. 创建新项目"></a>1. 创建新项目</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">poetry new my-project</span><br><span class="line"><span class="built_in">cd</span> my-project</span><br></pre></td></tr></tbody></table></figure><p>这会创建一个包含基本项目结构的目录，包括pyproject.toml文件和src目录。</p><h3 id="2-项目结构说明"><a href="#2-项目结构说明" class="headerlink" title="2. 项目结构说明"></a>2. 项目结构说明</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my-project/</span><br><span class="line">├── pyproject.toml  # 项目配置文件</span><br><span class="line">├── README.md</span><br><span class="line">├── my_project/     # 源代码目录</span><br><span class="line">│   └── __init__.py</span><br><span class="line">└── tests/          # 测试目录</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    └── test_my_project.py</span><br></pre></td></tr></tbody></table></figure><h2 id="三、配置项目"><a href="#三、配置项目" class="headerlink" title="三、配置项目"></a>三、配置项目</h2><h3 id="1-编辑pyproject-toml"><a href="#1-编辑pyproject-toml" class="headerlink" title="1. 编辑pyproject.toml"></a>1. 编辑pyproject.toml</h3><p>打开pyproject.toml文件，配置项目信息：<br></p><figure class="highlight toml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.poetry]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"my-project"</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">"0.1.0"</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">"一个示例项目"</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">"Your Name &lt;your.email@example.com&gt;"</span>]</span><br><span class="line"><span class="attr">readme</span> = <span class="string">"README.md"</span></span><br><span class="line"></span><br><span class="line"><span class="section">[tool.poetry.dependencies]</span></span><br><span class="line"><span class="attr">python</span> = <span class="string">"^3.8"</span></span><br><span class="line"></span><br><span class="line"><span class="section">[build-system]</span></span><br><span class="line"><span class="attr">requires</span> = [<span class="string">"poetry-core"</span>]</span><br><span class="line"><span class="attr">build-backend</span> = <span class="string">"poetry.core.masonry.api"</span></span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="2-配置虚拟环境（可选但推荐）"><a href="#2-配置虚拟环境（可选但推荐）" class="headerlink" title="2. 配置虚拟环境（可选但推荐）"></a>2. 配置虚拟环境（可选但推荐）</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry config virtualenvs.in-project <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure><p>这会将虚拟环境创建在项目目录中（.venv文件夹），便于团队协作。</p><h2 id="四、添加依赖"><a href="#四、添加依赖" class="headerlink" title="四、添加依赖"></a>四、添加依赖</h2><h3 id="1-添加主依赖"><a href="#1-添加主依赖" class="headerlink" title="1. 添加主依赖"></a>1. 添加主依赖</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry add requests</span><br></pre></td></tr></tbody></table></figure><p>这会安装requests库并自动更新pyproject.toml和poetry.lock文件。</p><h3 id="2-添加开发依赖（如测试框架）"><a href="#2-添加开发依赖（如测试框架）" class="headerlink" title="2. 添加开发依赖（如测试框架）"></a>2. 添加开发依赖（如测试框架）</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry add --group dev pytest black</span><br></pre></td></tr></tbody></table></figure><p>使用<code>--group dev</code>参数添加仅用于开发的依赖。</p><h2 id="五、开发环境设置"><a href="#五、开发环境设置" class="headerlink" title="五、开发环境设置"></a>五、开发环境设置</h2><h3 id="1-安装项目依赖"><a href="#1-安装项目依赖" class="headerlink" title="1. 安装项目依赖"></a>1. 安装项目依赖</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry install</span><br></pre></td></tr></tbody></table></figure><p>此命令会根据pyproject.toml安装所有依赖，并创建虚拟环境（如果尚未创建）。</p><h3 id="2-激活虚拟环境"><a href="#2-激活虚拟环境" class="headerlink" title="2. 激活虚拟环境"></a>2. 激活虚拟环境</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry shell</span><br></pre></td></tr></tbody></table></figure><p>这会启动一个新的shell会话，其中已激活项目的虚拟环境。</p><p>或者，不激活环境直接运行命令：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry run python your_script.py</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="六、编写代码"><a href="#六、编写代码" class="headerlink" title="六、编写代码"></a>六、编写代码</h2><ol><li>在<code>src/my_project/</code>目录下编写你的Python代码</li><li>在<code>tests/</code>目录下编写测试代码</li></ol><p>示例：编辑<code>src/my_project/__init__.py</code><br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"Hello, <span class="subst">{name}</span>!"</span></span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="七、运行测试"><a href="#七、运行测试" class="headerlink" title="七、运行测试"></a>七、运行测试</h2><ol><li><p>编写测试文件<code>tests/test_my_project.py</code>：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_project <span class="keyword">import</span> greet</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_greet</span>():</span><br><span class="line">    <span class="keyword">assert</span> greet(<span class="string">"World"</span>) == <span class="string">"Hello, World!"</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>运行测试：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry run pytest</span><br></pre></td></tr></tbody></table></figure><p>这会使用项目虚拟环境中的pytest运行测试。</p></li></ol><h2 id="八、构建和发布项目"><a href="#八、构建和发布项目" class="headerlink" title="八、构建和发布项目"></a>八、构建和发布项目</h2><h3 id="1-构建项目"><a href="#1-构建项目" class="headerlink" title="1. 构建项目"></a>1. 构建项目</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry build</span><br></pre></td></tr></tbody></table></figure><p>这会生成dist目录，包含wheel和源码分发包。</p><h3 id="2-发布到PyPI（可选）"><a href="#2-发布到PyPI（可选）" class="headerlink" title="2. 发布到PyPI（可选）"></a>2. 发布到PyPI（可选）</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先配置PyPI令牌</span></span><br><span class="line">poetry config pypi-token.pypi your-api-token</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后发布</span></span><br><span class="line">poetry publish</span><br></pre></td></tr></tbody></table></figure><h2 id="九、常用命令总结"><a href="#九、常用命令总结" class="headerlink" title="九、常用命令总结"></a>九、常用命令总结</h2><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>poetry init</code></td><td>交互式创建新项目（现有目录）</td></tr><tr><td><code>poetry add package</code></td><td>添加依赖</td></tr><tr><td><code>poetry remove package</code></td><td>移除依赖</td></tr><tr><td><code>poetry update</code></td><td>更新所有依赖</td></tr><tr><td><code>poetry show --tree</code></td><td>查看依赖树</td></tr><tr><td><code>poetry env info</code></td><td>查看虚拟环境信息</td></tr><tr><td><code>poetry run command</code></td><td>在虚拟环境中运行命令</td></tr></tbody></table></div><p>Poetry会自动管理项目环境隔离，确保工作始终与全局Python安装隔离。</p><h2 id="十、完整工作流程示例"><a href="#十、完整工作流程示例" class="headerlink" title="十、完整工作流程示例"></a>十、完整工作流程示例</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建并进入项目目录</span></span><br><span class="line"><span class="built_in">mkdir</span> myapp &amp;&amp; <span class="built_in">cd</span> myapp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 初始化项目</span></span><br><span class="line">poetry init  <span class="comment"># 交互式创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 配置虚拟环境在项目内</span></span><br><span class="line">poetry config virtualenvs.in-project <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 添加依赖</span></span><br><span class="line">poetry add flask</span><br><span class="line">poetry add --group dev pytest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 创建源代码目录和文件</span></span><br><span class="line"><span class="built_in">mkdir</span> -p src/myapp</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'def hello(): return "Hello World!"'</span> &gt; src/myapp/__init__.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 创建测试</span></span><br><span class="line"><span class="built_in">mkdir</span> tests</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'from myapp import hello; def test_hello(): assert hello() == "Hello World!"'</span> &gt; tests/test_app.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 运行测试</span></span><br><span class="line">poetry run pytest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 构建项目</span></span><br><span class="line">poetry build</span><br></pre></td></tr></tbody></table></figure><p>通过以上步骤，你可以在Mac上使用Poetry完整地创建、开发和构建Python项目。</p>]]></content>
      
      
      <categories>
          
          <category> Poetry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Poetry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<h3 id="SpotBugs-文档"><a href="#SpotBugs-文档" class="headerlink" title="SpotBugs 文档"></a>SpotBugs 文档</h3><h4 id="1-SpotBugs-介绍"><a href="#1-SpotBugs-介绍" class="headerlink" title="1. SpotBugs 介绍"></a>1. SpotBugs 介绍</h4><p><strong>SpotBugs 是什么？</strong><br>SpotBugs 是一个强大的静态分析工具，旨在帮助开发者发现并修复 Java 代码中的潜在缺陷和漏洞。它是 FindBugs 的继任者，在其基础上进行了改进和发展，致力于提供更准确、高效的代码质量检查。</p><p><strong>官网</strong></p><ul><li>官方网站: <a href="https://spotbugs.github.io/">https://spotbugs.github.io/</a></li><li>文档参考: <a href="http://spotbugs.readthedocs.io/en/latest/">SpotBugs Documentation</a></li></ul><p><strong>侧重点</strong><br>SpotBugs 的主要侧重点在于通过扫描 Java 字节码来发现潜在的问题，例如空指针引用、类型转换错误、未使用的变量等。它不仅可以检测代码中的逻辑错误，还可以识别安全相关的隐患，如 SQL 注入、XSS 攻击等。此外，SpotBugs 提供了用户友好的 GUI 和命令行接口，能够轻松与各种构建工具和 IDE 集成。</p><h4 id="2-如何使用-SpotBugs"><a href="#2-如何使用-SpotBugs" class="headerlink" title="2. 如何使用 SpotBugs"></a>2. 如何使用 SpotBugs</h4><h5 id="独立使用"><a href="#独立使用" class="headerlink" title="独立使用"></a>独立使用</h5><ul><li><strong>下载与安装</strong>: 访问 <a href="https://github.com/spotbugs/spotbugs/releases">SpotBugs GitHub Releases</a> 页面下载最新版本的 SpotBugs 发行版压缩包（例如 <code>spotbugs-4.x.x.zip</code>）。解压到指定目录，并确保 JDK 已正确安装。</li><li><strong>运行分析</strong>: 打开命令提示符或终端窗口，导航到 SpotBugs 的 bin 目录，然后使用如下命令来分析项目：<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spotbugs -textui -output output.xml -effort:max -low -progress -nested:<span class="literal">false</span> -exclude exclude.xml your_project.jar</span><br></pre></td></tr></tbody></table></figure>解释：<ul><li><code>-textui</code>: 以文本用户界面模式运行。</li><li><code>-output</code>: 指定输出报告文件的位置和名称。</li><li><code>-effort:max</code>: 设置最大分析努力程度。</li><li><code>-low</code>: 包括所有级别的警告（默认是中等及以上）。</li><li><code>-progress</code>: 显示进度信息。</li><li><code>-nested:false</code>: 关闭嵌套类分析。</li><li><code>-exclude</code>: 指定排除规则文件（如果有的话），用来忽略特定的代码段或类。</li><li><code>your_project.jar</code>: 要分析的目标 JAR 文件或编译后的类文件夹。</li></ul></li></ul><h5 id="结合-IntelliJ-IDEA-使用"><a href="#结合-IntelliJ-IDEA-使用" class="headerlink" title="结合 IntelliJ IDEA 使用"></a>结合 IntelliJ IDEA 使用</h5><ul><li><strong>安装插件</strong>: 打开 IntelliJ IDEA，进入 <code>IntelliJ IDEA</code> &gt; <code>Preferences</code> &gt; <code>Plugins</code>，在 Marketplace 中搜索 <code>SpotBugs</code> 并点击 <code>Install</code> 安装插件。安装完成后，重启 IDE。</li><li><strong>配置插件</strong>: 再次进入 <code>Preferences</code>，导航到 <code>Tools</code> &gt; <code>SpotBugs</code>，在这里你可以配置 SpotBugs 的各种选项，包括是否启用插件、分析范围等。</li><li><strong>启动分析</strong>: 右键点击项目或模块，在上下文菜单中选择 <code>Analyze | Inspect Code</code> 或者直接通过快捷键启动分析。</li><li><strong>查看报告</strong>: 分析完成后，IDEA 会在底部或右侧打开一个名为 “Inspection Results” 或 “SpotBugs” 的工具窗口，列出所有的发现项。</li></ul><h5 id="结合-Maven-使用"><a href="#结合-Maven-使用" class="headerlink" title="结合 Maven 使用"></a>结合 Maven 使用</h5><ul><li><strong>添加依赖</strong>: 在项目的 <code>pom.xml</code> 文件中添加以下依赖项：<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.spotbugs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spotbugs-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>最新版本号<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 插件配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><strong>执行分析</strong>: 使用 Maven 命令 <code>mvn spotbugs:check</code> 来触发 SpotBugs 分析。这将根据配置生成报告并将其集成到构建过程中。</li></ul><h5 id="其他使用方式"><a href="#其他使用方式" class="headerlink" title="其他使用方式"></a>其他使用方式</h5><ul><li><strong>Gradle 构建工具</strong>: 类似于 Maven，可以在 <code>build.gradle</code> 文件中添加 SpotBugs 插件，并通过 <code>gradle spotbugsMain</code> 等命令进行分析。</li><li><strong>Eclipse 插件</strong>: 如果你使用 Eclipse 作为开发环境，也可以安装 SpotBugs 插件来增强 IDE 的功能。</li><li><strong>Ant 构建脚本</strong>: 对于仍然使用 Ant 的项目，可以通过定义任务的方式集成 SpotBugs 分析。</li></ul><h4 id="3-SpotBugs-分析代码的结果详细解读"><a href="#3-SpotBugs-分析代码的结果详细解读" class="headerlink" title="3. SpotBugs 分析代码的结果详细解读"></a>3. SpotBugs 分析代码的结果详细解读</h4><p>代码审查结果<br>Bad practice：不佳实践：常见代码错误，用于静态代码检查时进行缺陷模式匹配(如重写equals但没重写 hashCode，或相反情况等)<br>Correctness：可能导致错误的代码(如空指针引用、无限循环等)<br>Internationalization：国际化相关问题（如错误的字符串转换等）<br>Experimental：实验性<br>Security： 安全问题（如HTTP，SQL，DB等）<br>Dodgy code： 导致自身错误的代码（如未确认的强制转换、冗余的空值检查等）<br>Performance：运行时性能问题（如由变量定义，方法调用导致的代码低效问题等）<br>Malicious code vulnerability：可能受到的恶意攻击（如访问权限修饰符的定义等）<br>Multithreaded correctness：多线程的正确性（如多线程编程时常见的同步，线程调度问题等）</p><p>SpotBugs 会生成详细的报告，指出潜在的问题及其位置。每个问题都会标明具体的 Bug Pattern 名称、严重程度以及受影响的代码位置。以下是常见的 Bug Patterns 及其解释：</p><h4 id="1-空指针引用-NP"><a href="#1-空指针引用-NP" class="headerlink" title="1. 空指针引用 (NP)"></a>1. <strong>空指针引用 (NP)</strong></h4><ul><li><strong>示例</strong>：<code>NP_NULL_ON_SOME_PATH</code></li><li><strong>描述</strong>：在某些路径上可能发生空指针异常，这可能导致应用程序崩溃或不可预测的行为。</li><li><strong>建议</strong>：确保所有对象引用都经过适当的 null 检查，并使用防御性编程实践来避免此类问题。</li></ul><h4 id="2-资源泄漏-OBL-OS"><a href="#2-资源泄漏-OBL-OS" class="headerlink" title="2. 资源泄漏 (OBL, OS)"></a>2. <strong>资源泄漏 (OBL, OS)</strong></h4><ul><li><strong>示例</strong>：<code>OBL_UNSATISFIED_OBLIGATION</code>, <code>OS_OPEN_STREAM</code></li><li><strong>描述</strong>：打开的资源（如文件、网络连接等）没有正确关闭，可能会导致内存泄露或其他资源耗尽的情况。</li><li><strong>建议</strong>：使用 try-with-resources 或者 finally 块来确保资源总是能被正确释放。</li></ul><h4 id="3-不安全的反序列化-SEC"><a href="#3-不安全的反序列化-SEC" class="headerlink" title="3. 不安全的反序列化 (SEC)"></a>3. <strong>不安全的反序列化 (SEC)</strong></h4><ul><li><strong>示例</strong>：<code>SEC_INJECTION_JAVA</code>, <code>SEC_DESERIALIZE</code></li><li><strong>描述</strong>：允许不受信任的数据进行反序列化操作，容易引发远程代码执行等严重安全风险。</li><li><strong>建议</strong>：严格限制可以反序列化的类，并对输入数据进行充分验证。</li></ul><h4 id="4-SQL-注入-SEC"><a href="#4-SQL-注入-SEC" class="headerlink" title="4. SQL 注入 (SEC)"></a>4. <strong>SQL 注入 (SEC)</strong></h4><ul><li><strong>示例</strong>：<code>SEC_SQL_INJECTION</code></li><li><strong>描述</strong>：未正确转义用户输入的 SQL 查询构造，可能导致恶意用户注入任意 SQL 语句。</li><li><strong>建议</strong>：使用参数化查询或 ORM 框架来构建 SQL 语句，避免直接拼接字符串。</li></ul><h4 id="5-跨站脚本攻击-XSS-SEC"><a href="#5-跨站脚本攻击-XSS-SEC" class="headerlink" title="5. 跨站脚本攻击 (XSS) (SEC)"></a>5. <strong>跨站脚本攻击 (XSS) (SEC)</strong></h4><ul><li><strong>示例</strong>：<code>SEC_XSS_REFLECTED</code></li><li><strong>描述</strong>：未经验证的用户输入直接输出到网页中，可能导致恶意脚本注入。</li><li><strong>建议</strong>：对所有用户提供的内容进行 HTML 编码，并采用合适的输出编码方式。</li></ul><h4 id="6-硬编码密码-SEC"><a href="#6-硬编码密码-SEC" class="headerlink" title="6. 硬编码密码 (SEC)"></a>6. <strong>硬编码密码 (SEC)</strong></h4><ul><li><strong>示例</strong>：<code>SEC_HARDCODED_PASSWORD</code></li><li><strong>描述</strong>：代码中存在硬编码的敏感信息，如密码、API 密钥等。</li><li><strong>建议</strong>：将敏感信息存储在配置文件或环境变量中，并通过加密手段保护其安全性。</li></ul><h4 id="7-不必要的同步-MT"><a href="#7-不必要的同步-MT" class="headerlink" title="7. 不必要的同步 (MT)"></a>7. <strong>不必要的同步 (MT)</strong></h4><ul><li><strong>示例</strong>：<code>MT_SYNC_ON_STATIC</code></li><li><strong>描述</strong>：在静态方法或字段上使用 synchronized 关键字，可能导致性能瓶颈或死锁。</li><li><strong>建议</strong>：评估是否真的需要同步机制，并考虑其他并发控制策略，如读写锁。</li></ul><h4 id="8-性能问题-PERF"><a href="#8-性能问题-PERF" class="headerlink" title="8. 性能问题 (PERF)"></a>8. <strong>性能问题 (PERF)</strong></h4><ul><li><strong>示例</strong>：<code>PERF_PESSIMISTIC_STRING_CONCATENATION</code></li><li><strong>描述</strong>：使用 + 运算符在循环体内进行字符串连接，效率低下。</li><li><strong>建议</strong>：改用 StringBuilder 或 StringBuffer 来优化字符串操作。</li></ul><h4 id="4-结果里面研发需要关注的重点事项"><a href="#4-结果里面研发需要关注的重点事项" class="headerlink" title="4. 结果里面研发需要关注的重点事项"></a>4. 结果里面研发需要关注的重点事项</h4><p>以下是一些常见且重要的 Bug Patterns，它们应当引起研发团队的高度关注：</p><ul><li><strong>高优先级问题</strong>：这些问题通常表示严重的错误或潜在的安全漏洞，必须尽快修复。例如，空指针引用、资源泄漏、不安全的反序列化、SQL 注入、XSS 攻击等。</li><li><strong>中优先级问题</strong>：虽然不如高优先级那么紧急，但仍然可能影响程序的行为或性能。例如，不必要的同步、性能问题等。</li><li><strong>低优先级问题</strong>：这类问题通常是建议性的改进，可以在后续版本中考虑。不过，对于新项目来说，尽量避免引入这些低级别的问题也是很重要的。</li></ul><h4 id="5-持续根据使用计划或方式"><a href="#5-持续根据使用计划或方式" class="headerlink" title="5. 持续根据使用计划或方式"></a>5. 持续根据使用计划或方式</h4><p>为了确保代码质量和安全性，建议定期运行 SpotBugs 分析，并将分析结果纳入持续集成（CI）流程中。这样可以自动捕获新引入的问题，并提醒开发人员及时处理。具体做法包括：</p><ul><li><strong>定期复查</strong>：随着项目的演进，应该定期重新运行 SpotBugs 分析，确保新引入的代码没有带来新的问题。</li><li><strong>团队协作</strong>：鼓励团队成员共同审查分析结果，分享最佳实践，共同提升代码质量。</li><li><strong>自动化测试</strong>：结合单元测试、集成测试以及其他形式的安全评估，可以更有效地保障应用程序的安全性。</li><li><strong>更新工具</strong>：保持 SpotBugs 和相关插件的最新状态，利用最新的规则集和技术来提高分析的准确性。</li><li><strong>误报管理</strong>：对于确定为误报的问题，可以通过 <code>@SuppressFBWarnings</code> 注解抑制警告，同时附上合理的理由，避免不必要的干扰。</li></ul><p>通过遵循上述指南，你可以充分利用 SpotBugs 的功能，确保代码的质量和安全性。如果有更多具体的问题或需要进一步的帮助，请随时提问！</p><p>解读 SpotBugs 的检查结果并确定哪些问题需要研发团队重点关注是一个关键步骤，以确保代码质量和安全性。SpotBugs 会根据不同的 Bug Pattern（缺陷模式）标记潜在的问题，每个问题都有一个优先级（Priority）和严重程度（Rank），这有助于你快速识别出最紧迫的问题。以下是详细的解读指南以及哪些问题应该被研发团队优先处理。</p><h3 id="一、理解-SpotBugs-报告"><a href="#一、理解-SpotBugs-报告" class="headerlink" title="一、理解 SpotBugs 报告"></a>一、理解 SpotBugs 报告</h3><h4 id="1-Bug-Pattern"><a href="#1-Bug-Pattern" class="headerlink" title="1. Bug Pattern"></a>1. <strong>Bug Pattern</strong></h4><ul><li>每个问题都会有一个对应的 Bug Pattern 名称，描述了该问题的类型（例如，空指针异常、资源泄漏等）。了解这些模式可以帮助你更深入地理解问题的本质。</li></ul><h4 id="2-优先级-严重性"><a href="#2-优先级-严重性" class="headerlink" title="2. 优先级/严重性"></a>2. <strong>优先级/严重性</strong></h4><ul><li><strong>高优先级</strong>：这些问题通常表示严重的错误或潜在的安全漏洞，必须尽快修复。</li><li><strong>中优先级</strong>：虽然不如高优先级那么紧急，但仍然可能影响程序的行为或性能。</li><li><strong>低优先级</strong>：这类问题通常是建议性的改进，可以在后续版本中考虑。</li></ul><h4 id="3-位置信息"><a href="#3-位置信息" class="headerlink" title="3. 位置信息"></a>3. <strong>位置信息</strong></h4><ul><li>包括受影响的类名、方法名及行号，便于定位代码中的确切位置。</li></ul><h4 id="4-详细说明"><a href="#4-详细说明" class="headerlink" title="4. 详细说明"></a>4. <strong>详细说明</strong></h4><ul><li>提供了问题的原因、可能的影响以及推荐的修复措施。</li></ul><h3 id="二、需要重点关注的问题类型"><a href="#二、需要重点关注的问题类型" class="headerlink" title="二、需要重点关注的问题类型"></a>二、需要重点关注的问题类型</h3><p>以下是一些常见且重要的 Bug Pattern，它们应当引起研发团队的高度关注：</p><h3 id="三、排除误报"><a href="#三、排除误报" class="headerlink" title="三、排除误报"></a>三、排除误报</h3><p>并非所有报告的问题都是实际存在的缺陷，有时可能是误报。对于这种情况，可以通过以下方式处理：</p><ul><li><strong>手动审查</strong>：仔细检查代码逻辑，确认问题的真实性。</li><li><strong>添加注解</strong>：如果确定某个警告是误报，可以在代码中添加 <code>@SuppressFBWarnings</code> 注解，并附上合理的理由。</li></ul><h3 id="四、持续改进"><a href="#四、持续改进" class="headerlink" title="四、持续改进"></a>四、持续改进</h3><ul><li><strong>定期复查</strong>：随着项目的演进，应该定期重新运行 SpotBugs 分析，确保新引入的代码没有带来新的问题。</li><li><strong>团队协作</strong>：鼓励团队成员共同审查分析结果，分享最佳实践，共同提升代码质量。</li></ul><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>通过聚焦于上述提到的关键问题类型，研发团队可以更有针对性地进行代码优化和安全加固。同时，保持对 SpotBugs 分析结果的关注，及时响应新发现的问题，有助于维护高质量的软件产品。如果有更多具体的问题或需要进一步的帮助，请随时提问！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Common Table Expressions (CTE)</title>
      <link href="/posts/3691c40f.html"/>
      <url>/posts/3691c40f.html</url>
      
        <content type="html"><![CDATA[<h3 id="Common-Table-Expressions-CTE-的详细描述"><a href="#Common-Table-Expressions-CTE-的详细描述" class="headerlink" title="Common Table Expressions (CTE) 的详细描述"></a>Common Table Expressions (CTE) 的详细描述</h3><p>Common Table Expressions（通常称为 CTE 或者公共表表达式）是 SQL 中的一种结构，它允许你定义一个临时的结果集，并且可以在同一个查询中引用这个结果集。CTE 有助于简化复杂的查询，提高代码的可读性和维护性。它们特别适用于以下场景：</p><ol><li><strong>简化复杂查询</strong>：将复杂的逻辑分解成更小、更易管理的部分。</li><li><strong>递归查询</strong>：处理层级或树形结构的数据（如组织架构、分类目录等）。</li><li><strong>避免重复计算</strong>：对于需要多次使用相同子查询的情况，可以先通过 CTE 计算一次，然后在主查询中引用。</li></ol><h4 id="CTE-的主要特点"><a href="#CTE-的主要特点" class="headerlink" title="CTE 的主要特点"></a>CTE 的主要特点</h4><ul><li><strong>作用范围有限</strong>：CTE 只能在紧随其后的 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 语句中使用。</li><li><strong>一次性计算</strong>：CTE 中的结果集只计算一次，之后可以多次引用，减少了重复计算。</li><li><strong>可嵌套</strong>：可以在一个 CTE 内部引用另一个 CTE。</li><li><strong>支持递归</strong>：某些数据库系统（如 PostgreSQL、SQL Server）支持递归 CTE，用于处理层次结构数据。</li></ul><h3 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h3><p>为了更好地理解 CTE 的功能，下面通过几个具体例子来展示如何使用 CTE。</p><h4 id="示例-1：简化复杂查询"><a href="#示例-1：简化复杂查询" class="headerlink" title="示例 1：简化复杂查询"></a>示例 1：简化复杂查询</h4><p>假设我们有一个销售记录表 <code>sales</code> 和一个产品表 <code>products</code>，我们想要获取每个产品的总销售额以及销售数量。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> ProductSales <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        p.product_id,</span><br><span class="line">        p.product_name,</span><br><span class="line">        <span class="built_in">SUM</span>(s.amount) <span class="keyword">AS</span> total_sales,</span><br><span class="line">        <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sales_count</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        sales s</span><br><span class="line">    <span class="keyword">JOIN</span></span><br><span class="line">        products p <span class="keyword">ON</span> s.product_id <span class="operator">=</span> p.product_id</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">        p.product_id, p.product_name</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    product_name,</span><br><span class="line">    total_sales,</span><br><span class="line">    sales_count</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    ProductSales;</span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，<code>ProductSales</code> 是一个 CTE，它预先计算了每个产品的总销售额和销售次数。然后，在主查询中，我们可以简单地从 <code>ProductSales</code> 中选择所需的字段。</p><h4 id="示例-2：递归查询（以员工层级为例）"><a href="#示例-2：递归查询（以员工层级为例）" class="headerlink" title="示例 2：递归查询（以员工层级为例）"></a>示例 2：递归查询（以员工层级为例）</h4><p>假设我们有一个员工表 <code>employees</code>，其中包含员工 ID (<code>employee_id</code>)、经理 ID (<code>manager_id</code>) 和姓名 (<code>name</code>)。我们想构建一个报告来显示每个员工及其直接下属。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> EmployeeHierarchy <span class="keyword">AS</span> (</span><br><span class="line">    <span class="comment">-- 基础情况：选择没有经理的顶级员工（即最高层管理者）</span></span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        employee_id,</span><br><span class="line">        name,</span><br><span class="line">        manager_id,</span><br><span class="line">        <span class="number">0</span> <span class="keyword">AS</span> level</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        employees</span><br><span class="line">    <span class="keyword">WHERE</span></span><br><span class="line">        manager_id <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 递归部分：选择每个员工的直接下属，并增加层级计数</span></span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        e.employee_id,</span><br><span class="line">        e.name,</span><br><span class="line">        e.manager_id,</span><br><span class="line">        eh.level <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        employees e</span><br><span class="line">    <span class="keyword">JOIN</span></span><br><span class="line">        EmployeeHierarchy eh <span class="keyword">ON</span> e.manager_id <span class="operator">=</span> eh.employee_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    employee_id,</span><br><span class="line">    name,</span><br><span class="line">    manager_id,</span><br><span class="line">    level</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    EmployeeHierarchy</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    level, name;</span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，<code>EmployeeHierarchy</code> 是一个递归 CTE。首先，它选择了所有没有经理的顶级员工作为基础情况。然后，它递归地选择每个员工的直接下属，并为每一层增加一个层级计数。最终结果展示了整个公司的员工层级结构。</p><h4 id="示例-3：避免重复计算"><a href="#示例-3：避免重复计算" class="headerlink" title="示例 3：避免重复计算"></a>示例 3：避免重复计算</h4><p>考虑一个场景，我们需要从订单表 <code>orders</code> 中获取每个客户的最新订单信息（订单日期和金额），并且这些信息将在多个地方使用。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> LatestOrder <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        customer_id,</span><br><span class="line">        <span class="built_in">MAX</span>(order_date) <span class="keyword">AS</span> latest_order_date</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        orders</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">        customer_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    o.customer_id,</span><br><span class="line">    c.customer_name,</span><br><span class="line">    o.order_date,</span><br><span class="line">    o.amount</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    orders o</span><br><span class="line"><span class="keyword">JOIN</span></span><br><span class="line">    LatestOrder lo <span class="keyword">ON</span> o.customer_id <span class="operator">=</span> lo.customer_id <span class="keyword">AND</span> o.order_date <span class="operator">=</span> lo.latest_order_date</span><br><span class="line"><span class="keyword">JOIN</span></span><br><span class="line">    customers c <span class="keyword">ON</span> c.customer_id <span class="operator">=</span> o.customer_id;</span><br></pre></td></tr></tbody></table></figure><p>这里，<code>LatestOrder</code> CTE 计算了每个客户的最新订单日期。然后，主查询利用这个 CTE 来获取具体的订单信息，包括客户名称、订单日期和金额。这样就避免了在主查询中重复执行相同的聚合操作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CTE 提供了一种强大而灵活的方式来构建复杂的 SQL 查询。通过将查询逻辑拆分为易于理解的小块，CTE 不仅提高了代码的可读性和维护性，还能够优化性能，尤其是在涉及重复计算或递归查询的情况下。如果你有技术基础但对 CTE 不熟悉，希望上述示例能帮助你直观地了解这一功能的强大之处。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTE </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务端接口鉴权机制——HMAC</title>
      <link href="/posts/fb55061.html"/>
      <url>/posts/fb55061.html</url>
      
        <content type="html"><![CDATA[<p>符合AES加密要求的字符串作为密钥，并且这个字符串可以直接用于加密和解密操作，那么我们需要确保这个字符串具有正确的长度（16字节/AES-128, 24字节/AES-192, 或32字节/AES-256）。下面是一个具体的例子，使用一个32字符长的字符串作为AES-256的密钥。</p><h3 id="直接使用的密钥字符串"><a href="#直接使用的密钥字符串" class="headerlink" title="直接使用的密钥字符串"></a>直接使用的密钥字符串</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constants</span> {</span><br><span class="line">    <span class="comment">// 32 字符长的字符串，适用于 AES-256</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SHARED_SECRET</span> <span class="operator">=</span> <span class="string">"your32characterlongsecretkey"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="完整实现示例"><a href="#完整实现示例" class="headerlink" title="完整实现示例"></a>完整实现示例</h3><h4 id="1-签名与验证"><a href="#1-签名与验证" class="headerlink" title="1. 签名与验证"></a>1. <strong>签名与验证</strong></h4><h5 id="客户端签名请求"><a href="#客户端签名请求" class="headerlink" title="客户端签名请求"></a>客户端签名请求</h5><p>客户端在发送请求之前，使用共享密钥对特定的请求头字段（例如时间戳和nonce）进行签名，并将签名结果附加到请求头中。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.crypto.Mac;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientSignatureExample</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] sharedSecretBytes = Constants.SHARED_SECRET.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">"https://api.cmeng.com/list"</span>);</span><br><span class="line">        <span class="type">HttpURLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">        conn.setRequestMethod(<span class="string">"POST"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建唯一的时间戳和随机数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">timestamp</span> <span class="operator">=</span> Long.toString(System.currentTimeMillis());</span><br><span class="line">        <span class="type">String</span> <span class="variable">nonce</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对时间戳和随机数进行签名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dataToSign</span> <span class="operator">=</span> timestamp + nonce;</span><br><span class="line">        <span class="type">String</span> <span class="variable">signature</span> <span class="operator">=</span> signData(dataToSign, sharedSecretBytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置请求头</span></span><br><span class="line">        conn.setRequestProperty(<span class="string">"Timestamp"</span>, timestamp);</span><br><span class="line">        conn.setRequestProperty(<span class="string">"Nonce"</span>, nonce);</span><br><span class="line">        conn.setRequestProperty(<span class="string">"Authorization"</span>, <span class="string">"HMAC "</span> + signature);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">responseCode</span> <span class="operator">=</span> conn.getResponseCode();</span><br><span class="line">        System.out.println(<span class="string">"Response Code: "</span> + responseCode);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">signData</span><span class="params">(String data, <span class="type">byte</span>[] secretKey)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">Mac</span> <span class="variable">mac</span> <span class="operator">=</span> Mac.getInstance(<span class="string">"HmacSHA256"</span>);</span><br><span class="line">        mac.init(<span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(secretKey, <span class="string">"HmacSHA256"</span>));</span><br><span class="line">        <span class="type">byte</span>[] signedData = mac.doFinal(data.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        <span class="keyword">return</span> Base64.getEncoder().encodeToString(signedData);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="服务端验证签名"><a href="#服务端验证签名" class="headerlink" title="服务端验证签名"></a>服务端验证签名</h5><p>服务端接收到请求后，使用相同的共享密钥对签名进行验证，以确保请求来自合法客户端，并且未被篡改。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerSignatureVerification</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] sharedSecretBytes = Constants.SHARED_SECRET.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verifyRequest</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">String</span> <span class="variable">timestamp</span> <span class="operator">=</span> request.getHeader(<span class="string">"Timestamp"</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">nonce</span> <span class="operator">=</span> request.getHeader(<span class="string">"Nonce"</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">authorizationHeader</span> <span class="operator">=</span> request.getHeader(<span class="string">"Authorization"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timestamp == <span class="literal">null</span> || nonce == <span class="literal">null</span> || authorizationHeader == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">receivedSignature</span> <span class="operator">=</span> authorizationHeader.replace(<span class="string">"HMAC "</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">dataToVerify</span> <span class="operator">=</span> timestamp + nonce;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证签名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">calculatedSignature</span> <span class="operator">=</span> signData(dataToVerify, sharedSecretBytes);</span><br><span class="line">        <span class="keyword">return</span> MessageDigest.isEqual(</span><br><span class="line">            Base64.getDecoder().decode(receivedSignature),</span><br><span class="line">            Base64.getDecoder().decode(calculatedSignature)</span><br><span class="line">        );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">signData</span><span class="params">(String data, <span class="type">byte</span>[] secretKey)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">Mac</span> <span class="variable">mac</span> <span class="operator">=</span> Mac.getInstance(<span class="string">"HmacSHA256"</span>);</span><br><span class="line">        mac.init(<span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(secretKey, <span class="string">"HmacSHA256"</span>));</span><br><span class="line">        <span class="type">byte</span>[] signedData = mac.doFinal(data.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        <span class="keyword">return</span> Base64.getEncoder().encodeToString(signedData);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-防止重放攻击"><a href="#2-防止重放攻击" class="headerlink" title="2. 防止重放攻击"></a>2. <strong>防止重放攻击</strong></h4><p>为了进一步增强安全性，可以在服务端记录每个收到的时间戳和随机数组合，确保它们不会被重复使用。可以设置一个合理的过期时间窗口，超出这个时间段的请求将被视为无效。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReplayAttackPrevention</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">EXPIRATION_TIME_MS</span> <span class="operator">=</span> TimeUnit.MINUTES.toMillis(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Long&gt; seenNonces = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNonceValid</span><span class="params">(String nonce, String timestamp)</span> {</span><br><span class="line">        <span class="comment">// 检查时间戳是否在有效期内</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">messageTime</span> <span class="operator">=</span> Long.parseLong(timestamp);</span><br><span class="line">        <span class="keyword">if</span> (now - messageTime &gt; EXPIRATION_TIME_MS) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 nonce 是否已经被使用过</span></span><br><span class="line">        <span class="keyword">return</span> seenNonces.putIfAbsent(nonce, now) == <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在示例代码中，<code>HMAC</code> 是“基于哈希的消息认证码”（Hash-based Message Authentication Code）的缩写。它是一种用于验证消息完整性和身份验证的机制，结合了哈希函数和密钥来生成一个固定长度的认证码。HMAC 不仅可以确保消息未被篡改，还可以验证发送者的真实性。</p><h3 id="HMAC-的工作原理"><a href="#HMAC-的工作原理" class="headerlink" title="HMAC 的工作原理"></a>HMAC 的工作原理</h3><ol><li><strong>输入</strong>：需要一个密钥（Key）和消息（Message）。</li><li><strong>处理</strong>：使用特定的哈希算法（如SHA-256），根据密钥对消息进行两次哈希计算。</li><li><strong>输出</strong>：生成一个固定长度的字符串，即 HMAC 值或标签（Tag），通常以十六进制或Base64编码形式表示。</li></ol><h3 id="示例中的-HMAC"><a href="#示例中的-HMAC" class="headerlink" title="示例中的 HMAC"></a>示例中的 <code>HMAC</code></h3><p>在之前的Java示例中，我们使用了 <code>HMAC</code> 来签名请求头中的时间戳和随机数（nonce），以便服务端能够验证这些信息的真实性和完整性。具体来说：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对时间戳和随机数进行签名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">dataToSign</span> <span class="operator">=</span> timestamp + nonce;</span><br><span class="line"><span class="type">String</span> <span class="variable">signature</span> <span class="operator">=</span> signData(dataToSign, sharedSecretBytes);</span><br></pre></td></tr></tbody></table></figure><p>这里的 <code>signData</code> 方法实现了 HMAC 签名过程：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">signData</span><span class="params">(String data, <span class="type">byte</span>[] secretKey)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="type">Mac</span> <span class="variable">mac</span> <span class="operator">=</span> Mac.getInstance(<span class="string">"HmacSHA256"</span>);</span><br><span class="line">    mac.init(<span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(secretKey, <span class="string">"HmacSHA256"</span>));</span><br><span class="line">    <span class="type">byte</span>[] signedData = mac.doFinal(data.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">    <span class="keyword">return</span> Base64.getEncoder().encodeToString(signedData);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ul><li><strong><code>HmacSHA256</code></strong>：这是指定使用的哈希算法，表示我们将使用SHA-256作为基础哈希函数来计算 HMAC。</li><li><strong><code>Mac.getInstance("HmacSHA256")</code></strong>：创建一个 HMAC 实例，指定使用 SHA-256 作为哈希算法。</li><li><strong><code>mac.init(new SecretKeySpec(secretKey, "HmacSHA256"))</code></strong>：初始化 HMAC 实例，提供共享密钥（secretKey）。</li><li><strong><code>mac.doFinal(data.getBytes("UTF-8"))</code></strong>：对给定的数据执行最终的 HMAC 计算，生成签名。</li><li><strong><code>Base64.getEncoder().encodeToString(signedData)</code></strong>：将生成的二进制签名转换为Base64编码的字符串，便于在网络上传输。</li></ul><h3 id="为什么使用-HMAC？"><a href="#为什么使用-HMAC？" class="headerlink" title="为什么使用 HMAC？"></a>为什么使用 HMAC？</h3><ul><li><strong>安全性</strong>：HMAC 提供了比简单哈希更强的安全性，因为它不仅依赖于哈希算法，还依赖于一个秘密密钥，这使得攻击者即使知道了哈希算法也无法伪造签名。</li><li><strong>完整性</strong>：通过比较接收到的消息与其 HMAC 签名，接收方可以确认消息没有被篡改。</li><li><strong>身份验证</strong>：只有知道正确密钥的一方才能生成有效的 HMAC 签名，因此它可以用来验证发送者的身份。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在API接口调用中使用 HMAC 可以有效地保护数据的完整性和真实性，同时避免直接传输敏感信息。通过将 HMAC 签名附加到每个请求，服务端可以在不暴露任何敏感信息的情况下验证客户端的身份和请求的有效性。</p>]]></content>
      
      
      <categories>
          
          <category> HMAC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HMAC </tag>
            
            <tag> ASE </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3中icon的使用</title>
      <link href="/posts/6918a5b5.html"/>
      <url>/posts/6918a5b5.html</url>
      
        <content type="html"><![CDATA[<h1 id="vue3中icon的使用"><a href="#vue3中icon的使用" class="headerlink" title="vue3中icon的使用"></a>vue3中icon的使用</h1><p>本文以【vite】+【vue3】+【TypeScript】方式进行演示，如使用JS可自行转化。</p><h2 id="一、element-plus-icons-vue"><a href="#一、element-plus-icons-vue" class="headerlink" title="一、element-plus/icons-vue"></a>一、element-plus/icons-vue</h2><p>Element Plus 提供了一套常用的图标集合，可以直接进行使用</p><h3 id="1-1、安装"><a href="#1-1、安装" class="headerlink" title="1.1、安装"></a>1.1、安装</h3><p>使用包管理器<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 选择一个你喜欢的包管理器</span><br><span class="line"></span><br><span class="line"># NPM</span><br><span class="line">$ npm install @element-plus/icons-vue</span><br><span class="line"># Yarn</span><br><span class="line">$ yarn add @element-plus/icons-vue</span><br><span class="line"># pnpm</span><br><span class="line">$ pnpm install @element-plus/icons-vue</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="1-2、注册所有图标"><a href="#1-2、注册所有图标" class="headerlink" title="1.2、注册所有图标"></a>1.2、注册所有图标</h3><p>从 @element-plus/icons-vue 中导入所有图标并进行全局注册。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果您正在使用CDN引入，请删除下面一行。</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">ElementPlusIconsVue</span> <span class="keyword">from</span> <span class="string">'@element-plus/icons-vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, component] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(<span class="title class_">ElementPlusIconsVue</span>)) {</span><br><span class="line">  app.<span class="title function_">component</span>(key, component)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-3、使用"><a href="#1-3、使用" class="headerlink" title="1.3、使用"></a>1.3、使用</h3><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用 el-icon 为 SVG 图标提供属性 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-icon :size="size" :color="color"&gt;</span><br><span class="line">      &lt;Edit /&gt;</span><br><span class="line">    &lt;/el-icon&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 或者独立使用它，不从父级获取属性 --&gt;</span><br><span class="line">    &lt;Edit /&gt;</span><br><span class="line">    &lt;Edit style="width: 1em; height: 1em; margin-right: 8px" /&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- el-icon 为 raw SVG 图标提供额外的属性 --&gt;</span><br><span class="line">    &lt;el-icon color="#409EFC" class="no-inherit"&gt;</span><br><span class="line">        &lt;Share /&gt;</span><br><span class="line">    &lt;/el-icon&gt;</span><br><span class="line">    &lt;el-icon&gt;</span><br><span class="line">        &lt;Delete /&gt;</span><br><span class="line">    &lt;/el-icon&gt;</span><br><span class="line">    &lt;el-icon class="is-loading"&gt;</span><br><span class="line">        &lt;Loading /&gt;</span><br><span class="line">    &lt;/el-icon&gt;</span><br><span class="line">    &lt;el-button type="primary"&gt;</span><br><span class="line">        &lt;el-icon style="vertical-align: middle"&gt;</span><br><span class="line">            &lt;Search /&gt;</span><br><span class="line">        &lt;/el-icon&gt;</span><br><span class="line">        &lt;span style="vertical-align: middle"&gt; Search &lt;/span&gt;</span><br><span class="line">    &lt;/el-button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="动态使用"><a href="#动态使用" class="headerlink" title="动态使用"></a>动态使用</h4><p>icons-vue图标也可动态使用并渲染，比如菜单导航栏、动态编辑等。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 前提是route.meta.icon这个参数要配置好并且与官网提供的图标组件名称一致 --&gt;</span><br><span class="line">&lt;el-icon&gt;</span><br><span class="line">    &lt;component :is="route.meta.icon" &gt;</span><br><span class="line">&lt;/component&gt;&lt;/el-icon&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="二、svg-icon图标直接使用"><a href="#二、svg-icon图标直接使用" class="headerlink" title="二、svg-icon图标直接使用"></a>二、svg-icon图标直接使用</h2><h3 id="2-1、安装插件"><a href="#2-1、安装插件" class="headerlink" title="2.1、安装插件"></a>2.1、安装插件</h3><p><a href="!https://github.com/vbenjs/vite-plugin-svg-icons">vite-plugin-svg-icons</a>  用于生成 svg 雪碧图.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 版本要求</span><br><span class="line">    node version: &gt;=12.0.0</span><br><span class="line">    vite version: &gt;=2.0.0</span><br><span class="line"> --&gt;</span><br><span class="line">yarn add vite-plugin-svg-icons -D</span><br><span class="line"># or</span><br><span class="line">npm i vite-plugin-svg-icons -D</span><br><span class="line"># or</span><br><span class="line">pnpm install vite-plugin-svg-icons -D</span><br></pre></td></tr></tbody></table></figure><p>一般会同时需要以下两个插件：</p><ul><li><p>fast-glob：依赖于 fast-glob 包来处理 SVG 图标文件</p><ul><li>```npmrc<br>  安装<br>  npm install fast-glob  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* sass：依赖于 sass 包来处理 CSS 文件</span><br><span class="line">    * ```npmrc </span><br><span class="line">        安装</span><br><span class="line">        npm install sass</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h3 id="2-2、配置"><a href="#2-2、配置" class="headerlink" title="2.2、配置"></a>2.2、配置</h3><ul><li><p>vite.config.ts 中的配置插件</p>  <figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { createSvgIconsPlugin } <span class="keyword">from</span> <span class="string">'vite-plugin-svg-icons'</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; {</span><br><span class="line"><span class="keyword">return</span> {</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="title function_">createSvgIconsPlugin</span>({</span><br><span class="line">            <span class="comment">// 指定需要缓存的图标文件夹</span></span><br><span class="line">            <span class="attr">iconDirs</span>: [path.<span class="title function_">resolve</span>(process.<span class="title function_">cwd</span>(), <span class="string">'src/icons'</span>)],</span><br><span class="line">            <span class="comment">// 指定symbolId格式</span></span><br><span class="line">            <span class="attr">symbolId</span>: <span class="string">'icon-[dir]-[name]'</span>,</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 自定义插入位置</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@default</span>: body-last</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            inject?: <span class="string">'body-last'</span> | <span class="string">'body-first'</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * custom dom id</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@default</span>: __svg__icons__dom__</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="attr">customDomId</span>: <span class="string">'__svg__icons__dom__'</span>,</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 颜色修改生效需增加以下配置 【此配置需每次引用SvgIcon时都需要设置颜色，否则svg颜色将全部置灰】</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="attr">svgoOptions</span>: {</span><br><span class="line">                <span class="attr">full</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">plugins</span>: [</span><br><span class="line">                {</span><br><span class="line">                <span class="attr">name</span>: <span class="string">"removeAttrs"</span>,</span><br><span class="line">                <span class="attr">params</span>: {</span><br><span class="line">                    <span class="attr">attrs</span>: <span class="string">"fill"</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                ]</span><br><span class="line">            },</span><br><span class="line"></span><br><span class="line">        }),</span><br><span class="line">    ],</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>在 src/main.ts 内引入注册脚本</p>  <figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这行代码的作用是在你的项目中注册一个自定义的 SVG 图标库。</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'virtual:svg-icons-register'</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="2-3、使用，vue中"><a href="#2-3、使用，vue中" class="headerlink" title="2.3、使用，vue中"></a>2.3、使用，vue中</h3><ul><li>定义组件  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;svg aria-hidden="true"&gt;</span><br><span class="line">        &lt;use :xlink:href="symbolId" :fill="color" /&gt;</span><br><span class="line">    &lt;/svg&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang="ts" name="SvgIcon"&gt;</span><br><span class="line">import { defineComponent, computed } from 'vue'</span><br><span class="line"></span><br><span class="line">const props = defineProps({</span><br><span class="line">    prefix: {</span><br><span class="line">        type: String,</span><br><span class="line">        default: 'icon',</span><br><span class="line">    },</span><br><span class="line">    name: {</span><br><span class="line">        type: String,</span><br><span class="line">        required: true,</span><br><span class="line">    },</span><br><span class="line">    color: {</span><br><span class="line">        type: String,</span><br><span class="line">        default: '#333',</span><br><span class="line">    },</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">const symbolId = computed(() =&gt; `#${props.prefix}-${props.name}`);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>icons 目录结构</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># src/icons</span><br><span class="line"></span><br><span class="line">- icon1.<span class="property">svg</span></span><br><span class="line">- icon2.<span class="property">svg</span></span><br><span class="line">- icon3.<span class="property">svg</span></span><br><span class="line">- dir/icon1.<span class="property">svg</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>/src/App.vue</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;SvgIcon name="icon1"&gt;&lt;/SvgIcon&gt;</span><br><span class="line">    &lt;SvgIcon name="icon2"&gt;&lt;/SvgIcon&gt;</span><br><span class="line">    &lt;SvgIcon name="icon3"&gt;&lt;/SvgIcon&gt;</span><br><span class="line">    &lt;SvgIcon name="dir-icon1"&gt;&lt;/SvgIcon&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import { defineComponent, computed } from 'vue'</span><br><span class="line"></span><br><span class="line">import SvgIcon from './components/SvgIcon.vue'</span><br><span class="line">export default defineComponent({</span><br><span class="line">  name: 'App',</span><br><span class="line">  components: { SvgIcon },</span><br><span class="line">})</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> icon </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<h3 id="LLM程序员的学习路线"><a href="#LLM程序员的学习路线" class="headerlink" title="LLM程序员的学习路线"></a>LLM程序员的学习路线</h3><p>LLM（Legal Language Model）程序员指的是专门从事法律领域自然语言处理（NLP）和人工智能相关工作的程序员。下面是一个适用于LLM程序员的学习路线：</p><ol><li><p><strong>学习法律知识：</strong> 作为LLM程序员，首先需要建立扎实的法律基础知识。这包括但不限于法律体系、法律原则、法律术语和法律文书等方面的学习。可以通过参加法学课程、阅读法律书籍和文献等方式来学习法律知识。</p></li><li><p><strong>掌握自然语言处理（NLP）技术：</strong> NLP技术是LLM程序员必备的技能之一。学习NLP技术包括语言模型、文本分类、命名实体识别、信息抽取、机器翻译等领域。可以通过学习相关的教材、课程或者参加在线培训来掌握NLP技术。</p></li><li><p><strong>深入理解机器学习和人工智能：</strong> 除了NLP技术，还需要掌握机器学习和人工智能的相关知识。这包括机器学习算法、深度学习、神经网络等方面的学习。可以通过学习相关的教材、课程或者参加在线培训来深入理解机器学习和人工智能。</p></li><li><p><strong>熟悉法律数据和语料库：</strong> 作为LLM程序员，需要熟悉法律领域的数据和语料库。这包括案例法数据库、法律文书数据库、法律条款数据库等。可以通过获取公开的法律数据集或者与法律机构合作来获取相关数据。</p></li><li><p><strong>开发法律智能应用：</strong> 掌握了上述技能之后，可以开始开发法律智能应用，如法律文书智能分析系统、法律咨询机器人、法律知识图谱等。在开发过程中，需要将NLP技术和机器学习技术应用到实际的法律场景中，提供高效、准确的法律智能解决方案。</p></li><li><p><strong>持续学习和实践：</strong> 法律领域和技术领域都在不断发展变化，作为LLM程序员需要保持持续学习的态度，关注最新的技术和法律发展趋势，并不断实践和完善自己的技能。</p></li></ol><p>以上是一个基本的LLM程序员的学习路线，通过不断的学习和实践，可以成为在法律领域运用人工智能技术解决问题的专业人士。</p><p>自然语言处理（Natural Language Processing，NLP）是人工智能领域的一个重要分支，旨在使计算机能够理解、解释、生成和处理人类语言。NLP 结合了计算机科学、人工智能和语言学等多个学科的知识，致力于开发能够与人类语言进行有效交互的计算机系统。</p><h3 id="自然语言处理（NLP）介绍"><a href="#自然语言处理（NLP）介绍" class="headerlink" title="自然语言处理（NLP）介绍"></a>自然语言处理（NLP）介绍</h3><p>以下是 NLP 的一些基本概念和主要任务：</p><h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h3><ol><li><p><strong>自然语言：</strong> 指人类用于交流和表达思想的语言，如英语、汉语、法语等。</p></li><li><p><strong>文本：</strong> 由自然语言编写的书面或电子形式的语言材料，如文章、文档、网页等。</p></li><li><p><strong>语言处理：</strong> 指对自然语言文本进行分析、理解和处理的过程，可以通过计算机来实现。</p></li></ol><h3 id="主要任务："><a href="#主要任务：" class="headerlink" title="主要任务："></a>主要任务：</h3><ol><li><p><strong>分词（Tokenization）：</strong> 将文本分割成独立的单词或标记，作为处理的基本单位。</p></li><li><p><strong>词性标注（Part-of-Speech Tagging）：</strong> 给文本中的每个词汇标注其词性，如名词、动词、形容词等。</p></li><li><p><strong>句法分析（Syntax Parsing）：</strong> 分析句子的结构和语法关系，以了解句子中各个成分之间的关联。</p></li><li><p><strong>语义分析（Semantic Analysis）：</strong> 理解句子的意思和含义，包括词义消歧、语义角色标注等。</p></li><li><p><strong>命名实体识别（Named Entity Recognition，NER）：</strong> 识别文本中具有特定意义的实体，如人名、地名、组织机构名等。</p></li><li><p><strong>情感分析（Sentiment Analysis）：</strong> 分析文本中的情感倾向，判断文本的情感色彩，如积极、消极或中性等。</p></li><li><p><strong>机器翻译（Machine Translation）：</strong> 将一种语言的文本翻译成另一种语言的过程。</p></li><li><p><strong>问答系统（Question Answering）：</strong> 基于自然语言的输入，从知识库或者语料库中找到相应的答案。</p></li><li><p><strong>自然语言生成（Natural Language Generation）：</strong> 根据特定任务或需求，生成符合语法和语义规则的自然语言文本。</p></li><li><p><strong>文本分类（Text Classification）：</strong> 将文本划分到不同的类别或标签中，如垃圾邮件过滤、情感分类等。</p></li></ol><p>NLP 技术在许多领域都有广泛的应用，包括搜索引擎、智能助手、智能翻译、情感分析、自动摘要、信息抽取等。随着深度学习等技术的发展，NLP 在处理语言数据上取得了显著的进展，并在各种实际应用中发挥着重要作用。</p><h3 id="NLP的学习路线和相关学习资料"><a href="#NLP的学习路线和相关学习资料" class="headerlink" title="NLP的学习路线和相关学习资料"></a>NLP的学习路线和相关学习资料</h3><p>学习自然语言处理（NLP）需要掌握语言学、机器学习、深度学习等多个领域的知识。以下是一个适用于初学者的 NLP 学习路线，以及一些相关的学习资料：</p><h3 id="初级阶段："><a href="#初级阶段：" class="headerlink" title="初级阶段："></a>初级阶段：</h3><ol><li><p><strong>了解基本概念：</strong></p><ul><li>阅读《自然语言处理综述》等入门级的书籍，了解 NLP 的基本概念、历史和主要任务。</li></ul></li><li><p><strong>学习编程基础：</strong></p><ul><li>学习一种编程语言，如 Python，作为实践 NLP 技术的基础。可以通过《Python编程快速上手》等教材学习。</li></ul></li><li><p><strong>掌握基础算法：</strong></p><ul><li>学习数据结构和算法，理解常用的数据结构和算法，如列表、字典、排序算法等。</li></ul></li><li><p><strong>学习 NLP 基础知识：</strong></p><ul><li>阅读《自然语言处理与计算语言学》等教材，了解 NLP 的基本任务、方法和技术，如分词、词性标注、句法分析等。</li></ul></li></ol><h3 id="中级阶段："><a href="#中级阶段：" class="headerlink" title="中级阶段："></a>中级阶段：</h3><ol><li><p><strong>深入学习机器学习：</strong></p><ul><li>学习机器学习算法和技术，掌握常用的机器学习模型和算法，如朴素贝叶斯、支持向量机、决策树等。</li></ul></li><li><p><strong>掌握 NLP 工具和库：</strong></p><ul><li>学习使用常用的 NLP 工具和库，如 NLTK（Natural Language Toolkit）、spaCy、gensim 等，掌握它们的基本用法和功能。</li></ul></li><li><p><strong>学习深度学习：</strong></p><ul><li>学习深度学习技术，了解神经网络、卷积神经网络（CNN）、循环神经网络（RNN）等深度学习模型，并了解它们在 NLP 中的应用。</li></ul></li><li><p><strong>实践项目开发：</strong></p><ul><li>参与 NLP 相关的项目开发，通过实践来巩固所学知识，如情感分析、文本分类、命名实体识别等。</li></ul></li></ol><h3 id="高级阶段："><a href="#高级阶段：" class="headerlink" title="高级阶段："></a>高级阶段：</h3><ol><li><p><strong>学习深度 NLP 技术：</strong></p><ul><li>深入学习深度 NLP 技术，如注意力机制（Attention Mechanism）、Transformer 模型、BERT（Bidirectional Encoder Representations from Transformers）等。</li></ul></li><li><p><strong>掌握语言模型和预训练模型：</strong></p><ul><li>学习语言模型和预训练模型，了解它们在 NLP 中的作用和应用，如 GPT（Generative Pre-trained Transformer）、BERT 等。</li></ul></li><li><p><strong>关注最新研究和进展：</strong></p><ul><li>关注 NLP 领域的最新研究成果和进展，阅读相关的论文、博客和研究报告，了解 NLP 领域的前沿技术和趋势。</li></ul></li></ol><h3 id="学习资料推荐："><a href="#学习资料推荐：" class="headerlink" title="学习资料推荐："></a>学习资料推荐：</h3><ol><li>《自然语言处理综述》（Introduction to Natural Language Processing）</li><li>《Python编程快速上手》（Python Crash Course）</li><li>NLTK（Natural Language Toolkit）官方文档：<a href="https://www.nltk.org/">https://www.nltk.org/</a></li><li>spaCy 官方文档：<a href="https://spacy.io/">https://spacy.io/</a></li><li>《深度学习》（Deep Learning）- Ian Goodfellow 等</li><li>《自然语言处理与计算语言学》（Natural Language Processing and Computational Linguistics）- Anne Garcia-Fernandez 等</li><li>《BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding》- Jacob Devlin 等</li></ol><p>以上是一个适用于初学者的 NLP 学习路线和相关学习资料。通过系统的学习和实践，你可以逐步掌握 NLP 技术并在实际项目中应用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>node相关命令</title>
      <link href="/posts/7908e8cd.html"/>
      <url>/posts/7908e8cd.html</url>
      
        <content type="html"><![CDATA[<h3 id="npm命令"><a href="#npm命令" class="headerlink" title="npm命令"></a>npm命令</h3><div class="table-container"><table><thead><tr><th style="text-align:left">命令行</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">sudo npm cache clean —force</td><td style="text-align:left">强制清空npm缓存</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>netty第二弹——Reactor模式</title>
      <link href="/posts/ad72082d.html"/>
      <url>/posts/ad72082d.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、Netty和Reactor"><a href="#一、Netty和Reactor" class="headerlink" title="一、Netty和Reactor"></a>一、Netty和Reactor</h2><p><strong>Netty</strong> 的线程模型是基于 <strong>NIO的Selector</strong>构建的，使用了异步驱动的<strong>Reactor</strong> 模式来构建的线程模型，可以很好的支持成百上千的 <strong>SocketChannel</strong> 连接。</p><p>所以 <strong>Netty</strong> 是一个典型的多线程的 <strong>Reactor</strong> 模式的使用，理解了这部分，在宏观上理解 <strong>Netty的NIO及多线程</strong> 部分就不会有什么困难了。</p><h2 id="二、Reactor模式（Reactor-Pattern）"><a href="#二、Reactor模式（Reactor-Pattern）" class="headerlink" title="二、Reactor模式（Reactor Pattern）"></a>二、Reactor模式（Reactor Pattern）</h2><blockquote><p><a href="https://zh.wikipedia.org/zh-hans/%E5%8F%8D%E5%BA%94%E5%99%A8%E6%A8%A1%E5%BC%8F">维基百科</a>：<br>反应器模式（Reactor_pattern）是一种为处理服务请求并发 提交到一个或者多个服务处理程序的事件设计模式。当请求抵达后，服务处理程序使用解多路分配策略，然后同步地派发这些请求至相关的请求处理程序。</p></blockquote><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/Reactor.jpg" alt="Reactor"></p><p>从结构图可以看出，有个独立的 <strong>Service Handler</strong> 线程进行监听就绪事件，当一个或多个事件准备好后，由 <strong>Service Handler</strong> 分发给具体的请求处理线程。听起来是不是很熟悉，再回想下 <strong>IO多路复用</strong> 模型，就明白 熟悉感在哪了。</p><p>Reactor模式是事件驱动架构的一种实现技术，这种模式将程序代码模块化与可复用反应器解耦，从而实现并发请求与事件处理分离。<br>其实也可理解为 <strong>IO多路复用</strong> 的面向对象化的包装，相较于用 I/O多路复用接口写网络程序这种面向过程的方式写代码，面向对象的方式效率肯定高很多。同时让使用者不用考虑底层网络 API 的细节，只需要关注应用代码的编写。</p><p><font size="5">Reactor模式</font> 也可以称为：</p><ul><li>反应器模式。</li><li>分发者模式（Dispatcher）。</li><li>通知者模式（notifier）。</li></ul><p>其实根据具体模型，感觉还是称为 <font color="#48D1CC">分发者模式（Dispatcher）</font> 更为贴切，即 <strong>I/O 多路复用监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程。</strong></p><p><strong>Reactor 模式</strong> 主要由 <strong>Reactor</strong> 和 <strong>Handler（处理资源池）</strong> 这两个核心部分组成，它俩负责的事情如下：</p><ul><li>Reactor：负责监听和分发事件，事件类型包含连接事件、读写事件；</li><li>Handler：处理程序执行对应I/O事件实际需要业务逻辑，如 read -&gt; 业务逻辑 -&gt; send。</li></ul><h2 id="三、Reactor模式类型"><a href="#三、Reactor模式类型" class="headerlink" title="三、Reactor模式类型"></a>三、Reactor模式类型</h2><p>根据两个核心组成可分为四种类型，分别是：</p><ul><li><p>单 Reactor —— 单线程/进程cd -</p></li><li><p>单 Reactor —— 多线程/进程</p></li><li>多 Reactor —— 单线程/进程</li><li>多 Reactor —— 多线程/进程</li></ul><p>其中第三种即 <strong>多 Reactor —— 单线程/进程</strong> 类型，相比 <strong>单 Reactor —— 多线程/进程</strong> 类型不仅实现复杂，也没性能优势，所以实际中并没有使用。<br>至于具体使线程还是进程则取决于具体的开发语言和平台，比如Java主要以线程为主。</p><h3 id="3-1、单-Reactor-——-单线程-进程"><a href="#3-1、单-Reactor-——-单线程-进程" class="headerlink" title="3.1、单 Reactor —— 单线程/进程"></a>3.1、单 Reactor —— 单线程/进程</h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty第一弹——JAVA的IO</title>
      <link href="/posts/ad72082d.html"/>
      <url>/posts/ad72082d.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>netty系列的IO逻辑基于 <strong>I/O模型</strong> 架构基础进行讲解，不会再次深入讲解具体I/O模型的原理和设计理念，具体可参考一下文章：</p><p><a href="https://cmeng-cm.github.io/posts/aeafbee0.html">I/O模型</a><br><a href="https://cmeng-cm.github.io/posts/a46eba31.html">用户空间、用户态、内核空间、内核态</a></p><p>下面正式进入：</p><h2 id="一、netty概述"><a href="#一、netty概述" class="headerlink" title="一、netty概述"></a>一、netty概述</h2><p><strong>Netty</strong> 是一个 <strong>非阻塞I/O客户端-服务器框架</strong> ，主要用于开发 <strong>Java网络应用程序</strong>，如协议服务器和客户端。异步事件驱动的网络应用程序框架和工具用于简化网络编程，例如TCP和UDP套接字服务器。Netty包括了反应器编程模式的实现。Netty最初由JBoss开发，现在由Netty项目社区开发和维护。</p><blockquote><p><a href="https://netty.io/">官网</a></p></blockquote><p><strong>Netty</strong> 本质上是一个 <strong>NIO</strong> 客户端服务器框架。它极大地简化和流线化了网络编程，例如 <strong>TCP和UDP</strong> 套接字服务器。</p><p>所以学习 <strong>Netty</strong> 要先了解下 <strong>JAVA</strong> 本身的 <strong>IO模型理念</strong>。JAVA的IO模型有三种分别为 <strong>BIO、NIO和AIO</strong> 下面逐个了解下。</p><h2 id="二、JAVA的IO模型——BIO"><a href="#二、JAVA的IO模型——BIO" class="headerlink" title="二、JAVA的IO模型——BIO"></a>二、JAVA的IO模型——BIO</h2><p><strong>JAVA BIO（Java Blocking I/O）</strong>：<font color="#0000FF">同步并阻塞</font> 即Java 网络编程的传统阻塞型，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不作任何事情会造成不必要的线程开销。</p><ul><li>客户端：发送消息后，等待服务端返回，再未收到返回前阻塞等待。</li><li>服务端：等待接收客户端消息，未收到消息阻塞等待。</li></ul><p>基于以上的 <strong>BIO</strong> 设计逻辑，分为两种BIO模型，分别是服务端 <strong>单线程</strong> 处理逻辑和  <strong>多线程</strong> 处理逻辑</p><h3 id="2-1、单线程-BIO"><a href="#2-1、单线程-BIO" class="headerlink" title="2.1、单线程 BIO"></a>2.1、单线程 BIO</h3><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/JAVA_BIO_MODEL.jpg" alt="JAVA_BIO_MODEL"></p><p><font size="5">单线程BIO：</font></p><ul><li>同一时间，服务端只能接收处理一个客户端的请求，即使多个客户端同时发送，也只能一个一个的串行处理。</li><li>由于服务端是串行处理，在高并发情况是不可取的。</li></ul><p>服务端代码：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">    log.info(<span class="string">"==== 服务端启动 ===="</span>);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) {</span><br><span class="line">            <span class="comment">//阻塞，直至有新的连接建立</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2048</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//阻塞，等待数据到达</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> inputStream.read(bytes);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,length);</span><br><span class="line">            log.info(String.format(<span class="string">"==== 收到信息：%s"</span>,msg));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//下面开始发送信息</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            outputStream.write(<span class="string">"向服务端发起请求：hello client"</span>.getBytes());</span><br><span class="line">            outputStream.flush();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//关闭</span></span><br><span class="line">            outputStream.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span>(Exception e) {</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span>(serverSocket != <span class="literal">null</span>) {</span><br><span class="line">            serverSocket.close();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>客户端代码，模拟50个客户端发送请求:<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++){</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Client.client();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                }</span><br><span class="line">            }).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">"127.0.0.1"</span>,<span class="number">9999</span>);</span><br><span class="line">    log.info(<span class="string">"==== 客户端启动 ===="</span>);</span><br><span class="line">    OutputStream outputStream= <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//发送请求</span></span><br><span class="line">        outputStream = socket.getOutputStream();</span><br><span class="line">        outputStream.write(String.format(<span class="string">"客户端线程名称：%s；hello server"</span>,Thread.currentThread().getName()).getBytes());</span><br><span class="line">        outputStream.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待响应</span></span><br><span class="line">        inputStream = socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2048</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//阻塞等待数据到达</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> inputStream.read(bytes);</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,length);</span><br><span class="line">        log.info(String.format(<span class="string">"==== 当前线程名称：%s ==== 服务器响应：%s"</span>,Thread.currentThread().getName(),msg));</span><br><span class="line">    }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">        log.error(e.getMessage(),e);</span><br><span class="line">    }<span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span>(outputStream!=<span class="literal">null</span>){</span><br><span class="line">            outputStream.close();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(inputStream != <span class="literal">null</span>) {</span><br><span class="line">            inputStream.close();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>上述单线程BIO的demo中，两个地方存在阻塞阶段，分别是：</p><ul><li>Socket socket = serverSocket.accept()：等待新的客户端建立连接。</li><li>inputStream.read(bytes)：读取客户端消息。需阻塞等待数据达到并准备好。</li></ul><h3 id="2-1、多线程-BIO"><a href="#2-1、多线程-BIO" class="headerlink" title="2.1、多线程 BIO"></a>2.1、多线程 BIO</h3><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/JAVA_BIO_MODEL_MULTI.jpg" alt="JAVA_BIO_MODEL_MULTI"></p><p><font size="5">多线程模式的BIO</font></p><ul><li>依旧由主线程一个一个的接收客户端连接请求，但后续的业务处理则交给独立线程去处理。</li><li>当并发数量起来时，则需要创建足够多的线程去处理业务逻辑。不过需要考虑线程资源是有限的。</li></ul><p>服务端多线程模式优化代码：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">    log.info(<span class="string">"==== 服务端启动 ===="</span>);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) {</span><br><span class="line">            <span class="comment">//阻塞，直至有新的连接建立</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="type">SocketServerThread</span> <span class="variable">socketServerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SocketServerThread</span>(socket);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(socketServerThread).start();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span>(Exception e) {</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span>(serverSocket != <span class="literal">null</span>) {</span><br><span class="line">            serverSocket.close();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务处理线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServerThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>{</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SocketServerThread</span> <span class="params">(Socket socket)</span> {</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2048</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//阻塞，等待数据到达</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> inputStream.read(bytes);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,length);</span><br><span class="line">            log.info(String.format(<span class="string">"==== 当前线程名称：%s；收到信息：%s"</span>,Thread.currentThread().getName(),msg));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//下面开始发送信息</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            outputStream.write(<span class="string">"向服务端发起请求：hello client"</span>.getBytes());</span><br><span class="line">            outputStream.flush();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//关闭</span></span><br><span class="line">            outputStream.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">            log.error(e.getMessage(), e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>多线程BIO和单线程BIO的区别主要在于接收到请求后的数据处理过程。但 <strong>accept()</strong> 和 <strong>read(bytes)</strong> 两处依旧是阻塞运行的状态，这两处才是 <font color="#0000FF">同步阻塞</font>  模型的关键处。多线程的BIO并没有从根源上解决这个问题，同时又容易造成资源的失控。</p><p>所以想要效率和资源的进一步优化，则要考虑如何才能不阻塞？基于此JAVA引入 <strong>NIO</strong></p><h2 id="三、JAVA的IO模型——NIO"><a href="#三、JAVA的IO模型——NIO" class="headerlink" title="三、JAVA的IO模型——NIO"></a>三、JAVA的IO模型——NIO</h2><p><font color="#0000FF">NIO（Java non-blocking IO）模型，即非阻塞模型。</font> 这个模型其实就是基于 <strong>BIO</strong> 中的两处阻塞处进行修改，即：</p><ul><li>accept()：无论是否有新客户端连接，都立即返回。如果没有新客户端，则不断去获取，直至有新的客户端发来请求。</li><li>read(bytes)：无论是否接收到信息，都立即返回。如果没有数据达到，则不断接收，直到有数据到达服务端。</li></ul><p>但如上述则会导致程序不断调用IO，多线程模式，单单创建线程就是一项不小的开销了，再加上线程之间要来回切换，资源消耗根本扛不住，所以最好的方式就是有一个线程负责去不断轮询新链接、消息达到等，等有响应时则通知对应线程进行操作，这样就是避免了所有线程都是轮询，这就是 <font color="#0000FF">IO多路复用模式</font>。</p><p><strong>JAVA NIO</strong> 也实现了 <strong>IO多路复用</strong> 这种模型。<br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/JAVA_NIO_MODEL.jpg" alt="JAVA_NIO_MODEL"></p><p><font size="5">JAVA-NIO</font>:</p><ul><li>主要由 Channel(通道)、Buffer(缓冲区)、Selector(选择器)三部分组成。</li><li><strong>Channel(通道)</strong>：客户端连接的抽象，每个客户端连接都对应一个 channel，负责数据的读写操作。并且每个 channel 都要注册在 Selector 上</li><li><strong>Buffer(缓冲区)</strong>：在NIO 库中，所有数据都是用缓冲区处理的。任何时候访问 NIO 中的数据，都是将它放到缓冲区中。</li><li><strong>Selector(选择器)</strong>：负责轮询注册在其上的 channel，这样的优点在于只需要一个线程就可以处理大量的客户端连接，当有客户端事件到达时，再将其分发出去交由其它线程处理；通过 selector 来实现 IO多路复用 原理。</li></ul><p>服务端代码：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">//轮询周期</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">POLLING_PERIOD</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="type">SocketServer</span> <span class="variable">socketServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SocketServer</span>();</span><br><span class="line">        socketServer.startServer();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="comment">//打开选择器</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取客户端连接抽象chennel、指定监听端口、指定阻塞模式为非阻塞</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//注册，并监听客户端连接事件</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>){</span><br><span class="line">            <span class="comment">//每分钟轮询一次，存在就绪事件则进行逻辑处理</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> == selector.select(POLLING_PERIOD)){</span><br><span class="line">                log.info(<span class="string">"======== 服务端——尚未有就绪事件 ========"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取就绪时间列表</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()){</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> iterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//根据注册时间状态，进行不同处理</span></span><br><span class="line">                <span class="keyword">if</span>(selectionKey.isAcceptable()){</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//新链接建立</span></span><br><span class="line">                    accept(selectionKey,selector);</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()){</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//数据读取</span></span><br><span class="line">                    read(selectionKey);</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span>(selectionKey.isValid() &amp;&amp; selectionKey.isWritable()){</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//数据写入</span></span><br><span class="line">                    write(selectionKey);</span><br><span class="line">                }</span><br><span class="line">                iterator.remove();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(SelectionKey selectionKey, Selector selector)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        log.info(<span class="string">"===========服务端读取数据==========="</span>);</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) selectionKey.channel();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> socketChannel.read(buffer);</span><br><span class="line">        log.info(<span class="string">"========== 服务端读取数据为："</span>+<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(),<span class="number">0</span>,read));</span><br><span class="line"></span><br><span class="line">        selectionKey.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        log.info(<span class="string">"===========服务端写入数据==========="</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">"hello client"</span>;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(message.getBytes());</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) selectionKey.channel();</span><br><span class="line">        <span class="keyword">if</span>(socketChannel.isOpen()){</span><br><span class="line">            socketChannel.write(buffer);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//监听OP_WRITE不可一直监听，因为连接打开，缓冲区未满或者客户后端未调用shutdownOutPut等，一直都处于可写状态。</span></span><br><span class="line">        selectionKey.interestOps(selectionKey.interestOps() &amp; ~SelectionKey.OP_WRITE);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p></p><p>客户端代码：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketClient</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">//轮询周期</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">POLLING_PERIOD</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SocketClient</span>().clientStart();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clientStart</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="comment">//创建客户端</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">"127.0.0.1"</span>,<span class="number">9999</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定selector</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>){</span><br><span class="line">            <span class="comment">//每分钟轮询一次，存在就绪事件则进行逻辑处理</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> == selector.select(POLLING_PERIOD)){</span><br><span class="line">                log.info(<span class="string">"======== 客户端——尚未有就绪事件 ========"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()){</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> iterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(selectionKey.isConnectable()){</span><br><span class="line">                    <span class="comment">//连接事件</span></span><br><span class="line">                    connect(selectionKey,selector);</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()){</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//数据读取</span></span><br><span class="line">                    read(selectionKey);</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span>(selectionKey.isValid() &amp;&amp; selectionKey.isWritable()){</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//数据写入</span></span><br><span class="line">                    write(selectionKey,selector);</span><br><span class="line">                }</span><br><span class="line">                iterator.remove();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(SelectionKey selectionKey,Selector selector)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="comment">// 由于是客户端Channel，因而可以直接强转为SocketChannel对象</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) selectionKey.channel();</span><br><span class="line">        channel.finishConnect();</span><br><span class="line">        <span class="comment">// 连接建立完成后就监听该Channel的WRITE事件，以供客户端写入数据发送到服务器</span></span><br><span class="line">        channel.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(SelectionKey key, Selector selector)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        log.info(<span class="string">"===========客户端写入数据==========="</span>);</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> Thread.currentThread().getId()+<span class="string">"hello client"</span>;</span><br><span class="line">        channel.write(ByteBuffer.wrap(message.getBytes()));</span><br><span class="line">        <span class="comment">// 数据写入完成后，客户端Channel监听OP_READ事件，以等待服务器发送数据过来</span></span><br><span class="line">        channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        log.info(<span class="string">"===========客户端读取==========="</span>);</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">        <span class="keyword">if</span> (read == -<span class="number">1</span>) {</span><br><span class="line">            channel.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        log.info(<span class="string">"========== 客户端读取数据为："</span>+<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(),<span class="number">0</span>,read));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>上述是简单的 <strong>NIO</strong> 应用的示例，实际项目中应用时最好使用 <strong>reactor模式</strong> 进行封装处理。<br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/Reactor_MODEL.jpg" alt="Reactor_MODEL"><p></p><blockquote><p>图片来源于大神 <strong>Doug Lea</strong> 的 <a href="https://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">Scalable IO in Java</a> 文章。</p></blockquote><h2 id="四、JAVA的IO模型——AIO"><a href="#四、JAVA的IO模型——AIO" class="headerlink" title="四、JAVA的IO模型——AIO"></a>四、JAVA的IO模型——AIO</h2><p><font color="#0000FF">AIO（Java Asynchronous I/O）</font>： 叫做异步非阻塞的 I/O，引入了异步通道的概念，采用了 <strong>Proactor</strong> 模式，有效的请求才会启动线程，特点就是先由操作系统完成后才通知服务端程序启动线程去处理，一般用于连接数较多且连接时长较长的应用。</p><p>区别于 <strong>NIO</strong> 的轮询操作不同，<strong>AIO</strong> 基于事件回调来完成IO操作。即当客户端发送消息之后，操作系统接收消息并将消息准备好后才通知服务端，服务端直接回调已注册好的回调方式直接执行操作。</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/异步IO.jpg" alt="异步IO"></p><p>服务端代码：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">waitObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException{</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="type">AsynchronousServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line">    serverSocketChannel.accept(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Object&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel asc, Object attachment)</span> {</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">            byteBuffer.put(<span class="string">"hello client"</span>.getBytes());</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            asc.read(byteBuffer, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, Object&gt;() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, Object attachment)</span> {</span><br><span class="line"></span><br><span class="line">                    byteBuffer.flip();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array(),<span class="number">0</span>,result);</span><br><span class="line">                    System.out.println(<span class="string">"=========== 服务端读取："</span>+rs);</span><br><span class="line">                }</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Object attachment)</span> {}</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">            asc.write(byteBuffer, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, Object&gt;() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, Object attachment)</span> {</span><br><span class="line">                    byteBuffer.clear();</span><br><span class="line">                }</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Object attachment)</span> {</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Object attachment)</span> {}</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) {}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>客户端代码：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException{</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="type">AsynchronousSocketChannel</span> <span class="variable">asynchronousSocketChannel</span> <span class="operator">=</span> AsynchronousSocketChannel.open();</span><br><span class="line">    asynchronousSocketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">"127.0.0.1"</span>, <span class="number">9999</span>), <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Void, Object&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Void result, Object attachment)</span> {</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line"></span><br><span class="line">            asynchronousSocketChannel.read(byteBuffer, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, Object&gt;() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, Object attachment)</span> {</span><br><span class="line">                    byteBuffer.flip();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array(),<span class="number">0</span>,result);</span><br><span class="line">                    System.out.println(<span class="string">"======== 客户端读取："</span>+rs);</span><br><span class="line"></span><br><span class="line">                    byteBuffer.clear();</span><br><span class="line">                    byteBuffer.put(<span class="string">"hello server"</span>.getBytes());</span><br><span class="line">                    byteBuffer.flip();</span><br><span class="line">                    asynchronousSocketChannel.write(byteBuffer);</span><br><span class="line">                }</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Object attachment)</span> {}</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Object attachment)</span> {}</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) {}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>Java的AIO</strong> 是基于NIO的基础上发展出来的异步IO，相关实现类也都是在NIO<br>的包下面，主要有以下几种：</p><ul><li>AsynchronousServerSocketChannel：服务端Socket通道类，负责服务端Socket的创建和监听；<ul><li>使用主要经历经过三个步骤：创建/打开通道、绑定地址和端口和监听客户端连接请求。从上面的demo也可以看出来。</li></ul></li><li>AsynchronousSocketChannel：客户端Socket通道类，负责客户端消息读写；<ul><li>需要先通过 <strong>open()</strong> 创建和打开一个AsynchronousSocketChannel实例，再调用其 <strong>connect()</strong> 方法连接到服务端，接着才可以与服务端交互。</li></ul></li><li>CompletionHandler<a,v>：消息处理回调接口，是一个负责消费异步IO操作结果的消息处理器；<br>*ByteBuffer：负责承载通信过程中需要读、写的消息。</a,v></li></ul><p>JAVA NIO和JAVA AIO框架，除了因为操作系统的实现不一样而去掉了Selector外，其他的重要概念都是存在的，例如上文中提到的Channel的概念，还有演示代码中使用的Buffer缓存方式。实际上JAVA NIO和JAVA AIO框架您可以看成是一套完整的“高并发IO处理”的实现。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>既然Java本身提供了各种IO模型的实现，那么为什么还要使用Netty呢？首先说下为什么不用原生Java IO：</p><ul><li>NIO、AIO的类库和API繁杂，使用麻烦。</li><li>需要具备其他的额外技能做铺垫，例如熟悉Java多线程编程。这是因为NIO编程涉及到Reactor模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序。</li><li>可靠性能力补齐，工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等问题，NIO编程的特点是功能开发相对容易，但是可靠性能力补齐的工作量和难度都非常大。</li></ul><p>再说下为什么选择Netty：</p><ul><li>API使用简单，开发门槛低；</li><li>功能强大，预置了多种编解码功能，支持多种主流协议；定制能力强，可以通过ChannelHandler对通信框架进行灵活地扩展；</li><li>提供可靠的、易维护的、高性能的 <strong>NIO/AIO</strong> 服务器应用。</li><li>经历了大规模的商业应用考验，质量得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它已经完全能够满足不同行业的商业应用了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO模型</title>
      <link href="/posts/aeafbee0.html"/>
      <url>/posts/aeafbee0.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、I-O概述"><a href="#一、I-O概述" class="headerlink" title="一、I/O概述"></a>一、I/O概述</h2><p><a href="https://zh.wikipedia.org/zh-cn/I/O">I/O（英语：Input/Output）</a>，即输入／输出，通常指数据在存储器（内部和外部）或其他周边设备之间的输入和输出。IO有 <strong>内存IO、网络IO和磁盘IO</strong> 三种，通常我们说的IO指的是后两者。</p><p>从系统角度来看，编辑器编辑文档、通讯软件消息的发送接收就分别属于网络IO和磁盘IO。为了方便理解IO模型，我们以通讯软件也就是网络IO来分析，软件程序是运行在 <strong>用户空间</strong> 的，并不存在实质的IO过程，真正的IO操作属于特权指令是运行在 <strong>系统内核</strong> 的（<a href="https://cmeng-cm.github.io/2023/02/17/theoretical-knowledge/virtual-memory/">用户空间和内核空间</a>）。所以软件程序的IO操作需要分为两步即：</p><ul><li><strong>IO调用</strong>：用户空间内软件程序像内核发起IO操作的调用</li><li><strong>IO执行</strong>：内核空间系统内核实际完成IO操作</li></ul><p>IO调用则由应用程序发起，发起后则等待系统内核完成实际IO操作。IO操作在内核中也分为两步，以网络IO来说，分别是：</p><ul><li>等待数据达到网卡后将数据拷贝至系统内核准备好。（即：<strong>等待数据准备好</strong>）</li><li>将内核读书的数据拷贝到用户空间，由程序进行相关操作。（即：<strong>从内核向进程拷贝数据</strong>）</li></ul><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/网络IO传输流程.jpg" alt="网络IO传输流程"></p><p>根据图解，可以清晰的感受到 <strong>IO调用</strong> 和 <strong>IO执行</strong> 的两阶段，以及 <strong>IO执行</strong> 也就是接收数据过程的 <strong>等待数据准备好</strong> 和 <strong>从内核向进程拷贝数据</strong> 两阶段。<br>至于我们说的 <strong>阻塞和非阻塞，异步和同步</strong> 都是指的 <strong>IO执行阶段</strong> 的状态和处理机制。</p><h2 id="二、阻塞、非阻塞"><a href="#二、阻塞、非阻塞" class="headerlink" title="二、阻塞、非阻塞"></a>二、阻塞、非阻塞</h2><p>我们以【数据接收】过程来进一步理解下阻塞和非阻塞的概念。</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/网络IO数据接收.jpg" alt="网络IO数据接收"></p><h3 id="2-1、阻塞式I-O"><a href="#2-1、阻塞式I-O" class="headerlink" title="2.1、阻塞式I/O"></a>2.1、阻塞式I/O</h3><p>根据IO调用和IO执行过程来看，如果程序发起IO调用，但此时数据还未准备好（即数据未到达网卡并读取到内核缓冲区）。那么此时程序就一直处于等待数据准备好的状态，知道数据准备好后内核才能将数据拷贝至用户缓冲区。这个等待的过程就是阻塞。</p><p><strong>流程：</strong></p><ol><li>程序发起IO调用。</li><li>系统内核进行IO操作。<ul><li>数据未准备好则等待，直至数据准备好。（<font color="red" size="5">阻塞主要是这一步</font>）</li><li>系统内核拷贝数据至用户缓冲区。</li></ul></li></ol><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/阻塞式IO模型.jpg" alt="阻塞式IO模型"></p><h3 id="2-2、非阻塞式I-O"><a href="#2-2、非阻塞式I-O" class="headerlink" title="2.2、非阻塞式I/O"></a>2.2、非阻塞式I/O</h3><p>理解了阻塞式IO再进一步理解非阻塞就很容易了。既然没有数据那系统内核直接返回没有数据，即返回一个 <strong>EWOULDBLOCK</strong> 错误告知程序就可以了。这样就不用一直阻塞着等待数据到达准备好了。<br>不过这样确实不阻塞了，但程序还是需要获取到数据的，那么就只能轮询了。在未接收到数据时需要持续轮询系统内核是否准备好数据，直到准备好数据进行拷贝为止。</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/非阻塞式IO模型.jpg" alt="非阻塞式IO模型"></p><p><strong>流程：</strong></p><ol><li>程序发起IO调用。</li><li>系统内核进行IO操作。<ul><li>i：判断数据是否准备好，准备好进行下一步，未准备好将错误 <strong>EWOULDBLOCK</strong> 响应给用户控件的程序。</li><li>ii：系统内核拷贝数据至用户缓冲区。</li></ul></li></ol><h2 id="三、I-O多路复用技术（multiplexing）"><a href="#三、I-O多路复用技术（multiplexing）" class="headerlink" title="三、I/O多路复用技术（multiplexing）"></a>三、I/O多路复用技术（multiplexing）</h2><p>针对阻塞模型进一步思考，每个系统的进程都是很多的，如果每个进程都持续轮询到数据准备，先不说服务器能不能扛得住这么多线程，就算扛得住那么很明显这种方式是不是太浪费资源了。</p><p>那么基于这种情况，是不是考虑可以有一个进程专门用来做轮询操作，等数据到达且准备好之后再通知各个进程读取数据呢？这种方式是有的，那就是 <strong>I/O 多路复用技术</strong></p><p><strong>I/O 多路复用技术</strong>：Linux下的 <strong>select、poll和epoll</strong> 就是干这个的。将用户socket对应的fd（<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">文件描述</a>）注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作同时提升了CPU效率。此时的socket应该采用非阻塞模式。</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/IO多路复用.jpg" alt="IO多路复用"></p><p><strong>select()：</strong> 用 <strong>long</strong> 组成的数据结构 <strong>fd_set</strong> 来存储文件句柄，每一个数组元素都能与一打开的文件句柄建立联系。当调用select()时，由内核根据IO状态修改 <strong>fd_set</strong> 的内容，由此来通知执行了 <strong>select()</strong> 的进程哪一Socket或文件可读。不过其监视的文件句柄通常最大为 <strong>1024</strong></p><p><strong>epoll</strong>：设计和实现与 <strong>select</strong> 完全不同。但是底层是链表，这就代表没有上限。</p><p><strong>epoll</strong>：底层采用红黑树，在内核空间创建需要关注的文件描述符的红黑树，内核监听时会将发生事件的描述符加入队列中，返回到用户空间的时候只需要返回队列中的数据即可。epoll通过这种方式使得减少了每次用户到内核的复制过程。</p><h2 id="四、信号驱动I-O"><a href="#四、信号驱动I-O" class="headerlink" title="四、信号驱动I/O"></a>四、信号驱动I/O</h2><p>在多路复用的基础上，能不能有更加有效率的方式来避免这种暴力的轮询机制呢？毕竟大部分轮询都是无效的，且 <strong>SELECT</strong> 轮询时程序进程依旧属于阻塞状态，效率并没有提高多少。</p><p>针对这种情况，就衍生出了 <strong>信号驱动I/O</strong> 模型</p><p><strong>信号驱动I/O</strong>：应用进程使用 <strong>sigaction</strong> 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 <strong>SIGIO</strong> 信号，应用进程收到之后在信号处理程序中调用 <strong>recvfrom</strong> 将数据从内核复制到应用进程中。</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/信号驱动IO.jpg" alt="信号驱动IO"></p><p>相交 <strong>I/O多路复用</strong> 这种通过不断轮询来减少线程资源创建的方式，<strong>信号驱动I/O</strong> 模式通过建立信号关联的机制，实现了发送后只需等待通知即可，避免大量无效的数据状态轮询操作。</p><h2 id="五、异步I-O"><a href="#五、异步I-O" class="headerlink" title="五、异步I/O"></a>五、异步I/O</h2><p>那么在 <strong>信号驱动I/O</strong> 的基础上有没有更进一步效率更高更简洁的操作呢？当然有啦，那就是 <strong>异步I/O</strong> 这个相信大家都不陌生，进程发送 <strong>aio_read</strong> 系统调用会立即返回，内核会在所有操作完成之后向应用进程发送信号，这期间程序线程不阻塞继续执行。</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/异步IO.jpg" alt="异步IO"></p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>以上就是 <strong>Unix</strong> 中的五种 I/O 模型，列举如下:</p><ul><li>阻塞式 I/O</li><li>非阻塞式 I/O</li><li>I/O 复用(select 和 poll)</li><li>信号驱动式 I/O(SIGIO)</li><li>异步 I/O(AIO)</li></ul><p>前四种模型主要区别有 <strong>IO操作</strong> 的第一阶段，就是等待数据阶段，至于第二阶段的数据复制都是一样的。其中 <strong>阻塞式 I/O、非阻塞式 I/O、I/O 复用(select 和 poll)、信号驱动式 I/O(SIGIO)</strong> 都是同步的I/O，虽然非阻塞式 I/O 和信号驱动 I/O 在等待数据阶段不会阻塞，但是在之后的将数据从内核复制到应用进程这个操作会阻塞。<br>只有 <strong>异步I/O</strong> 是完全不阻塞的 <strong>IO操作</strong></p><p>&lt;/br&gt;&lt;/br&gt;</p><h2>参考资料</h2><p></p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/synchronous-and-asynchronous-i-o?redirectedfrom=MSDN">Synchronous and asynchronous I/O</a><br><a href="https://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html#ch06fig01">6.2 I/O Models</a><br><a href="https://www.kancloud.cn/luoyoub/network-programming/2234074">select/poll/epoll</a></p>]]></content>
      
      
      <categories>
          
          <category> 理论知识 </category>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO,IO模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户空间、内核空间</title>
      <link href="/posts/a46eba31.html"/>
      <url>/posts/a46eba31.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、虚拟内存定义"><a href="#一、虚拟内存定义" class="headerlink" title="一、虚拟内存定义"></a>一、虚拟内存定义</h2><p><strong>虚拟内存</strong>：在多任务系统系统中，多任务并行，大大提升了 <strong>CPU</strong> 利用率，但却引出了多个进程对内存操作冲突的问题，<strong>虚拟内存</strong> 概念的提出就是为了解决这个问题，每个进程都运行在属于自己的 <strong>虚拟内存</strong> 中。</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/虚拟内存页表映射物理内存.jpg" alt="虚拟内存页表映射物理内存"></p><p>如上图，虚拟内存通过 <strong>MMU</strong> 将自己映射到物理内存上，使程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个 <strong>物理内存碎片</strong> 。至于具体使用的 <strong>物理内存</strong> 是哪块他们不需知道。所以保证了进程之间不会互相影响。</p><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">维基百科定义</a></p></blockquote><hr class="dotted"><h2 id="二、虚拟内存构成"><a href="#二、虚拟内存构成" class="headerlink" title="二、虚拟内存构成"></a>二、虚拟内存构成</h2><p><strong>虚拟内存</strong> 通常会被分成 <strong>用户空间（User Space）</strong>，与 <strong>核心空间/内核空间（Kernel Space）</strong> 这两个区段。对于 32 位的操作系统，在 Linux 的虚拟地址空间中，用户空间和内核空间的大小比例为 3:1，而在 window 中则为 2:2。</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/虚拟内存结构.jpg" alt="虚拟内存结构"></p><h3 id="2-1-用户空间"><a href="#2-1-用户空间" class="headerlink" title="2.1. 用户空间"></a>2.1. 用户空间</h3><p>进程能实际操作百分百权限的空间</p><ol><li>用户空间是在虚拟内存上连续的，物理内存上 <strong>不连续的，碎片状</strong>。</li><li>通过 <strong>MMU</strong> 来映射。</li></ol><h3 id="2-2、内核空间"><a href="#2-2、内核空间" class="headerlink" title="2.2、内核空间"></a>2.2、内核空间</h3><p>针对一些特权指令并不允许进程直接调用，必须由系统内核调用。因系统内核也在内存中，同时防止用户进程干扰，操作系统为内核单独划分了一块内存区域，这块区域就是内核空间。</p><ol><li><p>内核空间是在虚拟内存和物料内存上都是 <strong>连续的</strong>。</p><ul><li><strong>系统内核</strong> 在系统启动时就需要加载到 <strong>物理内存的内核空间上运行</strong>，又要保证在虚拟内存内存在内核空间，所以进程的 <strong>虚拟地址空间中的内核空间</strong> 映射到 <strong>物理内存中的内核空间</strong>上。</li><li>物理内存的内核空间唯一，所以所有进程的 <strong>虚拟内存中内核空间</strong> 都映射到了 <strong>同一块物理内存区域</strong>。</li></ul></li><li><p>通过 <strong>MMU</strong> 来映射。</p></li><li><p>分级保护域<br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/priv_rings.jpg" alt="分级保护域"></p></li></ol><p>比如 Intel 的 CPU 将特权等级分为 4 个级别：Ring0~Ring3。其实 Linux 系统只使用了 Ring0 和 Ring3 两个运行级别(Windows 系统也是一样的)。当进程运行在 Ring3 级别时被称为运行在用户态，而运行在 Ring0 级别时被称为运行在内核态。</p><blockquote><p>详见：<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%BA%A7%E4%BF%9D%E6%8A%A4%E5%9F%9F">分级保护域</a></p></blockquote><hr class="dotted"><h2 id="三、虚拟内存存在的意义"><a href="#三、虚拟内存存在的意义" class="headerlink" title="三、虚拟内存存在的意义"></a>三、虚拟内存存在的意义</h2><ul><li>虚拟内存可以利用内存起到缓存的作用，提高进程访问磁盘的速度；</li><li>虚拟内存可以为进程提供独立的内存空间，简化程序的链接、加载过程并通过动态库 共享内存；</li><li>虚拟内存可以控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性；</li></ul><hr class="dotted"><h2 id="四、用户态、内核态"><a href="#四、用户态、内核态" class="headerlink" title="四、用户态、内核态"></a>四、用户态、内核态</h2><p>通俗点讲，<strong>用户态</strong> 就是程序在用户空间运行的状态，<strong>内核态</strong> 就是系统内核在内核空间运行的状态。</p><p>其实所有涉及系统资源管理的操作都是在 <strong>内核空间</strong> 内完成的，比如读写磁盘文件，分配回收内存，从网络接口读写数据等等。程序是无法直接访问的，这就涉及到了 <strong>用户态</strong> 和 <strong>内核态</strong> 的通讯机制。通常我们在调用系统提供的接口操作系统资源时都属于这种通讯机制。</p><p>从用户空间和内核空间及通讯角度来看：</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/虚拟内存结构2.png" alt="虚拟内存结构（ps：图片来源于网络）"></p><p><br><font size="5">用户态主动切换至内核态</font><br>粗略根据代码流程看下用户切换到内核态的流水，<strong>用户态 &lt;—&gt; 内核态</strong> 状态切换流程（大致示意）：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文件</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">"/demo.txt"</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">length</span> <span class="operator">=</span> file.length();</span><br></pre></td></tr></tbody></table></figure><br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/file_read.jpg" alt="用户态主动切换到内核态"><p></p><p>上图为文件读取过程程序的用户态和内核态之前的切换，可以看到程序无法直接访问系统资源，如果涉及系统资源的访问都需要通过 <strong>内核空间</strong> ，切换为 <strong>内核态</strong> 才可以。</p><p><br><font size="5"> 用户态切换到内核态的 3 种方式</font>：</p><ul><li>系统调用：用户态主动切换为内核的方式，如上述示例。</li><li>异常：当 CPU 在用户态执行时，发生不可预知异常，则会切换到内核处理异常的机制中，比如缺页异常。</li><li>外围设备的中断。</li></ul><style>.dotted {    border-top: 2px dotted #eed5d2;}</style>]]></content>
      
      
      <categories>
          
          <category> 理论知识 </category>
          
          <category> 内存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟空间,用户态,内核态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM启动参数</title>
      <link href="/posts/9074d23e.html"/>
      <url>/posts/9074d23e.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">​JAVA8虚拟机参数官方文档​</a></p><h3 id="一、-X：显示所有可用-X选项的帮助。"><a href="#一、-X：显示所有可用-X选项的帮助。" class="headerlink" title="一、-X：显示所有可用-X选项的帮助。"></a>一、-X：显示所有可用-X选项的帮助。</h3><div class="table-container"><table><thead><tr><th style="text-align:center">参数名称</th><th style="text-align:center">含义</th><th style="text-align:center">默认值</th><th style="text-align:center">描述/示例</th></tr></thead><tbody><tr><td style="text-align:center">-Xms</td><td style="text-align:center">堆的最小和初始大小（以字节为单位），可以使用 -Xmn 选项或 -XX:NewSize 选项设置年轻代堆的初始大小。</td><td style="text-align:center">初始大小将被设置为分配给老年代和年轻代的大小之和</td><td style="text-align:center">示例：大小设置为 <strong>6MB</strong> 的方式有以下三种： <strong>-Xms6291456</strong>；<strong>-Xms6144k</strong>；<strong>-Xms6m</strong></td></tr><tr><td style="text-align:center">-Xmx</td><td style="text-align:center">堆的最大值</td><td style="text-align:center">默认值是在运行时根据系统配置选择的。</td><td style="text-align:center">-Xms 通常与 -Xmx 设置为相同的值，该 -Xmx 选项相当于 -XX:MaxHeapSize.</td></tr><tr><td style="text-align:center">-Xmn</td><td style="text-align:center">新生代（nursery）设置堆的初始大小和最大大小（以字节为单位）</td><td style="text-align:center"></td><td style="text-align:center">Oracle 建议将新生代的大小保持在整个堆大小的一半到四分之一之间。相当于 -XX:NewSize、-XX:MaxNewSize</td></tr><tr><td style="text-align:center">-XX:MetaspaceSize</td><td style="text-align:center">设置分配的类元数据空间的大小</td><td style="text-align:center"></td><td style="text-align:center">该空间将在第一次超出时触发垃圾回收。垃圾回收的阈值根据使用的元数据量增加或减少。默认大小取决于平台。</td></tr><tr><td style="text-align:center">-XX:MaxMetaspaceSize</td><td style="text-align:center">设置可以分配给类元数据的最大本机内存量。</td><td style="text-align:center">设置为 256 MB：-XX:MaxMetaspaceSize=256m</td><td style="text-align:center">默认情况下，大小不受限制。应用程序的元数据量取决于应用程序本身、其他正在运行的应用程序以及系统上可用的内存量。</td></tr><tr><td style="text-align:center">-XX:+UseConcMarkSweepGC</td><td style="text-align:center">为老年代启用 CMS 垃圾收集器。</td><td style="text-align:center"></td><td style="text-align:center">默认情况下，这个选项是禁用的，收集器是根据机器的配置和 JVM 的类型自动选择的。启用此选项后，该-XX:+UseParNewGC选项会自动设置，以下选项组合已在 JDK 8 中弃用：-XX:+UseConcMarkSweepGC -XX:-UseParNewGC。</td></tr><tr><td style="text-align:center">-XX:CMSInitiatingOccupancyFraction</td><td style="text-align:center">设置开始 CMS 收集周期的老年代占用百分比（0 到 100）。</td><td style="text-align:center">默认值设置为 -1。任何负值（包括默认值）都意味着-XX:CMSTriggerRatio用于定义初始占用率的值。</td><td style="text-align:center">以下示例显示如何将占用率设置为 20%：-XX:CMSInitiatingOccupancyFraction=20</td></tr><tr><td style="text-align:center">-XX:SoftRefLRUPolicyMSPerMB</td><td style="text-align:center">设置软可达对象在上次被引用后在堆上保持活动状态的时间量（以毫秒为单位）。</td><td style="text-align:center">默认值是堆中每兆字节的生命周期一秒。</td><td style="text-align:center">以下示例显示如何将值设置为 2.5 秒：-XX:SoftRefLRUPolicyMSPerMB=2500</td></tr><tr><td style="text-align:center">-XX:+CMSClassUnloadingEnabled</td><td style="text-align:center">使用并发标记清除 (CMS) 垃圾收集器时启用类卸载。</td><td style="text-align:center"></td><td style="text-align:center">默认情况下启用此选项。要禁用 CMS 垃圾收集器的类卸载，请指定-XX:-CMSClassUnloadingEnabled.</td></tr><tr><td style="text-align:center">-XX:SurvivorRatio</td><td style="text-align:center">设置伊甸园空间大小和幸存者空间大小之间的比率。</td><td style="text-align:center">默认情况下，此选项设置为 8。</td><td style="text-align:center">示例显示如何将 eden/survivor 空间比率设置为 4：-XX:SurvivorRatio=4</td></tr><tr><td style="text-align:center">-verbose:gc</td><td style="text-align:center">显示有关每个垃圾回收 (GC) 事件的信息。</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">-Xloggc</td><td style="text-align:center">设置详细 GC 事件信息应重定向到的文件以进行日志记录。</td><td style="text-align:center"></td><td style="text-align:center">写入此文件的信息类似于-verbose:gc自每个记录事件之前的第一个 GC 事件以来经过的时间的输出。如果两者都使用相同的命令，则该-Xloggc选项会覆盖。-verbose:gcjava 例子：-Xloggc:garbage-collection.log</td></tr><tr><td style="text-align:center">-XX:+PrintGCDetails</td><td style="text-align:center">允许在每次 GC 时打印详细消息。默认情况下，此选项被禁用。</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">-XX:+PrintGCDateStamps</td><td style="text-align:center">启用在每个 GC 上打印日期戳。默认情况下，此选项被禁用。</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">-XX:+UseGCLogFileRotation</td><td style="text-align:center">此参数主要定义GC Log 的滚动功能</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">-XX:NumberOfGCLogFiles</td><td style="text-align:center">此参数主要定义滚动日志文件的个数，此参数值必须大于等于1，对应的日志文件命名策略为：<filename>.0、<filename>.1、 … 、 <filename>.n-1等，其中 n 是 该参数的值。</filename></filename></filename></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">-XX:GCLogFileSize</td><td style="text-align:center">此参数主要定义滚动日志文件的大小，必须大于 8k，当前写日志文件大小超过该参数值时，日志将写入下一个文件，依次类推。</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">-XX:-OmitStackTraceInFastThrow</td><td style="text-align:center">禁用fast throw。fast throw：优化这个抛出异常的地方，同一个异常多次抛出会直接抛出一个事先分配好的、类型匹配的对象，这个对象的message和stack trace都被清空</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">-XX:+UseCMSCompactAtFullCollection</td><td style="text-align:center">使用并发收集器时,开启对年老代的压缩.</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">-XX:+CMSParallelRemarkEnabled</td><td style="text-align:center">降低标记停顿</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">-XX:+UseLargePages</td><td style="text-align:center">启用大页面内存的使用。默认情况下，禁用此选项并且不使用大页面内存。</td><td style="text-align:center"></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell脚本相关笔记</title>
      <link href="/posts/206f81a4.html"/>
      <url>/posts/206f81a4.html</url>
      
        <content type="html"><![CDATA[<h3 id="a到-z的含义"><a href="#a到-z的含义" class="headerlink" title="-a到-z的含义"></a>-a到-z的含义</h3><p>变量    含义<br>[ -a FILE ]    如果 FILE 存在则为真<br>[ -b FILE ]    如果 FILE 存在且是一个块特殊文件则为真<br>[ -c FILE ]    如果 FILE 存在且是一个字特殊文件则为真<br>[ -e FILE ]    如果 FILE 存在则为真<br>[ -f FILE ]    如果 FILE 存在且是一个普通文件则为真<br>[ -g FILE ]    如果 FILE 存在且已经设置了SGID则为真<br>[ -h FILE ]    如果 FILE 存在且是一个符号连接则为真<br>[ -k FILE ]    如果 FILE 存在且已经设置了粘制位则为真<br>[ -r FILE ]    如果 FILE 存在且是可读的则为真<br>[ -s FILE ]    如果 FILE 存在且大小不为0则为真<br>[ -t FD ]    如果文件描述符 FD 打开且指向一个终端则为真<br>[ -u FILE ]    如果 FILE 存在且设置了SUID (set user ID)则为真<br>[ -w FILE ]    如果 FILE 如果 FILE 存在且是可写的则为真<br>[ -x FILE ]    如果 FILE 存在且是可执行的则为真<br>[ -O FILE ]    如果 FILE 存在且属有效用户ID则为真<br>[ - G FILE ]    如果 FILE 存在且属有效用户组则为真<br>[ -L FILE ]    如果 FILE 存在且是一个符号连接则为真<br>[ -N FILE ]    如果 FILE 存在 and has been mod如果ied since it was last read则为真<br>[ -S FILE ]    如果 FILE 存在且是一个套接字则为真<br>[ -z STRING ]    “STRING” 的长度为零则为真</p><p>字符串判断<br>变量    含义<br>str1 = str2    两个字符串完全相等为真<br>str1 != str2    两个字符串不完全相等为真<br>-n str1    当串的长度大于0时为真(串非空)<br>-z str1    当串的长度为0时为真(空串)<br>str1    当串str1为非空时为真<br>数字判断<br>变量    含义<br>int1 -eq int2    两数字相等为真<br>int1 -ne int2    两数字不相等为真<br>int1 -gt int2    int1大于int2为真<br>int1 -ge int2    int1&gt;= int2为真<br>in1 -lt int2    int1&lt;int2 为真<br>int1 -le int2    int1 &lt;= int2为真<br>文件判断<br>变量名    含义<br>-r file    用户可读为真<br>-w file    用户可写为真<br>-f file    文件为正规文件为真<br>-x file    用户可执行为真<br>-d file    文件为目录为真<br>-c file    闻见味特殊字符文件为真<br>-s file    文件大小非0为真<br>-b file    文件为块特殊文件为真<br>-t file    文件描述符(默认1)指定的设备为终端时为真<br>复杂逻辑<br>变量名    含义<br>-a    与<br>-o    或<br>!    非<br>!=    不等于</p><p>作者：PengboGai<br>链接：<a href="https://www.jianshu.com/p/73b562050e83">https://www.jianshu.com/p/73b562050e83</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MQ原理和技术选型</title>
      <link href="/posts/8911925b.html"/>
      <url>/posts/8911925b.html</url>
      
        <content type="html"><![CDATA[<h1 id="MQ原理及选型"><a href="#MQ原理及选型" class="headerlink" title="MQ原理及选型"></a>MQ原理及选型</h1><h2 id="一、消息队列概念"><a href="#一、消息队列概念" class="headerlink" title="一、消息队列概念"></a>一、消息队列概念</h2><h3 id="1-1、概述"><a href="#1-1、概述" class="headerlink" title="1.1、概述"></a>1.1、概述</h3><p><strong>消息队列（英语：Message queue，简称：MQ）</strong>：是一种进程间通信或同一进程的不同线程间的通信方式。</p><ul><li>消息（Message）：是指在应用之间传送的数据，消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。</li><li>队列（Queue）：保持消息的容器，本质上为队列。</li></ul><p><strong>原始模型：</strong><br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/MQ/MQ_basic_model.jpg" alt="MQ基本模型"></p><p>消息队列的本质很好理解，本质都是：<strong><font color="red">一发、一存、一消</font></strong>，所有复杂模型和中间件实现都是基于这个最初原理和模型来实现的。</p><h3 id="1-2、MQ模型"><a href="#1-2、MQ模型" class="headerlink" title="1.2、MQ模型"></a>1.2、MQ模型</h3><p>现在有MQ产品都是在上面的原始模型基础上进行演化、扩展出来的功能更完善、性能更稳定的中间件。目前比较通用的MQ模型有两种：</p><ul><li>点对点模型（point to point，queue）模型。</li><li>发布/订阅（publish/subscribe，topic）模型。</li></ul><h4 id="点对点模型"><a href="#点对点模型" class="headerlink" title="点对点模型"></a>点对点模型</h4><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/MQ/MQ_peertopeer_model.jpg" alt="MQ_peertopeer_model"></p><p><strong>特点：</strong></p><ul><li>消息的消费顺序和生产顺序一致。</li><li>它允许多个生产者往同一个队列发送消息。</li><li>若多消费者接收同一队列的消息，这些消费者间就是竞争关系。一条消息只能被其中一个消费者接收到，读完即被删除。</li><li>接收者在成功接收消息之后需向队列应答成功</li></ul><h4 id="发布-订阅模型"><a href="#发布-订阅模型" class="headerlink" title="发布/订阅模型"></a>发布/订阅模型</h4><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/MQ/MQ_pub-sub_model.jpg" alt="MQ_pub-sub_model"></p><p><strong>特点：</strong></p><ul><li>每个消息可以有多个消费者：和点对点方式不同，发布消息可以被所有订阅者消费。</li><li>发布者和订阅者之间有时间上的依赖性。</li><li>针对某个主题 <strong>（Topic）</strong> 的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。</li><li>为了消费消息，订阅者必须保持运行的状态。</li></ul><hr><h2 id="二、消息队列优、缺"><a href="#二、消息队列优、缺" class="headerlink" title="二、消息队列优、缺"></a>二、消息队列优、缺</h2><p>消息队列使用三个经典的场景：异步、解耦、削峰。无论因为什么都是这三点的延伸。下面就这三个模块展开细说。</p><h3 id="2-1、优-异步"><a href="#2-1、优-异步" class="headerlink" title="2.1、优-异步"></a>2.1、优-异步</h3><p>消息队列的主要特点就是异步执行，以异步的方式执行非核心业务逻辑来降低 <strong>RT（Response Time）</strong>，提高用户体验和流畅性。</p><p>比如某个充值场景，最初可能就是个简单的充值，充值支付成功就OK。但随着迭代和推广，出现了充值返利、积分、充值赠券、充值后短信通知等等功能。这个时候同步操作就很影响响应时间了。</p><p>此时就需要考虑异步操作，将非必要的放在MQ异步完成，压缩响应时间。</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/MQ/MQ_Async_model.jpeg" alt="异步模型"></p><h3 id="2-2、优-解耦"><a href="#2-2、优-解耦" class="headerlink" title="2.2、优-解耦"></a>2.2、优-解耦</h3><p>还是上面充值的场景，假如不用MQ，我直接使用异步线程或者分布式情况下调用其它服务接口不一样实现异步的操作么。</p><p>其实是可以的，但弊端就是后续再有相关的流程加入到充值操作里面，就需要改代码、加调用。流程越多改的次数越多。</p><p>所以MQ的另一个特性就体现出来了：<strong>解耦</strong>。如果使用MQ充值成功后发布个充值成功到队列，谁需要谁就去消费，这样充值就直负责充值，其它的就不用管了。各自系统负责自己的任务就可以了。</p><p>所以MQ可实现模块、服务、接口等不同粒度上实现解耦。</p><h3 id="2-3、优-削峰"><a href="#2-3、优-削峰" class="headerlink" title="2.3、优-削峰"></a>2.3、优-削峰</h3><p>削峰就比较好理解了，比如系统推广或秒杀的时候，突然<strong>QPS</strong>（QPS：Queries Per Second：每秒查询率）极速上涨。这个时候就得考虑服务是否能承载这么大的访问，如果超出系统负责可能直接就是崩掉了。</p><p>这个时候就可以把请求先放到MQ中，至于每秒消费多少就根据数据库、中间件以及服务本身的实际情况来判断并消费对应的消息就可以了。虽然响应慢一些，但不至于直接把服务干蹦掉。</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/MQ/MQ_weaken_peak_model.jpg" alt="削峰模型"></p><h3 id="2-4、使用MQ的缺点"><a href="#2-4、使用MQ的缺点" class="headerlink" title="2.4、使用MQ的缺点"></a>2.4、使用MQ的缺点</h3><p>以上均为系统加入MQ的优点，那么有没有缺点呢？当然有了，所有东西都要辩证的来得。</p><ul><li>系统复杂性：原本系统的基础上增加中间件，就要考虑其使用、维护、问题定位等问题。再加上MQ机制本身也要考虑：重复消费、消息丢失、消息的顺序消费等等问题。系统复杂性的增加不言而喻了。</li><li>数据一致性：比如刚刚的充值，充值操作是完成了，那返利是否完成？优惠券是否发放？短信是否已通知到位？</li><li>可用性：原本只需要考虑系统的健壮性就可以，现在增加了中间件MQ，那MQ挂了怎么处理？系统是否就直接宕掉了？</li></ul><p>当然这些都是可以处理，只不过增加相应的开发、维护成本。最终是否使用MQ还是需要根据实际的系统和业务需求来考虑其使用情况</p><hr><h2 id="三、消息队列协议"><a href="#三、消息队列协议" class="headerlink" title="三、消息队列协议"></a>三、消息队列协议</h2><h3 id="3-1、JMS：Java-Message-Service（Java-消息服务）"><a href="#3-1、JMS：Java-Message-Service（Java-消息服务）" class="headerlink" title="3.1、JMS：Java Message Service（Java 消息服务）"></a>3.1、JMS：Java Message Service（Java 消息服务）</h3><p><a href="https://www.oracle.com/technical-resources/articles/java/intro-java-message-service.html">JMS</a>：Java 消息服务 (JMS) API 是一种消息传递标准，它允许基于 Java 平台企业版 (Java EE) 的应用程序组件创建、发送、接收和读取消息。它支持松耦合、可靠和异步的分布式通信。</p><font size="5" color="#b9268d">支持两种模型： </font><ul><li>点对点（队列目的地）：在此模型中，消息从生产者传递到一个消费者。</li><li>发布/订阅（主题目的地）：在此模型中，消息从生产者传递到任意数量的消费者。</li></ul><font size="5" color="#b9268d">JMS优点：</font><ul><li>同时支持同步和异步<ul><li>同步：在这种模式下，客户端通过调用对象的receive()方法来接收消息MessageConsumer。应用程序线程阻塞直到方法返回，这会导致如果消息不可用，它会阻塞直到消息可用或receive()方法超时。</li><li>异步：在这种模式下，客户端MessageListener向消息消费者注册一个对象。这类似于回调，其中客户端在会话调用onMessage()方法时使用消息。</li></ul></li><li>可靠的；JMS 定义了两种传递模式：<ul><li>持久化消息：保证一次且仅一次成功消费。消息不会丢失。</li><li>非持久消息：保证最多传递一次。消息丢失不是问题。<br>JMS 提供了确保消息将被传递一次且仅一次的设施。我们知道重复的消息会产生问题。JMS 可以帮助您避免此类问题。</li></ul></li></ul><p><a href="https://activemq.apache.org/">ActiveMQ</a>：就是<strong>JMS</strong>规范中的一种消息中间件。</p><hr class="dotted"><h3 id="3-2、AMQP：Advanced-Message-Queuing-Protocol（高级消息队列协议）"><a href="#3-2、AMQP：Advanced-Message-Queuing-Protocol（高级消息队列协议）" class="headerlink" title="3.2、AMQP：Advanced Message Queuing Protocol（高级消息队列协议）"></a>3.2、AMQP：Advanced Message Queuing Protocol（高级消息队列协议）</h3><p><strong>AMQP：</strong> 是一个二进制的、面向消息的中间件的开放标准，应用层协议。</p><ul><li>旨在有效地支持各种消息传递应用程序和通信模式。</li><li>其特征是消息导向、队列、路由（包括点对点和发布-订阅）、可靠性和安全性。</li><li>基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同开发语言等条件的限制。</li></ul><p><a href="https://www.rabbitmq.com/">RabbitMQ</a>：就是AMQP协议的标准实现。<br><strong>基础模型：</strong><br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/MQ/MQ_amqp_model.jpg" alt="MQ_amqp_model"></p><hr class="dotted"><h3 id="3-3、STOMP：The-Simple-Text-Oriented-Messaging-Protocol（面向简单文本的消息协议）"><a href="#3-3、STOMP：The-Simple-Text-Oriented-Messaging-Protocol（面向简单文本的消息协议）" class="headerlink" title="3.3、STOMP：The Simple Text Oriented Messaging Protocol（面向简单文本的消息协议）"></a>3.3、STOMP：The Simple Text Oriented Messaging Protocol（面向简单文本的消息协议）</h3><p><strong>STOMP：</strong> 是简单（或流式）文本导向消息传递协议，其设计的主要理念是简单性和互操作性。<br><strong>STOMP：</strong> 是一种基于框架的协议，框架以 <strong>HTTP</strong> 为模型。一个框架由一个命令、一组可选的头部和一个可选的主体组成。<strong>STOMP</strong> 基于文本，但也允许传输二进制消息。</p><p><strong>兼容STOMP协议的中间件：</strong><br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/MQ/MQ_compatible_stomp_server.jpg" alt="MQ_compatible_stomp_server"></p><hr class="dotted"><h3 id="3-4、MQTT"><a href="#3-4、MQTT" class="headerlink" title="3.4、MQTT"></a>3.4、MQTT</h3><p><strong>MQTT：</strong> 最初IBM最初发布时定义名称为：Message Queuing Telemetry Transport（消息队列遥测传输协议），但随着在物联网内的应用和发展 <strong>MQTT</strong> 正迅速成为IOT（物联网）部署的主要协议之一。所以称它为：<strong>用于物联网 (IoT) 的 OASIS 标准消息传递协议</strong> 更为准确。</p><p><strong>MQTT：</strong> 被设计为一种极其轻量级的发布/订阅消息传输，非常适合连接具有小代码占用空间和最小网络带宽的远程设备。如今，MQTT 被广泛用于各种行业，例如汽车、制造、电信、石油和天然气等。</p><p><strong>官方架构图：</strong><br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/MQ/MQ_mqtt_official_architecture.jpg" alt="MQ_mqtt_official_architecture"></p><hr class="dotted"><h3 id="3-5、XMPP：Extensible-Messaging-and-Presence-Protocol（可扩展消息与存在协议）"><a href="#3-5、XMPP：Extensible-Messaging-and-Presence-Protocol（可扩展消息与存在协议）" class="headerlink" title="3.5、XMPP：Extensible Messaging and Presence Protocol（可扩展消息与存在协议）"></a>3.5、XMPP：Extensible Messaging and Presence Protocol（可扩展消息与存在协议）</h3><p><strong>XXMP：</strong> 是一种以XML为基础的开放式即时通信协议。该协议于 1999 年从 Jabber 开源社区出现，最初旨在为 ICQ、AIM 和 MSN 等面向消费者的即时消息 (IM) 服务提供一种开放、安全、去中心化的替代方案。核心技术于 2004 年在IETF中以可扩展消息传递和存在协议 (XMPP) 的名称正式确定  。这些核心技术包括：</p><ul><li>基本 XML 流层</li><li>使用传输层安全性 (TLS) 的通道加密</li><li>使用简单身份验证和安全层 (SASL) 的强身份验证</li><li>使用 UTF-8 获得完整的 Unicode 支持，包括完全国际化的地址</li><li>关于网络可用性的内置信息（“存在”）</li><li>用于双向授权的 Presence 订阅</li><li>启用在线状态的联系人列表（“花名册”）</li></ul><h2 id="四、MQ中间件"><a href="#四、MQ中间件" class="headerlink" title="四、MQ中间件"></a>四、MQ中间件</h2><h4 id="参照网络数据形成的各MQ不同维度的对比"><a href="#参照网络数据形成的各MQ不同维度的对比" class="headerlink" title="参照网络数据形成的各MQ不同维度的对比"></a>参照网络数据形成的各MQ不同维度的对比</h4><div class="table-container"><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>开发语言</td><td>java</td><td>Erlang</td><td>Java</td><td>Scala</td></tr><tr><td>支持的协议</td><td>OpenWire、STOMP、REST、XMPP、AMQP</td><td>AMQP</td><td>自定义</td><td>基于TCP自定义的一套</td></tr><tr><td>客户端支持语言</td><td>JAVA、C、C++、Python、PHP、Pert、net等</td><td>官方支持Erlang、Java/Ruby等，社区产出多种语言API，几乎支持所有常用语言</td><td>JAVA、C++（不成熟）</td><td>官方支持JAVA,开源社区有多语言版本，如PHP,Python,GO,C/C++，Ruby，NodeJS等编程语言</td></tr><tr><td>单机吞吐量</td><td>万级</td><td>万级</td><td>10万级</td><td>10万级别</td></tr><tr><td>topic数量对吞吐量的影响</td><td></td><td></td><td>topic可以达到几百，几千个的级别，吞吐量会有较小幅度的下降 这是RocketMQ的一大优势，在同等机器下，可以支撑大量的topic</td><td>topic从几十个到几百个的时候，吞吐量会大幅度下降 所以在同等机器下，kafka尽量保证topic数量不要过多。如果要支撑大规模topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms级</td><td>微秒级</td><td>ms级</td><td>延迟在ms级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用性</td><td>高，基于主从架构实现高可用性</td><td>非常高，分布式架构</td><td>非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到0丢失</td><td>经过参数优化配置，消息可以做到0丢失</td></tr><tr><td>事物</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>持久化</td><td>内存、文件、数据库</td><td>内存、文件，支持数据堆积，但数据堆积会影响生产速率</td><td>磁盘文件</td><td>磁盘文件，只要磁盘容量足够，可以做到无限消息堆积</td></tr><tr><td>功能支持</td><td>MQ领域的功能极其完备</td><td>基于erlang开发，所以并发能力很强，性能极其好，延时很低</td><td>MQ功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td></tr><tr><td>社区活跃度</td><td>低</td><td>中</td><td>高</td><td>高</td></tr></tbody></table></div><p>综合上面的对比数据再结合项目实际的业务需求其实就已经可以很好的总结出具体的技术选型了。</p><font size="5" color="#b9268d">记住，没有最好的技术，只有最适合的技术，不要为了用而用。</font><style>.dotted {    border-top: 2px dotted #eed5d2;}</style>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ——《1、启动脚本》</title>
      <link href="/posts/10a565f9.html"/>
      <url>/posts/10a565f9.html</url>
      
        <content type="html"><![CDATA[<h1 id="RocketMQ使用记录"><a href="#RocketMQ使用记录" class="headerlink" title="RocketMQ使用记录"></a>RocketMQ使用记录</h1><p><strong>RocketMQ</strong> 相关的操作和使用官方的文档是有具体步骤讲解的：<a href="https://rocketmq.apache.org/zh/docs/">RocketMQ官方</a>。本文基于官方文档的基础上 <strong>深入每步的具体操作</strong> 及后续 <strong>运行原理和源码</strong> 进行进一步分析和讨论。</p><h2 id="一、启动"><a href="#一、启动" class="headerlink" title="一、启动"></a>一、启动</h2><p>安装好Rocket后，启动操作如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 启动namesrv</span></span><br><span class="line">$ <span class="built_in">nohup</span> sh bin/mqnamesrv &amp;</span><br><span class="line"> </span><br><span class="line"><span class="comment">### 验证namesrv是否启动成功</span></span><br><span class="line">$ <span class="built_in">tail</span> -f ~/logs/rocketmqlogs/namesrv.log</span><br><span class="line">The Name Server boot success...</span><br></pre></td></tr></tbody></table></figure><br>下面分解启动流程内包含的所有操作和配置。<p></p><h3 id="1-1、mqnamesrv"><a href="#1-1、mqnamesrv" class="headerlink" title="1.1、mqnamesrv"></a>1.1、mqnamesrv</h3><p>源码：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$ROCKETMQ_HOME</span>"</span> ] ; <span class="keyword">then</span></span><br><span class="line">  <span class="comment">## resolve links - $0 may be a link to maven's home</span></span><br><span class="line">  <span class="comment"># 获取执行文件名称   </span></span><br><span class="line">  PRG=<span class="string">"<span class="variable">$0</span>"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果 $0 是软连接则通过迭代获取其绝对路径</span></span><br><span class="line">  <span class="comment"># need this for relative symlinks</span></span><br><span class="line">  <span class="keyword">while</span> [ -h <span class="string">"<span class="variable">$PRG</span>"</span> ] ; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">ls</span>=`<span class="built_in">ls</span> -ld <span class="string">"<span class="variable">$PRG</span>"</span>`</span><br><span class="line">    <span class="built_in">link</span>=`<span class="built_in">expr</span> <span class="string">"<span class="variable">$ls</span>"</span> : <span class="string">'.*-&gt; \(.*\)$'</span>`</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">expr</span> <span class="string">"<span class="variable">$link</span>"</span> : <span class="string">'/.*'</span> &gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">      PRG=<span class="string">"<span class="variable">$link</span>"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      PRG=<span class="string">"`dirname "</span><span class="variable">$PRG</span><span class="string">"`/<span class="variable">$link</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">  saveddir=`<span class="built_in">pwd</span>`</span><br><span class="line"></span><br><span class="line">  ROCKETMQ_HOME=`<span class="built_in">dirname</span> <span class="string">"<span class="variable">$PRG</span>"</span>`/..</span><br><span class="line"></span><br><span class="line">  <span class="comment"># make it fully qualified</span></span><br><span class="line">  ROCKETMQ_HOME=`<span class="built_in">cd</span> <span class="string">"<span class="variable">$ROCKETMQ_HOME</span>"</span> &amp;&amp; <span class="built_in">pwd</span>`</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cd</span> <span class="string">"<span class="variable">$saveddir</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> ROCKETMQ_HOME</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行runserver.sh脚本，启动 NamesrvStartup 类文件</span></span><br><span class="line">sh <span class="variable">${ROCKETMQ_HOME}</span>/bin/runserver.sh org.apache.rocketmq.namesrv.NamesrvStartup <span class="variable">$@</span></span><br></pre></td></tr></tbody></table></figure><br>所以mqnamesrv内容很简单：<p></p><ul><li>找到 <strong>ROCKETMQ_HOME</strong> 的绝对路径，即下载包所在的绝对路径。</li><li>设置环境变量 <strong>ROCKETMQ_HOME</strong></li><li>启动 <strong>runserver.sh</strong> 脚本，并带有指定类 <strong>NamesrvStartup</strong>。</li><li>如果运行 <strong>mqnamesrv</strong> 时有额外参数也一并带入 <strong>runserver.sh</strong> 脚本中。</li></ul><h3 id="1-2、runserver"><a href="#1-2、runserver" class="headerlink" title="1.2、runserver"></a>1.2、runserver</h3><p>源码：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误日志输出</span></span><br><span class="line"><span class="function"><span class="title">error_exit</span></span> ()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"ERROR: <span class="variable">$1</span> !!"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment"># 校验JAVA环境是否存在</span></span><br><span class="line">[ ! -e <span class="string">"<span class="variable">$JAVA_HOME</span>/bin/java"</span> ] &amp;&amp; JAVA_HOME=<span class="variable">$HOME</span>/jdk/java</span><br><span class="line">[ ! -e <span class="string">"<span class="variable">$JAVA_HOME</span>/bin/java"</span> ] &amp;&amp; JAVA_HOME=/usr/java</span><br><span class="line">[ ! -e <span class="string">"<span class="variable">$JAVA_HOME</span>/bin/java"</span> ] &amp;&amp; error_exit <span class="string">"Please set the JAVA_HOME variable in your environment, We need java(x64)!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义环境变量</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME</span><br><span class="line"><span class="built_in">export</span> JAVA=<span class="string">"<span class="variable">$JAVA_HOME</span>/bin/java"</span></span><br><span class="line"><span class="built_in">export</span> BASE_DIR=$(<span class="built_in">dirname</span> <span class="variable">$0</span>)/..</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">${BASE_DIR}</span>/conf:<span class="variable">${BASE_DIR}</span>/lib/*:<span class="variable">${CLASSPATH}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#===========================================================================================</span></span><br><span class="line"><span class="comment"># JVM Configuration</span></span><br><span class="line"><span class="comment">#===========================================================================================</span></span><br><span class="line"><span class="comment"># The RAMDisk initializing size in MB on Darwin OS for gc-log</span></span><br><span class="line">DIR_SIZE_IN_MB=600</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择GC日志目录</span></span><br><span class="line"><span class="function"><span class="title">choose_gc_log_directory</span></span>()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"`uname`"</span> <span class="keyword">in</span></span><br><span class="line">        Darwin)</span><br><span class="line">            <span class="keyword">if</span> [ ! -d <span class="string">"/Volumes/RAMDisk"</span> ]; <span class="keyword">then</span></span><br><span class="line">                <span class="comment"># create ram disk on Darwin systems as gc-log directory</span></span><br><span class="line">                DEV=`hdiutil attach -nomount ram://$((<span class="number">2</span> * <span class="number">1024</span> * DIR_SIZE_IN_MB))` &gt; /dev/null</span><br><span class="line">                diskutil eraseVolume HFS+ RAMDisk <span class="variable">${DEV}</span> &gt; /dev/null</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Create RAMDisk /Volumes/RAMDisk for gc logging on Darwin OS."</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">            GC_LOG_DIR=<span class="string">"/Volumes/RAMDisk"</span></span><br><span class="line">        ;;</span><br><span class="line">        *)</span><br><span class="line">            <span class="comment"># check if /dev/shm exists on other systems</span></span><br><span class="line">            <span class="keyword">if</span> [ -d <span class="string">"/dev/shm"</span> ]; <span class="keyword">then</span></span><br><span class="line">                GC_LOG_DIR=<span class="string">"/dev/shm"</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                GC_LOG_DIR=<span class="variable">${BASE_DIR}</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置JVM启动参数</span></span><br><span class="line"><span class="function"><span class="title">choose_gc_options</span></span>()</span><br><span class="line">{</span><br><span class="line">    <span class="comment"># Example of JAVA_MAJOR_VERSION value : '1', '9', '10', '11', ...</span></span><br><span class="line">    <span class="comment"># '1' means releases befor Java 9</span></span><br><span class="line">    JAVA_MAJOR_VERSION=$(<span class="string">"<span class="variable">$JAVA</span>"</span> -version 2&gt;&amp;1 | sed -r -n <span class="string">'s/.* version "([0-9]*).*$/\1/p'</span>)</span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$JAVA_MAJOR_VERSION</span>"</span> ] || [ <span class="string">"<span class="variable">$JAVA_MAJOR_VERSION</span>"</span> -lt <span class="string">"9"</span> ] ; <span class="keyword">then</span></span><br><span class="line">      JAVA_OPT=<span class="string">"<span class="variable">${JAVA_OPT}</span> -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</span></span><br><span class="line">      JAVA_OPT=<span class="string">"<span class="variable">${JAVA_OPT}</span> -XX:+UseConcMarkSweepGC -XX:+UseCMSCompactAtFullCollection -XX:CMSInitiatingOccupancyFraction=70 -XX:+CMSParallelRemarkEnabled -XX:SoftRefLRUPolicyMSPerMB=0 -XX:+CMSClassUnloadingEnabled -XX:SurvivorRatio=8 -XX:-UseParNewGC"</span></span><br><span class="line">      JAVA_OPT=<span class="string">"<span class="variable">${JAVA_OPT}</span> -verbose:gc -Xloggc:<span class="variable">${GC_LOG_DIR}</span>/rmq_srv_gc_%p_%t.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps"</span></span><br><span class="line">      JAVA_OPT=<span class="string">"<span class="variable">${JAVA_OPT}</span> -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=30m"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      JAVA_OPT=<span class="string">"<span class="variable">${JAVA_OPT}</span> -server -Xms4g -Xmx4g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</span></span><br><span class="line">      JAVA_OPT=<span class="string">"<span class="variable">${JAVA_OPT}</span> -XX:+UseG1GC -XX:G1HeapRegionSize=16m -XX:G1ReservePercent=25 -XX:InitiatingHeapOccupancyPercent=30 -XX:SoftRefLRUPolicyMSPerMB=0"</span></span><br><span class="line">      JAVA_OPT=<span class="string">"<span class="variable">${JAVA_OPT}</span> -Xlog:gc*:file=<span class="variable">${GC_LOG_DIR}</span>/rmq_srv_gc_%p_%t.log:time,tags:filecount=5,filesize=30M"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">choose_gc_log_directory</span><br><span class="line">choose_gc_options</span><br><span class="line">JAVA_OPT=<span class="string">"<span class="variable">${JAVA_OPT}</span> -XX:-OmitStackTraceInFastThrow"</span></span><br><span class="line">JAVA_OPT=<span class="string">"<span class="variable">${JAVA_OPT}</span> -XX:-UseLargePages"</span></span><br><span class="line"><span class="comment">#JAVA_OPT="${JAVA_OPT} -Xdebug -Xrunjdwp:transport=dt_socket,address=9555,server=y,suspend=n"</span></span><br><span class="line">JAVA_OPT=<span class="string">"<span class="variable">${JAVA_OPT}</span> <span class="variable">${JAVA_OPT_EXT}</span>"</span></span><br><span class="line">JAVA_OPT=<span class="string">"<span class="variable">${JAVA_OPT}</span> -cp <span class="variable">${CLASSPATH}</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$JAVA</span> <span class="variable">${JAVA_OPT}</span> <span class="variable">$@</span></span><br></pre></td></tr></tbody></table></figure><br>流程：<p></p><ol><li>校验JAVA环境信息</li><li>定义环境变量，包含JAVA、RocketMQ等。</li><li>设置JVM的GC日志目录</li><li>设置JVM启动信息，设置参数如下：<ul><li>-Xms4g：堆的最小和初始大小4G。</li><li>-Xmx4g：堆的最大值4G。</li><li>-Xmn2g：新生代2G。</li><li>-XX:MetaspaceSize=128m：元数据空间为128M</li><li>-XX:MaxMetaspaceSize=320m：类元数据的最大本机内存量为320M</li><li>-XX:+UseConcMarkSweepGC：为老年代启用 CMS 垃圾收集器。</li><li>-XX:CMSInitiatingOccupancyFraction=70：设置开始 CMS 收集周期的老年代占用百分比（0 到 100）。</li><li>-XX:SoftRefLRUPolicyMSPerMB=0：设置软可达对象在上次被引用后在堆上保持活动状态的时间量（以毫秒为单位）。</li><li>-XX:+CMSClassUnloadingEnabled：使用并发标记清除 (CMS) 垃圾收集器时启用类卸载。</li><li>-XX:SurvivorRatio=8：设置伊甸园空间大小和幸存者空间大小之间的比率。</li><li>-verbose:gc：显示有关每个垃圾回收 (GC) 事件的信息。</li><li>-Xloggc：设置详细 GC 事件信息应重定向到的文件以进行日志记录。</li><li>-XX:+PrintGCDetails：允许在每次 GC 时打印详细消息。默认情况下，此选项被禁用。</li><li>-XX:+PrintGCDateStamps：启用在每个 GC 上打印日期戳。默认情况下，此选项被禁用。</li><li>-XX:+UseGCLogFileRotation：此参数主要定义GC Log 的滚动功能</li><li>-XX:NumberOfGCLogFiles=5：此参数主要定义滚动日志文件的个数</li><li>-XX:GCLogFileSize=30m：此参数主要定义滚动日志文件的大小</li><li>-XX:-OmitStackTraceInFastThrow：禁用fast throw。fast throw：优化这个抛出异常的地方，同一个异常多次抛出会直接抛出一个事先分配好的、类型匹配的对象，这个对象的message和stack trace都被清空</li><li>-XX:+UseCMSCompactAtFullCollection：使用并发收集器时,开启对年老代的压缩.</li><li>-XX:+CMSParallelRemarkEnabled：降低标记停顿</li><li>-XX:+UseLargePages：启用大页面内存的使用。默认情况下，禁用此选项并且不使用大页面内存。</li></ul></li><li>启动org.apache.rocketmq.namesrv.NamesrvStartup类。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdowm语法</title>
      <link href="/posts/db8caa0.html"/>
      <url>/posts/db8caa0.html</url>
      
        <content type="html"><![CDATA[<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>markdown内超链接分为两种形式，分别是 <strong>行内式</strong> 和 <strong>参考式</strong></p><ol><li>行内式：<ul><li>格式：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[链接名称](链接地址)</span><br><span class="line">或：</span><br><span class="line">&lt;连接&gt;</span><br></pre></td></tr></tbody></table></figure></li><li>示例：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[这是一个连接](https://cmeng-cm.github.io/)</span><br></pre></td></tr></tbody></table></figure>效果：<a href="https://cmeng-cm.github.io/">这是一个连接</a></li></ul></li><li>参考式：参考式链接的写法相当于行内式拆分成两部分，并通过一个 识别符 来连接两部分。<ul><li>示例<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[这是一个连接][link]</span><br><span class="line">[link]: https://cmeng-cm.github.io/</span><br></pre></td></tr></tbody></table></figure>效果：<br><a href="https://cmeng-cm.github.io/">这是一个连接</a></li></ul></li></ol><hr><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><h3 id="1、markdown官方提供的分割线语法"><a href="#1、markdown官方提供的分割线语法" class="headerlink" title="1、markdown官方提供的分割线语法"></a>1、markdown官方提供的分割线语法</h3><p>三个星号（*）、三个中划线（-）、三个下划线（-）三者都能达到下面的效果：</p><hr><h3 id="2、特殊效果"><a href="#2、特殊效果" class="headerlink" title="2、特殊效果"></a>2、特殊效果</h3><p><strong>Markdown</strong> 只控制文档的结构，不控制文档的样式。但是既然依托于<strong>html</strong>语法，那我们就依然能通过HTML+CSS的方式定制分割线的样式。<br></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 简单示例 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 实线： --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">class</span>=<span class="string">"solid"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 虚线 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">class</span>=<span class="string">"dashed"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 点状 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">class</span>=<span class="string">"dotted"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 双线 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">class</span>=<span class="string">"double"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">class</span>=<span class="string">"double"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.solid</span> {</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-top</span>: <span class="number">5px</span> solid <span class="number">#FFDEAD</span>;</span></span><br><span class="line"><span class="language-css">}</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.dashed</span> {</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-top</span>: <span class="number">6px</span> dashed <span class="number">#00F5FF</span>;</span></span><br><span class="line"><span class="language-css">}</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.dotted</span> {</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-top</span>: <span class="number">7px</span> dotted <span class="number">#C0FF3E</span>;</span></span><br><span class="line"><span class="language-css">}</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.double</span> {</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-top</span>: <span class="number">8px</span> double <span class="number">#FF7F24</span>;</span></span><br><span class="line"><span class="language-css">}</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p></p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/markdown/dividing_line.jpg" alt="效果图"></p><style>.dashed {    border-top: 3px dashed #D3D3D3;}</style>]]></content>
      
      
      <categories>
          
          <category> Markdowm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdowm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主题标题相关设置</title>
      <link href="/posts/a5202087.html"/>
      <url>/posts/a5202087.html</url>
      
        <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th style="text-align:center">配置选项</th><th style="text-align:center">默认值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">title</td><td style="text-align:center">Markdown的文件标题</td><td style="text-align:center">文章标题，强烈建议填写此选项</td></tr><tr><td style="text-align:center">date</td><td style="text-align:center">文件创建时的日期时间</td><td style="text-align:center">发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td style="text-align:center">author</td><td style="text-align:center">根 _config.yml 中的 author</td><td style="text-align:center">文章作者</td></tr><tr><td style="text-align:center">img</td><td style="text-align:center">featureImages中的某个值</td><td style="text-align:center">文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <a href="http://xxx.com/xxx.jpg">http://xxx.com/xxx.jpg</a></td></tr><tr><td style="text-align:center">top</td><td style="text-align:center">true</td><td style="text-align:center">推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章</td></tr><tr><td style="text-align:center">hide</td><td style="text-align:center">false</td><td style="text-align:center">隐藏文章，如果hide值为true，则文章不会在首页显示</td></tr><tr><td style="text-align:center">cover</td><td style="text-align:center">false</td><td style="text-align:center">v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td style="text-align:center">coverImg</td><td style="text-align:center">无</td><td style="text-align:center">v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td style="text-align:center">password</td><td style="text-align:center">无</td><td style="text-align:center">文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项</td></tr><tr><td style="text-align:center">toc</td><td style="text-align:center">true</td><td style="text-align:center">是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项</td></tr><tr><td style="text-align:center">mathjax</td><td style="text-align:center">false</td><td style="text-align:center">是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行</td></tr><tr><td style="text-align:center">summary</td><td style="text-align:center">无</td><td style="text-align:center">文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td style="text-align:center">categories</td><td style="text-align:center">无</td><td style="text-align:center">文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td style="text-align:center">tags</td><td style="text-align:center">无</td><td style="text-align:center">文章标签，一篇文章可以多个标签</td></tr><tr><td style="text-align:center">keywords</td><td style="text-align:center">文章标题</td><td style="text-align:center">文章关键字，SEO 时需要</td></tr><tr><td style="text-align:center">reprintPolicy</td><td style="text-align:center">cc_by</td><td style="text-align:center">文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>markdown思维导图demo</title>
      <link href="/posts/7065c334.html"/>
      <url>/posts/7065c334.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 启动 —— 源码解析</title>
      <link href="/posts/609270ec.html"/>
      <url>/posts/609270ec.html</url>
      
        <content type="html"><![CDATA[<font size="7">SpringBoot 启动 —— 源码解析</font><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>本文从main方法的SpringApplication.run(SpringbootTestLockApplication.class, args)开始追踪源码的实现，通过分析源码的调用情况分析整个springboot启动过程的原理和相关的设计理念。<br><strong>SPringboot版本：2.4.4</strong></p><h2 id="二、创建SpringApplication实例"><a href="#二、创建SpringApplication实例" class="headerlink" title="二、创建SpringApplication实例"></a>二、创建SpringApplication实例</h2><h3 id="2-1、启动类"><a href="#2-1、启动类" class="headerlink" title="2.1、启动类"></a>2.1、启动类</h3><p>程序入口是启动类的main方法。通过运行SpringApplication.run()来实际启动服务。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">启动类main：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(SpringbootTestLockApplication.class, args);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h3 id="2-2、SpringApplication实例"><a href="#2-2、SpringApplication实例" class="headerlink" title="2.2、SpringApplication实例"></a>2.2、SpringApplication实例</h3><h4 id="2-2-1、启动步骤"><a href="#2-2-1、启动步骤" class="headerlink" title="2.2.1、启动步骤"></a>2.2.1、启动步骤</h4><p>通过源码可以看到，启动分为两步：1、实例化SpringApplication，2、再执行实例的run()方法.<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//run方法两层调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> {</span><br><span class="line">  <span class="keyword">return</span> run(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] { primarySource }, args);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(primarySources).run(args);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="2-2-2、SpringApplication构造函数"><a href="#2-2-2、SpringApplication构造函数" class="headerlink" title="2.2.2、SpringApplication构造函数"></a>2.2.2、SpringApplication构造函数</h4><p>SpringApplication的构造方法主要是为了初始化SpringApplication的一些基础属性，例如主启动类、web应用类型、启动载入器、初始化器列表、监听器列表等。<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数两层调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(Class&lt;?&gt;... primarySources)</span> {</span><br><span class="line">  <span class="built_in">this</span>(<span class="literal">null</span>, primarySources);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings({ "unchecked", "rawtypes" })</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> {</span><br><span class="line"></span><br><span class="line">  <span class="comment">//根据调用逻辑可知resourceLoader为Null。</span></span><br><span class="line">  <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">  Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>);</span><br><span class="line">  <span class="comment">//将Class数组参数赋值到SpringApplication.primarySources属性</span></span><br><span class="line">  <span class="built_in">this</span>.primarySources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取固定应用类型：WebApplicationType.SERVLET（The application should run as a servlet-based web application and should start an embedded servlet web server.）  </span></span><br><span class="line">  <span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取spring.factories中Bootstrapper对应的实例</span></span><br><span class="line">  <span class="built_in">this</span>.bootstrappers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(getSpringFactoriesInstances(Bootstrapper.class));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置 spring.factories中ApplicationContextInitializer对应的实例</span></span><br><span class="line">  setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置 spring.factories中ApplicationListener对应的实例</span></span><br><span class="line">  setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">  <span class="comment">//获取当前启动类class</span></span><br><span class="line">  <span class="built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h5 id="1、getSpringFactoriesInstances"><a href="#1、getSpringFactoriesInstances" class="headerlink" title="1、getSpringFactoriesInstances"></a>1、getSpringFactoriesInstances</h5><p>获取所以META-INF/spring.factories下的接口及其实现类的对应关系。即在初始化启动载入器、初始化器、监听器时，均是调用getSpringFactoriesInstances方法，通过传入不同的Class类型获取到不同的实例。<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type)</span> {</span><br><span class="line"><span class="keyword">return</span> getSpringFactoriesInstances(type, <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] {});</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> {</span><br><span class="line">    <span class="comment">//获取ClassLoader——sun.misc.Launcher$AppClassLoader</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> getClassLoader();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取指定type的接口实现类列表</span></span><br><span class="line">    Set&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化type对应的接口实现类</span></span><br><span class="line">    List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line"><span class="keyword">return</span> instances;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>getClassLoader：获取SpringApplication.resourceLoader，当resourceLoader为Null时获取当前线程的ClassLoader。由构造函数可知，此处获取的是当前线程的ClassLoader。</li></ul><h5 id="2、loadFactoryNames"><a href="#2、loadFactoryNames" class="headerlink" title="2、loadFactoryNames()"></a>2、loadFactoryNames()</h5><p>通过解析getSpringFactoriesInstances可以看到，通过SpringFactoriesLoader.loadFactoryNames()方法获取指定名称的所有类名称列表。即通过扫描资源文件META-INF/spring.factories来获取相关的键值对匹配关系并进行代码化解析。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FACTORIES_RESOURCE_LOCATION</span> <span class="operator">=</span> <span class="string">"META-INF/spring.factories"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> {</span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoaderToUse</span> <span class="operator">=</span> classLoader;</span><br><span class="line"><span class="keyword">if</span> (classLoaderToUse == <span class="literal">null</span>) {</span><br><span class="line">classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();</span><br><span class="line">}</span><br><span class="line"><span class="type">String</span> <span class="variable">factoryTypeName</span> <span class="operator">=</span> factoryType.getName();</span><br><span class="line"><span class="keyword">return</span> loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">loadSpringFactories</span><span class="params">(ClassLoader classLoader)</span> {</span><br><span class="line">  <span class="comment">//如果缓存存在，则获取缓存中的数据</span></span><br><span class="line">  Map&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="literal">null</span>) {</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">//缓存不存在，则通过解析 FACTORIES_RESOURCE_LOCATION 资源文件，解析里面不同接口类型及对应的类名称。并将数据存储入缓存中。</span></span><br><span class="line">Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) {</span><br><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line"><span class="type">UrlResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url);</span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) {</span><br><span class="line"><span class="type">String</span> <span class="variable">factoryTypeName</span> <span class="operator">=</span> ((String) entry.getKey()).trim();</span><br><span class="line">String[] factoryImplementationNames =</span><br><span class="line">StringUtils.commaDelimitedListToStringArray((String) entry.getValue());</span><br><span class="line"><span class="keyword">for</span> (String factoryImplementationName : factoryImplementationNames) {</span><br><span class="line">result.computeIfAbsent(factoryTypeName, key -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())</span><br><span class="line">.add(factoryImplementationName.trim());</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace all lists with unmodifiable lists containing unique elements</span></span><br><span class="line">result.replaceAll((factoryType, implementations) -&gt; implementations.stream().distinct()</span><br><span class="line">.collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) {</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Unable to load factories from location ["</span> +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + <span class="string">"]"</span>, ex);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="3、setListeners"><a href="#3、setListeners" class="headerlink" title="3、setListeners()"></a>3、setListeners()</h5><p>初始化所有监听器，并将监听器数组赋值到SpringApplication.listeners属性中，纯净的springboot初始化的监听器分别如下：<br>org.springframework.boot.ClearCachesApplicationListener<br>org.springframework.boot.builder.ParentContextCloserApplicationListener<br>org.springframework.boot.context.FileEncodingApplicationListener<br>org.springframework.boot.context.config.AnsiOutputApplicationListener<br>org.springframework.boot.context.config.DelegatingApplicationListener<br>org.springframework.boot.context.logging.LoggingApplicationListener<br>org.springframework.boot.env.EnvironmentPostProcessorApplicationListener<br>org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener<br>org.springframework.boot.autoconfigure.BackgroundPreinitializer</p><p>自此SpringApplication初始化完成。主要是初始化了一些基础属性和定义了服务类型。</p><h2 id="三、运行SpringApplication-run-方法"><a href="#三、运行SpringApplication-run-方法" class="headerlink" title="三、运行SpringApplication.run()方法"></a>三、运行SpringApplication.run()方法</h2><p>创建成功后调用该实例的run方法：运行spring应用程序，创建并刷新一个APplicationContext对象。<br>ApplicationContext：中央接口，为应用程序提供配置。在应用程序运行时这是只读的，但如果实现支持，则可以重新加载。  </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run the Spring application, creating and refreshing a new</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> ApplicationContext}.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the application arguments (usually passed from a Java main method)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a running {<span class="doctag">@link</span> ApplicationContext}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> {</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建秒表</span></span><br><span class="line">  <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">  <span class="comment">//秒表启动</span></span><br><span class="line">  stopWatch.start();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建启动上下文</span></span><br><span class="line">  <span class="type">DefaultBootstrapContext</span> <span class="variable">bootstrapContext</span> <span class="operator">=</span> createBootstrapContext();</span><br><span class="line"><span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置系统参数：java.awt.headless（在系统可能缺少显示设备、键盘或鼠标这些外设的情况下可以使用该模式，例如Linux服务器）</span></span><br><span class="line">  configureHeadlessProperty();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化监听器列表</span></span><br><span class="line">  <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> getRunListeners(args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//启动监听器</span></span><br><span class="line">  listeners.starting(bootstrapContext, <span class="built_in">this</span>.mainApplicationClass);</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">//创建程序参数对象，args：命令行执行时，命令行参数对象。</span></span><br><span class="line">    <span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备环境</span></span><br><span class="line">    <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置忽略的bean信息</span></span><br><span class="line">    configureIgnoreBeanInfo(environment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印banner，即启动时控制台的图案</span></span><br><span class="line">    <span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> printBanner(environment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据webApplicationType来创建容器/spring上下文对象  下面统一称呼为容器</span></span><br><span class="line">    context = createApplicationContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置应用程序启动指标对象，使应用程序上下文在启动期间能够记录一些指标</span></span><br><span class="line">context.setApplicationStartup(<span class="built_in">this</span>.applicationStartup);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备容器，容器的前置处理</span></span><br><span class="line">prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//刷新容器</span></span><br><span class="line">    refreshContext(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//刷新容器的后续处理</span></span><br><span class="line">    afterRefresh(context, applicationArguments);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//秒表停止</span></span><br><span class="line">    stopWatch.stop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出记录，记录启动类class信息，时间信息</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) {</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布监听应用上下文启动完成（发出启动结束事件）</span></span><br><span class="line">    listeners.started(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//运行runner</span></span><br><span class="line">    callRunners(context, applicationArguments);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">    handleRunFailure(context, ex, listeners);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">//监听容器运行中</span></span><br><span class="line">    listeners.running(context);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">    handleRunFailure(context, ex, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下面就是对整个run方法进行逐行理解分析。</p><h3 id="3-1、秒表"><a href="#3-1、秒表" class="headerlink" title="3.1、秒表"></a>3.1、秒表</h3><p>创建一个秒表并在正式运行逻辑之前启动。纳秒级精确度。<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">stopWatch.start();</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="3-2、创建启动上下文——Bootstrap"><a href="#3-2、创建启动上下文——Bootstrap" class="headerlink" title="3.2、创建启动上下文——Bootstrap"></a>3.2、创建启动上下文——Bootstrap</h3><p>Spring Cloud官方文档有一部分相关Bootstrap的描述：<br><a href="https://cloud.spring.io/spring-cloud-commons/multi/multi__spring_cloud_context_application_context_services.html">Spring Cloud 官方文档</a>    </p><p>大致译文为：<br>Spring Cloud应用程序通过创建<strong>bootstrap</strong>上下文进行操作，该上下文是主应用程序的父上下文。它负责从外部源加载配置属性，并负责解密本地外部配置文件中的属性。这两个上下文共享一个<strong>Environment</strong>，这是任何Spring应用程序的外部属性的来源。默认情况下，引导程序属性（不是bootstrap.properties引导程序阶段加载的属性）具有较高的优先级，因此它们不能被本地配置覆盖。  </p><p>如果从SpringApplication或构建应用程序上下文SpringApplicationBuilder，那么Bootstrap上下文将作为父级添加到该上下文。  </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> DefaultBootstrapContext <span class="title function_">createBootstrapContext</span><span class="params">()</span> {</span><br><span class="line"><span class="type">DefaultBootstrapContext</span> <span class="variable">bootstrapContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultBootstrapContext</span>();</span><br><span class="line"><span class="built_in">this</span>.bootstrappers.forEach((initializer) -&gt; initializer.intitialize(bootstrapContext));</span><br><span class="line"><span class="keyword">return</span> bootstrapContext;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>进入源码，可知创建启动上下文时，会进行初始化，主要对bootstrapContext内的实例进行注册。注册成功后返回bootstrapContext对象。<br><strong>注</strong>：通过loadFactoryNames()方法可知当不应用Cloud体系时，bootstrapContext为空list。  </p><h3 id="3-3、获取SpringApplicationRunListeners实例——getRunListeners"><a href="#3-3、获取SpringApplicationRunListeners实例——getRunListeners" class="headerlink" title="3.3、获取SpringApplicationRunListeners实例——getRunListeners()"></a>3.3、获取SpringApplicationRunListeners实例——getRunListeners()</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SpringApplicationRunListeners <span class="title function_">getRunListeners</span><span class="params">(String[] args)</span> {</span><br><span class="line">  Class&lt;?&gt;[] types = <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] { SpringApplication.class, String[].class };</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringApplicationRunListeners</span>(logger,</span><br><span class="line">      getSpringFactoriesInstances(SpringApplicationRunListener.class, types, <span class="built_in">this</span>, args),</span><br><span class="line">      <span class="built_in">this</span>.applicationStartup);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li><p>这段代码就比较熟悉了，还是getSpringFactoriesInstances()这个方法获取所有SpringApplicationRunListener接口的实现类的实例化对象。并初始SpringApplicationRunListeners对象。  </p></li><li><p>SpringApplicationRunListener：spring所有事件的触发都是通过该接口的唯一实现类EventPublishingRunListener来实现的，EventPublishingRunListener也是该接口的官方唯一实现类。<br>EventPublishingRunListener构造函数：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">EventPublishingRunListener</span><span class="params">(SpringApplication application, String[] args)</span> {</span><br><span class="line"><span class="built_in">this</span>.application = application;</span><br><span class="line"><span class="built_in">this</span>.args = args;</span><br><span class="line"><span class="built_in">this</span>.initialMulticaster = <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>();</span><br><span class="line"><span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : application.getListeners()) {</span><br><span class="line"><span class="built_in">this</span>.initialMulticaster.addApplicationListener(listener);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>EventPublishingRunListener的属性共有三个：</p><ul><li>application：当前运行的SpringApplication实例</li><li>args：启动命令行参数</li><li>initialMulticaster：事件广播器<br>根据构造函数可知，会将application关联的所有ApplicationListener实例关联到initialMulticaster中，以方便initialMulticaster将事件传递给所有的监听器。</li></ul></li><li><p>事件触发过程：</p><ul><li>当对应的时间处理方法被调用时，EventPublishingRunListener会将application和args封装到对应的SpringApplicationEvent子类实例中；</li><li>initialMulticaster会根据事件类型和触发源对事件进行分类，并与对应的ApplicationListener建立关联关系，之后将事件传递给对应的ApplicationListener；</li><li>ApplicationListener实例收到事件后，会根据时间类型不同，执行不同的处理逻辑。</li></ul></li></ol><p>至此可知，getRunListeners()方法是为了获取一个装有EventPublishingRunListener对象实例的数组对象-SpringApplicationRunListeners。用于后续事件触发通知功能。</p><h3 id="3-4、启动监听器——listeners-starting"><a href="#3-4、启动监听器——listeners-starting" class="headerlink" title="3.4、启动监听器——listeners.starting()"></a>3.4、启动监听器——listeners.starting()</h3><p>初始化所有监听器后，进行启动。启动时传入启动上下文和启动类的class对象<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">starting</span><span class="params">(ConfigurableBootstrapContext bootstrapContext, Class&lt;?&gt; mainApplicationClass)</span> {</span><br><span class="line">doWithListeners(<span class="string">"spring.boot.application.starting"</span>, (listener) -&gt; listener.starting(bootstrapContext),</span><br><span class="line">(step) -&gt; {</span><br><span class="line"><span class="keyword">if</span> (mainApplicationClass != <span class="literal">null</span>) {</span><br><span class="line">step.tag(<span class="string">"mainApplicationClass"</span>, mainApplicationClass.getName());</span><br><span class="line">}</span><br><span class="line">});</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>启动监听器主要是starting()方案，此处调用则使用SpringApplicationRunListener接口的实现类EventPublishingRunListener对应的starting()方法进行监听器启动。<br>此处实现类的创建的可参看 spring-boot 包的 spring.factories 文件：<a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot/src/main/resources/META-INF/spring.factories">官方spring.factories</a>  </p><p>EventPublishingRunListener具体实现启动的代码逻辑<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">starting</span><span class="params">(ConfigurableBootstrapContext bootstrapContext)</span> {</span><br><span class="line"><span class="built_in">this</span>.initialMulticaster</span><br><span class="line">.multicastEvent(<span class="keyword">new</span> <span class="title class_">ApplicationStartingEvent</span>(bootstrapContext, <span class="built_in">this</span>.application, <span class="built_in">this</span>.args));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> {</span><br><span class="line">  <span class="type">ResolvableType</span> <span class="variable">type</span> <span class="operator">=</span> (eventType != <span class="literal">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">  <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getTaskExecutor();</span><br><span class="line">  <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) {</span><br><span class="line">    <span class="keyword">if</span> (executor != <span class="literal">null</span>) {</span><br><span class="line">      executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">      invokeListener(listener, event);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeListener</span><span class="params">(ApplicationListener&lt;?&gt; listener, ApplicationEvent event)</span> {</span><br><span class="line">  <span class="type">ErrorHandler</span> <span class="variable">errorHandler</span> <span class="operator">=</span> getErrorHandler();</span><br><span class="line">  <span class="keyword">if</span> (errorHandler != <span class="literal">null</span>) {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      doInvokeListener(listener, event);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) {</span><br><span class="line">      errorHandler.handleError(err);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> {</span><br><span class="line">    doInvokeListener(listener, event);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doInvokeListener</span><span class="params">(ApplicationListener listener, ApplicationEvent event)</span> {</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    listener.onApplicationEvent(event);</span><br><span class="line">  }</span><br><span class="line">  ......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>starting()启动的时候实际上是又创建了一个ApplicationStartingEvent对象，其实就是监听应用启动事件。其中 initialMulticaster是一个SimpleApplicationEventMuticaster对象的实例化。<br>具体：<p></p><ul><li>获取initialMulticaster的线程池，但该实例初始化时并未创建线程池对象，所以此处为null</li><li>通过getApplicationListeners方法获取匹配事件的监听器。</li><li>对符合要求的监听器执行invokeListener方法.</li><li>对符合条件的监听器执行onApplicationEvent方法进行相关初始化操作。</li></ul><p>此处纯净的springboot项目共有四个监听器。</p><ul><li>LoggingApplicationListener初始化了loggingSystem</li><li>BackgroundPreinitializer：未执行任何操作</li><li>DelegatingApplicationListener：未执行任何操作</li><li>LiquibaseServiceLocatorApplicationListener：未执行任何操作.</li></ul><h3 id="3-5、环境准备-prepareEnvironment"><a href="#3-5、环境准备-prepareEnvironment" class="headerlink" title="3.5、环境准备-prepareEnvironment()"></a>3.5、环境准备-prepareEnvironment()</h3><p>设置好监听器后进行环境准备。主要是初始化应用参数和启动环境准备，源码对应如下：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建程序参数对象，args：命令行执行时，命令行参数对象。</span></span><br><span class="line"><span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line"></span><br><span class="line"><span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置忽略的bean信息</span></span><br><span class="line">configureIgnoreBeanInfo(environment);</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="3-5-1、初始化应用参数"><a href="#3-5-1、初始化应用参数" class="headerlink" title="3.5.1、初始化应用参数"></a>3.5.1、初始化应用参数</h4><p>对启动时的参数进行解析，例如：java -jar —spring.profiles.active=test等。最终将解析的键值对存储到CommandLineArgs对象中。</p><h4 id="3-5-2、准备环境"><a href="#3-5-2、准备环境" class="headerlink" title="3.5.2、准备环境"></a>3.5.2、准备环境</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ConfigurableEnvironment <span class="title function_">prepareEnvironment</span><span class="params">(SpringApplicationRunListeners listeners,</span></span><br><span class="line"><span class="params">DefaultBootstrapContext bootstrapContext, ApplicationArguments applicationArguments)</span> {</span><br><span class="line"><span class="comment">// 获取或创建一个environment实例</span></span><br><span class="line"><span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> getOrCreateEnvironment();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//配置环境：转换器、命令行参数等</span></span><br><span class="line">configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line"></span><br><span class="line">   <span class="comment">//固定ConfigurationPropertySourcesPropertySource到environment</span></span><br><span class="line">ConfigurationPropertySources.attach(environment);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//启动监听器</span></span><br><span class="line">listeners.environmentPrepared(bootstrapContext, environment);</span><br><span class="line">   <span class="comment">//判断是否存在defaultProperties的属性源，存在则移动最后一位</span></span><br><span class="line">DefaultPropertiesPropertySource.moveToEnd(environment);</span><br><span class="line">   </span><br><span class="line">configureAdditionalProfiles(environment);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//将环境绑定到SpringApplication类上</span></span><br><span class="line">bindToSpringApplication(environment);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//判断是否存在定制的环境</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.isCustomEnvironment) {</span><br><span class="line">environment = <span class="keyword">new</span> <span class="title class_">EnvironmentConverter</span>(getClassLoader()).convertEnvironmentIfNecessary(environment,</span><br><span class="line">deduceEnvironmentClass());</span><br><span class="line">}</span><br><span class="line">ConfigurationPropertySources.attach(environment);</span><br><span class="line"><span class="keyword">return</span> environment;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="1、getOrCreateEnvironment"><a href="#1、getOrCreateEnvironment" class="headerlink" title="1、getOrCreateEnvironment()"></a>1、getOrCreateEnvironment()</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ConfigurableEnvironment <span class="title function_">getOrCreateEnvironment</span><span class="params">()</span> {</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.environment != <span class="literal">null</span>) {</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.environment;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">switch</span> (<span class="built_in">this</span>.webApplicationType) {</span><br><span class="line"><span class="keyword">case</span> SERVLET:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StandardServletEnvironment</span>();</span><br><span class="line"><span class="keyword">case</span> REACTIVE:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StandardReactiveWebEnvironment</span>();</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果不存在environment则根据webApplicationType类型进行初始环境实例创建，通过上面的源码解析可知，此处类型为SERVLET，所以会创建StandardServletEnvironment实例。<br>StandardReactiveWebEnvironment构造：</p><ul><li>调用了父类AbstractEnvironment的构造函数，进行相关属性的初始化。<ol><li>propertySources属性初始化MutablePropertySources实例。</li><li>propertyResolver属性初始化PropertySourcesPropertyResolver实例，它的父类AbstractPropertyResolver中定义了”${}”占位符，用于后续解析配置文件时使用。</li></ol></li><li>通过customizePropertySources()方法对propertySources增加了以下四个元素：servletConfigInitParams、servletContextInitParams、systemProperties、systemEnvironment。</li></ul><h5 id="2、configureEnvironment-environment-applicationArguments-getSourceArgs"><a href="#2、configureEnvironment-environment-applicationArguments-getSourceArgs" class="headerlink" title="2、configureEnvironment(environment, applicationArguments.getSourceArgs());"></a>2、configureEnvironment(environment, applicationArguments.getSourceArgs());</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configureEnvironment</span><span class="params">(ConfigurableEnvironment environment, String[] args)</span> {</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.addConversionService) {</span><br><span class="line">    <span class="type">ConversionService</span> <span class="variable">conversionService</span> <span class="operator">=</span> ApplicationConversionService.getSharedInstance();</span><br><span class="line">    environment.setConversionService((ConfigurableConversionService) conversionService);</span><br><span class="line">  }</span><br><span class="line">  configurePropertySources(environment, args);</span><br><span class="line">  configureProfiles(environment, args);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>环境配置分三步，配置转换器、配置属性资源(命令行参数)、配置文件(命令行参数)。</p><ul><li>配置转换器：<ol><li>addConversionService属性初始值为true，通过静态方法getSharedInstance()获取一个单例的转换器。构造函数包含一些默认的Formatter和GenericConverter。</li><li>获取后配置到environment的propertyResolver属性中。</li></ol></li><li>配置属性资源文件:configurePropertySources()<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">addCommandLineProperties</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">COMMAND_LINE_PROPERTY_SOURCE_NAME</span> <span class="operator">=</span> <span class="string">"commandLineArgs"</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configurePropertySources</span><span class="params">(ConfigurableEnvironment environment, String[] args)</span> {</span><br><span class="line"><span class="type">MutablePropertySources</span> <span class="variable">sources</span> <span class="operator">=</span> environment.getPropertySources();</span><br><span class="line"><span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="built_in">this</span>.defaultProperties)) {</span><br><span class="line">DefaultPropertiesPropertySource.addOrMerge(<span class="built_in">this</span>.defaultProperties, sources);</span><br><span class="line">}</span><br><span class="line">   <span class="comment">//若条件成立则将命令行参数设置进环境属性资源</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.addCommandLineProperties &amp;&amp; args.length &gt; <span class="number">0</span>) {</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME;</span><br><span class="line"><span class="keyword">if</span> (sources.contains(name)) {</span><br><span class="line">PropertySource&lt;?&gt; source = sources.get(name);</span><br><span class="line"><span class="type">CompositePropertySource</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompositePropertySource</span>(name);</span><br><span class="line">composite.addPropertySource(</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">SimpleCommandLinePropertySource</span>(<span class="string">"springApplicationCommandLineArgs"</span>, args));</span><br><span class="line">composite.addPropertySource(source);</span><br><span class="line">sources.replace(name, composite);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">sources.addFirst(<span class="keyword">new</span> <span class="title class_">SimpleCommandLinePropertySource</span>(args));</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>初始化defaultProperties属性为null，args则根据是否在命令输入进行相关处理。</li><li>配置文件(命令行参数):configureProfiles()<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configureProfiles</span><span class="params">(ConfigurableEnvironment environment, String[] args)</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>未具体实现，应该是用于后续扩展使用。</li></ul><h5 id="3、ConfigurationPropertySources-attach-environment"><a href="#3、ConfigurationPropertySources-attach-environment" class="headerlink" title="3、ConfigurationPropertySources.attach(environment)"></a>3、ConfigurationPropertySources.attach(environment)</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ATTACHED_PROPERTY_SOURCE_NAME</span> <span class="operator">=</span> <span class="string">"configurationProperties"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Environment environment)</span> {</span><br><span class="line">  Assert.isInstanceOf(ConfigurableEnvironment.class, environment);</span><br><span class="line">  <span class="type">MutablePropertySources</span> <span class="variable">sources</span> <span class="operator">=</span> ((ConfigurableEnvironment) environment).getPropertySources();</span><br><span class="line">  PropertySource&lt;?&gt; attached = sources.get(ATTACHED_PROPERTY_SOURCE_NAME);</span><br><span class="line">  <span class="keyword">if</span> (attached != <span class="literal">null</span> &amp;&amp; attached.getSource() != sources) {</span><br><span class="line">    sources.remove(ATTACHED_PROPERTY_SOURCE_NAME);</span><br><span class="line">    attached = <span class="literal">null</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (attached == <span class="literal">null</span>) {</span><br><span class="line">    sources.addFirst(<span class="keyword">new</span> <span class="title class_">ConfigurationPropertySourcesPropertySource</span>(ATTACHED_PROPERTY_SOURCE_NAME,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SpringConfigurationPropertySources</span>(sources)));</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>该步骤的目的是将ConfigurationPropertySource支持固定到environment中，以便于PropertySourcesPropertyResolver使用配置属性名称进行解析。</p><h5 id="4、listeners-environmentPrepared-bootstrapContext-environment"><a href="#4、listeners-environmentPrepared-bootstrapContext-environment" class="headerlink" title="4、listeners.environmentPrepared(bootstrapContext, environment)"></a>4、listeners.environmentPrepared(bootstrapContext, environment)</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">environmentPrepared</span><span class="params">(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment)</span> {</span><br><span class="line">doWithListeners(<span class="string">"spring.boot.application.environment-prepared"</span>,</span><br><span class="line">(listener) -&gt; listener.environmentPrepared(bootstrapContext, environment));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>向监听器发送环境准备事件。此处的代码就比较熟悉了，和启动监听事件[starting()]方法逻辑基本一致。此处主要用来解析配置文件的监听器为：EnvironmentPostProcessorApplicationListener。<br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/springboot/springboot-yml读取过程.png" alt="springboot配置读取调用层次关系">  </p><h5 id="5、DefaultPropertiesPropertySource-moveToEnd-environment"><a href="#5、DefaultPropertiesPropertySource-moveToEnd-environment" class="headerlink" title="5、DefaultPropertiesPropertySource.moveToEnd(environment)"></a>5、DefaultPropertiesPropertySource.moveToEnd(environment)</h5><p>判断是否存在defaultProperties的属性源，存在则移动最后一位</p><h5 id="6、configureAdditionalProfiles-environment"><a href="#6、configureAdditionalProfiles-environment" class="headerlink" title="6、configureAdditionalProfiles(environment);"></a>6、configureAdditionalProfiles(environment);</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">configureAdditionalProfiles</span><span class="params">(ConfigurableEnvironment environment)</span> {</span><br><span class="line"><span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="built_in">this</span>.additionalProfiles)) {</span><br><span class="line">Set&lt;String&gt; profiles = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(Arrays.asList(environment.getActiveProfiles()));</span><br><span class="line"><span class="keyword">if</span> (!profiles.containsAll(<span class="built_in">this</span>.additionalProfiles)) {</span><br><span class="line">profiles.addAll(<span class="built_in">this</span>.additionalProfiles);</span><br><span class="line">environment.setActiveProfiles(StringUtils.toStringArray(profiles));</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此处获取additionalProfiles属性是通过SpringApplicationBuilder实例设置的，一般不是使用SpringApplicationBuilder对象的应用此处没有额外的配置进入。</p><h5 id="7、bindToSpringApplication-environment"><a href="#7、bindToSpringApplication-environment" class="headerlink" title="7、bindToSpringApplication(environment)"></a>7、bindToSpringApplication(environment)</h5><p>将环境绑定到SpringApplication类上</p><h5 id="8、if-this-isCustomEnvironment"><a href="#8、if-this-isCustomEnvironment" class="headerlink" title="8、if (!this.isCustomEnvironment)"></a>8、if (!this.isCustomEnvironment)</h5><p>判断是否存在定制的环境，一般springboot方式启动的服务该<strong>isCustomEnvironment</strong>均为false，只有当通过SpringApplicationBuilder以war包的形式启动才会对该参数进行true赋值。</p><h5 id="9、ConfigurationPropertySources-attach-environment"><a href="#9、ConfigurationPropertySources-attach-environment" class="headerlink" title="9、ConfigurationPropertySources.attach(environment)"></a>9、ConfigurationPropertySources.attach(environment)</h5><p>通过lister的一系列操作后再次将ConfigurationPropertySource支持固定到environment中。</p><p>自此Springboot启动流程中环境准备、配置等操作已完成。</p><h4 id="3-6、准备容器，容器的前置处理——prepareContext-bootstrapContext-context-environment-listeners-applicationArguments-printedBanner"><a href="#3-6、准备容器，容器的前置处理——prepareContext-bootstrapContext-context-environment-listeners-applicationArguments-printedBanner" class="headerlink" title="3.6、准备容器，容器的前置处理——prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);"></a>3.6、准备容器，容器的前置处理——prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</h4><p>参数属性对应的实际class类型：</p><ul><li>contex:AnnotationConfigServletWebServerApplicationContext</li><li>listeners: SpringApplicationRunListeners</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prepareContext</span><span class="params">(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context,</span></span><br><span class="line"><span class="params">ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span></span><br><span class="line"><span class="params">ApplicationArguments applicationArguments, Banner printedBanner)</span> {</span><br><span class="line"></span><br><span class="line">   <span class="comment">//将给定的环境委托给底层的AnnotatedBeanDefinitionReader和ClassPathBeanDefinitionScanner。</span></span><br><span class="line">   context.setEnvironment(environment);</span><br><span class="line">postProcessApplicationContext(context);</span><br><span class="line">applyInitializers(context);</span><br><span class="line">listeners.contextPrepared(context);</span><br><span class="line">bootstrapContext.close(context);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) {</span><br><span class="line">logStartupInfo(context.getParent() == <span class="literal">null</span>);</span><br><span class="line">logStartupProfileInfo(context);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Add boot specific singleton beans</span></span><br><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getBeanFactory();</span><br><span class="line">beanFactory.registerSingleton(<span class="string">"springApplicationArguments"</span>, applicationArguments);</span><br><span class="line"><span class="keyword">if</span> (printedBanner != <span class="literal">null</span>) {</span><br><span class="line">beanFactory.registerSingleton(<span class="string">"springBootBanner"</span>, printedBanner);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) {</span><br><span class="line">((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">.setAllowBeanDefinitionOverriding(<span class="built_in">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.lazyInitialization) {</span><br><span class="line">context.addBeanFactoryPostProcessor(<span class="keyword">new</span> <span class="title class_">LazyInitializationBeanFactoryPostProcessor</span>());</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Load the sources</span></span><br><span class="line">Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">Assert.notEmpty(sources, <span class="string">"Sources must not be empty"</span>);</span><br><span class="line">load(context, sources.toArray(<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]));</span><br><span class="line">listeners.contextLoaded(context);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>未完待续！</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发模型比较</title>
      <link href="/posts/36a7b9af.html"/>
      <url>/posts/36a7b9af.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、进程、线程、协程"><a href="#一、进程、线程、协程" class="headerlink" title="一、进程、线程、协程"></a>一、进程、线程、协程</h2><h3 id="1-1、进程"><a href="#1-1、进程" class="headerlink" title="1.1、进程"></a>1.1、进程</h3><p><strong>进程：</strong> 是系统进行资源分配的一个独立单位，内核通过进程控制块（PCB，process control block）来感知进程。</p><blockquote><p>一个计算机系统进程包括（或者说“拥有”）下列资料：</p><blockquote><ul><li>那个程序的可执行机器代码的一个在存储器的映像。</li><li>分配到的存储器（通常是虚拟的一个存储器区域）。存储器的内容包括可执行代码、特定于进程的资料（输入、输出）、调用堆栈、堆栈（用于保存运行时运输中途产生的资料）。</li><li>分配给该进程的资源的操作系统描述符，诸如文件描述符（Unix术语）或文件句柄（Windows）、资料源和资料终端。</li><li>安全特性，诸如进程拥有者和进程的权限集（可以容许的操作）。</li><li>处理器状态（内文），诸如寄存器内容、物理存储器寻址等。当进程正在执行时，状态通常存储在寄存器，其他情况在存储器。</li></ul></blockquote></blockquote><h3 id="1-2、线程"><a href="#1-2、线程" class="headerlink" title="1.2、线程"></a>1.2、线程</h3><ol><li><p>是独立调度和分派的基本单位。内核通过<a href="https://en.wikipedia.org/wiki/Thread_control_block">线程控制块（TCB，thread control block）</a>来感知线程。  </p></li><li><p>同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。</p></li></ol><h3 id="1-3、线程的实现和调度方式"><a href="#1-3、线程的实现和调度方式" class="headerlink" title="1.3、线程的实现和调度方式"></a>1.3、线程的实现和调度方式</h3><h4 id="1-3-1、线程的实现"><a href="#1-3-1、线程的实现" class="headerlink" title="1.3.1、线程的实现"></a>1.3.1、线程的实现</h4><ol><li><p><strong>内核支持线程（KST，Kernel Supported Threads）</strong></p><ul><li>内核级线程的 TCB 保存在内核空间，其创建、阻塞、撤销、切换等活动也都是在内核空间实现的。</li><li>内核线程的调度是由内核完成的，一般是抢占式调度。     </li></ul></li><li><p>用户级线程(UST, User Supported Threads)</p><ul><li>用户级线程则是内核无关的，用户级线程的实现在用户空间，内核感知不到用户线程的存在。</li><li>用户线程的调度算法可以是进程专用的，不会被内核调度，但同时，用户线程也无法利用多处理机的并行执行。调度也发生在用户态，一般是由线程库或编程语言运行时自行实现的。</li><li>一个拥有多个用户线程的进程，一旦有一个线程阻塞，该进程所有的线程都会被阻塞。</li><li>内核的切换需要转换到内核空间，而用户线程不需要，所以前者开销会更大。</li><li>用户线程需要内核的支持，一般是通过运行时系统或内核控制线程来连接一个内核线程，有 1:1、1:n、n:m 的不同实现。</li></ul></li></ol><h4 id="1-3-2、调度方式"><a href="#1-3-2、调度方式" class="headerlink" title="1.3.2、调度方式"></a>1.3.2、调度方式</h4><p>在分时操作系统中，处理机的调度一般基于时间片的轮转（RR, round robin)，多个就绪线程排成队列，轮流执行时间片。所以进程调度主要有抢占式调度和协作式调度两种：<strong>抢占式(Preemptive)</strong> 与 <strong>协作式(Cooperative)</strong>。</p><ol><li><p><strong>抢占式(Preemptive)</strong><br>抢占式调度往往在一些重要位置（Sleep Call，Timer Tick）放置了中断信号，通过这个信号通知操作系统调度器(Scheduler)进行进程切换。在抢占式模型中，正在运行的进程可能会被强行挂起，这是由于这些中断信号引发的。</p></li><li><p><strong>协作式(Cooperative)</strong>。<br>协作式调度也叫非抢占式调度，是指当前运行的进程通过自身代码逻辑出让CPU控制权。与抢占式调度的区别在于进程运行不会被中断信号打断，除非其主动出让控制权给其他进程。  </p></li><li><p>结构示意图<br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/线程调度方式.png" alt="调度方式"></p></li></ol><h3 id="1-4、协程-Coroutines-Cooperative-User-Level-Threads"><a href="#1-4、协程-Coroutines-Cooperative-User-Level-Threads" class="headerlink" title="1.4、协程(Coroutines - Cooperative User-Level Threads)"></a>1.4、协程(Coroutines - Cooperative User-Level Threads)</h3><p><strong>协程：</strong> 又称微线程，纤程。英文名Coroutine。是应用程序通过线程库自行实现的 <strong>协作式调度</strong> 的运行在用户空间的用户线程，是编译器级别的。<strong>系统的并发是时间片的轮转</strong> ，单处理器交互执行不同的执行流，营造不同线程同时执行的感觉；而 <strong>协程的并发，是单线程内控制权的轮转</strong> 。相比抢占式调度，协程是主动让权，实现协作。</p><h2 id="二、并发模型"><a href="#二、并发模型" class="headerlink" title="二、并发模型"></a>二、并发模型</h2><h3 id="2-1、、模型：单进（线）程·循环处理请求"><a href="#2-1、、模型：单进（线）程·循环处理请求" class="headerlink" title="2.1、、模型：单进（线）程·循环处理请求"></a>2.1、、模型：单进（线）程·循环处理请求</h3><p>单进程和单线程其实没有区别，因为一个进程至少有一个线程。循环处理请求应该是最初级的做法。当大量请求进来时，单线程一个一个处理请求，请求很容易就积压起来，得不到响应。这是无并发的做法。</p><h3 id="2-2、模型：多进程（Multiprocessing）"><a href="#2-2、模型：多进程（Multiprocessing）" class="headerlink" title="2.2、模型：多进程（Multiprocessing）"></a>2.2、模型：多进程（Multiprocessing）</h3><p>主进程监听和管理连接，当有客户请求的时候，<strong>fork</strong> 一个子进程来处理连接，父进程继续等待其他客户的请求。</p><p><strong>优点</strong>：<strong>好处是隔离性</strong>，子进程万一 crash 并不会影响到父进程。<br><strong>缺点</strong>：<strong>缺点就是对系统的负担过重</strong>。  </p><p>典型的是 <strong>Apache Web Server</strong>，每个用户请求接入的时候都会创建一个进程，这样应用就可以同时支持多个用户。</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/Apache-Web-Server-Thread.jpeg" alt="Apache-Web-Server-Thread"></p><p>在图中M1、M2与M3都代表内存资源，在多进程中如果不同进程想共享内存中的数据必须通过 <strong>进程间通信</strong>的方式来实现。</p><h3 id="2-3、模型：多线程（Multithreaded）"><a href="#2-3、模型：多线程（Multithreaded）" class="headerlink" title="2.3、模型：多线程（Multithreaded）"></a>2.3、模型：多线程（Multithreaded）</h3><p>在操作系统的视角看，比如Linux中，在进程中创建线程是通过 <strong>clone()</strong> 系统调用来实现，这和创建子进程的区别不大。线程与进程的区别在于同一个进程内的线程共享着进程分配的资源，线程不被分配资源，只是操作系统调度执行任务的抽象的最小单元。</p><p>比如下图中，PID为10的进程P0通过clone()系统调用创建了3个线程，这些线程都可以访问进程分配的内存资源M0。<br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/多线程模型.jpeg" alt="多线程模型"></p><h4 id="2-3-1、多线程：通信方式——共享内存通信-Shared-memory-communication"><a href="#2-3-1、多线程：通信方式——共享内存通信-Shared-memory-communication" class="headerlink" title="2.3.1、多线程：通信方式——共享内存通信(Shared memory communication)"></a>2.3.1、多线程：通信方式——共享内存通信(Shared memory communication)</h4><p><strong>共享内存通信(Shared memory communication)</strong> ：不同线程间可以访问同一内存地址空间，并可修改此地址空间的数据。</p><h5 id="同步-Synchronize-访问"><a href="#同步-Synchronize-访问" class="headerlink" title="同步(Synchronize)访问"></a>同步(Synchronize)访问</h5><p>因为线程间共享内存资源，所以在访问临界区域时会出现数据竞争。解决竞态条件的方式是对数据进行 <strong>同步(Synchronize)访问</strong> 。要实现同步访问常见的方式有：</p><pre><code>* **锁(Lock)** ：通过锁定临界区域来实现同步访问。* **信号量(Semaphores)** ：可以通过信号量的增减控制对一个或多个线程对临界区域的访问。* **同步屏障(Barriers)** ：通过设置屏障控制不同线程执行周期实现同步访问。  </code></pre><p><strong>此模型的优点：</strong>  </p><ul><li>大多编程语言都支持此模型；</li><li>贴近硬件架构，使用得当性能很高；</li><li>是其他并发模型的基础；</li></ul><p><strong>此模型的缺点：</strong></p><ul><li>不支持分布式内存模型，只解决了进程内的并发同步；</li><li>不好调试与测试，想用好不容易；    </li></ul><h5 id="STM-Software-transactional-memory"><a href="#STM-Software-transactional-memory" class="headerlink" title="STM(Software transactional memory)"></a>STM(Software transactional memory)</h5><p>STM是用软件的方式去实现事务内存(Transactional memory)，而事务内存中的事务(Transactional)正是关系型数据库中的概念，一个事务必须满足ACID性质，在STM的事务中尽可能避免副作用，比如在事务中去修改原子变量这种操作，可能会导致事务回滚失败。</p><p><strong>此模型的优点：</strong></p><ul><li>相比锁模型更简单；</li><li>大部分情况下更高效；</li></ul><p><strong>此模型的缺点：</strong></p><ul><li>在事务内需要避免产生副作用；</li><li>不支持分布式内存模型，只解决了进程内的并发同步；</li></ul><h4 id="2-3-2、多线程：通信方式——消息传递通信-Message-passing-communication"><a href="#2-3-2、多线程：通信方式——消息传递通信-Message-passing-communication" class="headerlink" title="2.3.2、多线程：通信方式——消息传递通信(Message passing communication)"></a>2.3.2、多线程：通信方式——消息传递通信(Message passing communication)</h4><p><strong>消息传递通信(Message passing communication)</strong> ：不同线程间只能通过收发消息的形式去通信，数据只能被拥有它的线程修改。</p><h5 id="通信顺序进程-CSP-Communicating-sequential-processes"><a href="#通信顺序进程-CSP-Communicating-sequential-processes" class="headerlink" title="通信顺序进程(CSP(Communicating sequential processes))"></a>通信顺序进程(CSP(Communicating sequential processes))</h5><p><strong>CSP</strong>：是一种形式语言，用来描述基于消息传递通信的安全并发模型。各任务模块之间的通信是基于 <strong>通道(Channel)</strong> 来完成的。<strong>通道可以被不同的任务块共享</strong> 。通道两端任务块的通信可以是<strong>同步的，也可以是异步的</strong>。</p><p><strong>此模型的优点：</strong></p><ul><li>相比锁模型更简单；</li><li>很容易实现高并发；</li></ul><p><strong>此模型的缺点：</strong></p><ul><li>不支持分布式内存模型，只解决了进程内的并发同步；</li></ul><h5 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h5><p><strong>演员模型(Actor)</strong> 是一种类似面向对象编程思想的安全并发模型。Actor模型=数据+行为+消息。Actor模型内部的状态由自己的行为维护，外部线程不能直接调用对象的行为，必须通过消息才能激发行为，这样就保证Actor内部数据只有被自己修改。</p><p>相比CSP模型，Actor模型可以跨节点在 <strong>分布式集群中运行</strong>。实际上Actor模型的代表Erlang正是天然分布式容错的编程语言。</p><p>二者的区别：Actor之间直接通讯，而CSP是通过Channel通讯，在耦合度上两者是有区别的，后者更加松耦合。</p><p><strong>此模型的优点：</strong></p><ul><li>相比锁模型更简单；</li><li>很容易实现高并发；</li><li>支持分布式内存模型，能实现跨节点的并发同步；</li></ul><p><strong>此模型的缺点：</strong></p><ul><li>存在信箱满后消息丢失的问题;</li></ul><h3 id="2-4、事件驱动模型"><a href="#2-4、事件驱动模型" class="headerlink" title="2.4、事件驱动模型"></a>2.4、事件驱动模型</h3><p><strong>事件驱动编程</strong> 是一种编程范式，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理。<br><strong>Event Loop with Multiplexing</strong>：此模型巧妙的利用了系统内核提供的I/O多路复用系统调用，将多个socket连接转换成一个事件队列(event queue)，只需要单个线程即可循环处理这个事件队列。当然这个线程是有可能被阻塞或长期占用的，针对这种类型的任务处理可以单独使用一个线程池去做，这样就不会阻塞Event Loop的线程了。</p><p><strong>此模型的优点：</strong></p><ul><li>单线程对系统资源的占用很小；</li><li>很容易实现高并发；</li></ul><p>此模型的缺点：</p><ul><li>不支持分布式内存模型，只解决了进程内的并发同步；</li></ul><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>高并发的关键在于实现异步非阻塞，更加高效地利用 CPU，涉及的两大安全难题则是<strong>线程安全</strong>与<strong>内存安全</strong>。多线程可以达到非阻塞，但占用资源多，切换开销大。协程用栈的动态增长、用户态的调度来避免多线程的两个问题。事件驱动用单线程的方式，避免了占用太多系统资源，不需要关心线程安全，但无法利用多核。具体要采用哪种模型，还是要看需求。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://gobomb.github.io/post/high-concurrency-model/">high-concurrency-model</a><br><a href="https://www.bmpi.dev/dev/deep-in-program-language/how-to-implement-concurrency/concurrency-model/"></a></p>]]></content>
      
      
      <categories>
          
          <category> 理论知识 </category>
          
          <category> 并发相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分库分表</title>
      <link href="/posts/a3a0c28e.html"/>
      <url>/posts/a3a0c28e.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-1、为什么分库？"><a href="#1-1、为什么分库？" class="headerlink" title="1.1、为什么分库？"></a>1.1、为什么分库？</h3><p>分库主要解决并发及磁盘存储的问题。</p><ul><li><strong>并发支撑：</strong> 数据库的连接数是有限，即使能调整也不是无限的。所以并发量一上来，数据库就是服务的瓶颈。<br>所以，当数据库的读或者写的QPS过高，导致你的数据库连接数不足了的时候，就需要考虑分库了，通过增加数据库实例的方式来提供更多的可用数据库链接，从而提升系统的并发度。</li></ul><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/mysql/分库概念图.png" alt="分库概念图">  </p><ul><li><strong>磁盘存储：</strong> 业务量剧增，MySQL单机磁盘容量会撑爆，拆成多个数据库，磁盘使用率大大降低。</li></ul><h3 id="1-2、为什么分表？"><a href="#1-2、为什么分表？" class="headerlink" title="1.2、为什么分表？"></a>1.2、为什么分表？</h3><p>分库主要解决的是并发量大的问题，那分表其实主要解决的是数据量大的问题。</p><p>数据量太大的话，SQL的查询就会变慢。如果一个查询SQL没命中索引，千百万数据量的表可能会拖垮这个数据库。</p><p>一般我们认为，单表行数超过 <strong>500 万行</strong> 或者单表容量超过 <strong>2GB</strong> 之后，才需要考虑做分库分表了，小于这个数据量，遇到性能问题先建议大家通过其他优化来解决。</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/mysql/分表概念图.png" alt="分表概念图">  </p><h3 id="1-3、即分库又分表？"><a href="#1-3、即分库又分表？" class="headerlink" title="1.3、即分库又分表？"></a>1.3、即分库又分表？</h3><p>当并发和数据量都起来的时候就需要即分库又分表了。切分就需要考虑怎么分了。分库分表有两种拆分机制：</p><ul><li>水平拆分</li><li>垂直拆分</li></ul><h2 id="二、垂直（纵向）拆分"><a href="#二、垂直（纵向）拆分" class="headerlink" title="二、垂直（纵向）拆分"></a>二、垂直（纵向）拆分</h2><p>垂直拆分有垂直分库和垂直分表两种。</p><h3 id="2-1、垂直分库"><a href="#2-1、垂直分库" class="headerlink" title="2.1、垂直分库"></a>2.1、垂直分库</h3><p><strong>垂直分库：</strong> 就是根据业务耦合性将关联度低的表分别存储在不同的数据，以此来降低各个数据连接数据和磁盘占用。和微服务治理的理念非常相似，每一个独立的服务都拥有自己的数据库，需要不同业务的数据需接口调用。它的核心理念是专库专用。</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/mysql/分库概念图.png" alt="垂直分库">  </p><h3 id="2-2、垂直分表"><a href="#2-2、垂直分表" class="headerlink" title="2.2、垂直分表"></a>2.2、垂直分表</h3><p><strong>垂直分表：</strong> 就是将表内字段进行拆分，根据使用情况及关联性，将一张表垂直切割成多张表。每张表留有原表的部分字段，多张表合起来和原表一样。</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/mysql/垂直拆分表.png" alt="垂直拆分表"> </p><p>当然，分开的每张表都会保留唯一值字段，一般是主键，也可以是唯一值索引。这样也是为了方便查询命中。</p><h2 id="三、水平拆分"><a href="#三、水平拆分" class="headerlink" title="三、水平拆分"></a>三、水平拆分</h2><p>水平切分分为 <strong>库内分表</strong> 和 <strong>分库分表</strong> ，是根据表内数据内在的逻辑关系，将同一个表按不同的条件分散到多个数据库或多个表中。</p><h3 id="3-1、水平分表"><a href="#3-1、水平分表" class="headerlink" title="3.1、水平分表"></a>3.1、水平分表</h3><p>库内分表：即水平分表，每个表中只包含一部分数据，从而使得单个表的数据量变小，达到分布式的效果。即：每张表结构完全一样，只是数据不一样。<br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/mysql/水平拆分表.png" alt="水平拆分表"> </p><h3 id="3-2、水平分库"><a href="#3-2、水平分库" class="headerlink" title="3.2、水平分库"></a>3.2、水平分库</h3><p>分库分表：即水平分库，单表分为多个结构一样且存储在不同的数据库中</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/mysql/水平拆分两种模式.png" alt="水平拆分两种模式"> </p><h3 id="3-3、分表策略——Range"><a href="#3-3、分表策略——Range" class="headerlink" title="3.3、分表策略——Range"></a>3.3、分表策略——Range</h3><p><strong>Range</strong>：范围划分，比如按照时间将数据划分为每月一张表。或者根据id范围，如：【1-100000】放一张表，【100001-10000000】放在一张等依次类推。</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/mysql/Range分表.png" alt="Range分表"> </p><p><strong>优缺点：</strong></p><ul><li>优点：是自带水平扩展，不需要过多干预。</li><li>缺点：存在热点数据，比如某个月请求暴增。</li></ul><h3 id="3-4、分表策略——mod-hash-mod"><a href="#3-4、分表策略——mod-hash-mod" class="headerlink" title="3.4、分表策略——mod/hash+mod"></a>3.4、分表策略——mod/hash+mod</h3><p><strong>mod</strong>: 取余模式，指定路由的key（一般是id）通过分表的数量进行取余，然后根据余数指定将数据存储入表中。<br><strong>hash+mod</strong>：在取余之前，针对路由的key进行Hash取值，取值后再取余。这种方式与 <strong>HashMap的key</strong> 存储机制类似。</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/mysql/mod分表.png" alt="mod分表"> </p><p><strong>分表数量</strong>：具体分表数量要根据业务的实际情况，以及对未来业务发展情况及数据量级增加情况进行划分。此处扩展较为麻烦，比如原数据 <strong>16%4</strong> 分配在表 <strong>union_bill_0</strong> 中，扩展表数量为 <strong>8</strong> 后，数据存储在 <strong>16%8</strong> 表 <strong>union_bill_2</strong> 中，此种方式在扩展表时，需要针对历史数据进行数据迁移。</p><p><strong>优缺点：</strong></p><ul><li>优点：不存在热点数据。</li><li>缺点：不利于水平扩展。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分库分表 </tag>
            
            <tag> ShardingSphere </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存模型</title>
      <link href="/posts/c2d38e6e.html"/>
      <url>/posts/c2d38e6e.html</url>
      
        <content type="html"><![CDATA[<h1 id="JVM内存"><a href="#JVM内存" class="headerlink" title="JVM内存"></a>JVM内存</h1><h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p><strong>内存</strong> 是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行.</p><p>在JVM自动内存管理机制，开发人员不需要去考虑内存的delete/free操作，不容易出现内存溢出和泄露问题。</p><h3 id="二-运行时数据区域-内存布局"><a href="#二-运行时数据区域-内存布局" class="headerlink" title="二 运行时数据区域/内存布局"></a>二 运行时数据区域/内存布局</h3><p>1.8之前和之后略有区别，主要体现在为1.8之前存在方法区(Method Area)，1.8之后去掉方法区，增加元空间(MetaSpace)</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/JVM/Java虚拟机运行时数据区_水印.jpg" alt="Java内存布局"></p><h4 id="2-1-虚拟机栈"><a href="#2-1-虚拟机栈" class="headerlink" title="2.1 虚拟机栈"></a>2.1 虚拟机栈</h4><ol><li><p>Java 虚拟机栈（Java Virtual Machine Stacks）也就是我们平时所说的 <strong>栈内存</strong>，或者指的就是虚拟机栈中的 <strong>局部变量表</strong> 部分。<br>虚拟机栈描述的是Java方法的内存模型：即每个方法在执行的同时都会创建一个 <strong>栈帧</strong>，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。所以虚拟机栈是线程私有的，生命周期与线程相同。  </p></li><li><p><strong>栈针（Stack Frame）</strong> ：用于支持虚拟机进行方法调用和方法执行的数据结构。每一个方法从调用至执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。  </p></li><li><p><strong>局部变量表</strong>：存放编译期方法内部的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference）类型等。<br>局部变量表所需空间是在编译期间完成分配的，当进入方法，该方法需要的栈针分配的空间是固定，在方法运行期间不会改变.   </p><p><strong>操作数栈</strong>：Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。当JVM为方法创建栈帧的时候，在栈帧中为方法创建一个操作数栈，保证方法内指令可以完成工作。</p><p><strong>动态链接</strong>： 每个栈帧中包含一个在常量池中对当前方法的引用， 目的是支持方法调用过程的动态连接。</p><p><strong>方法返回地址</strong>： 退出的两种形式，1、正常退出；2、抛出异常。</p></li><li><p>虚拟机栈在JVM中存在两种异常</p><ul><li>StackOverflowError：若线程请求的栈深度大于当前虚拟机所允许的深度，抛出此异常</li><li>OutOfMemoryError：若虚拟机栈可动态扩展，当扩展时无法申请到足够的内存，抛出此异常</li></ul></li></ol><h4 id="2-2-本地方法栈"><a href="#2-2-本地方法栈" class="headerlink" title="2.2 本地方法栈"></a>2.2 本地方法栈</h4><p>本地方法栈Native Method Stack）与虚拟机栈的作用是相似。区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong>   </p><p>此外，对于此区域出现的异常，和虚拟机栈是相同的。</p><h4 id="2-3-程序计数器"><a href="#2-3-程序计数器" class="headerlink" title="2.3 程序计数器"></a>2.3 程序计数器</h4><p>程序计数器（Program Counter Register）是当前线程所执行的字节码的行号指示器，它占用一块较小的内存空间。<strong>字节码解释器通过改变该计数器的值来选取下一条需要执行的字节码指令，其中包括分支、循环、跳转、异常处理、线程恢复等基础功能。</strong>  </p><p>Java多线程是处理器的时间片转轮的策略的实现的，任一确定时刻，一个处理器只执行一条线下中的命令，为了切换线程后可恢复到正确的执行位置，程序计数器为线程私有。</p><p><strong>程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</strong></p><h4 id="2-4-堆"><a href="#2-4-堆" class="headerlink" title="2.4 堆"></a>2.4 堆</h4><ol><li><p>堆（Heap）是JVM最重要的也是最大的一块内存，在虚拟机启动时创建。对于堆来说，它可以位于物理上不连续而逻辑上连续的内存空间中。在实际情况下也可以通过调整虚拟机参数的方式对堆进行扩展，即通过 -Xmx 和 -Xms 控制。</p></li><li><p>该区域的主要作用: <strong>为对象实例及数组分配内存</strong>，几乎存储了所有对象实例。同时也是垃圾回收器管理的主要区域，因此也被称作GC 堆（Garbage Collected Heap）。 <br><br><br>Java堆还可以细分为：新生代和老年代。再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。具体如下图：<br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/JVM/Heap.jpg" alt="堆Heap详细分布">1.8后去除永生代，用元空间替代。<br><br><br>查看虚拟机默认配置命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -version</span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="2-5-方法区-Method-Area"><a href="#2-5-方法区-Method-Area" class="headerlink" title="2.5 方法区(Method Area)"></a>2.5 方法区(Method Area)</h4><ol><li><p>方法区（Method Area）用于存储已被虚拟机加载的 类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p></li><li><p>方法区也被成为永生代，二者关系分析起来比较容易混淆，引用下面个人认为比较好的释义：</p><blockquote><p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。<strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p></blockquote></li><li><p>方法区或者称为永生代，<strong>在1.8中被去除</strong>。并用元空间（Metaspace）替换。</p></li></ol><h4 id="2-5-元空间（Metaspace）"><a href="#2-5-元空间（Metaspace）" class="headerlink" title="2.5 元空间（Metaspace）"></a>2.5 元空间（Metaspace）</h4><ol><li>元空间替换方法区的原因：<ul><li>因为PermGen/(Method Area)经常内存溢出。</li><li>促进HotSpot和JRockit VM融合，因为 JRockit 没有永久代。<br>详细原因：<a href="http://openjdk.java.net/jeps/122">JEP 122:Remove the Permanent Generation</a></li></ul></li><li>根据上面的原因方法区被移除，方法区中类元信息、字段、静态属性、方法、常量等移至元空间，<strong>并在1.7时将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></li><li>元空间和方法区本质类似，主要区别在于：<strong>元空间使用本地内存，方法区存在于虚拟机中。</strong> 所以元空间的大小取决于本地内存的容量。  </li></ol><p>元空间对应的JVM调参：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">-XX:MaxMetaspaceSize</td><td style="text-align:left">分配给Metaspace 的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。</td></tr><tr><td style="text-align:left">-XX:MinMetaspaceFreeRatio</td><td style="text-align:left">在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</td></tr><tr><td style="text-align:left">-XX:MaxMetaspaceFreeRatio</td><td style="text-align:left">在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</td></tr><tr><td style="text-align:left">-XX:MetaspaceSize</td><td style="text-align:left">分配给Metaspace（以字节计）的初始大小</td></tr></tbody></table></div><h4 id="2-6-直接内存（Direct-Memory）"><a href="#2-6-直接内存（Direct-Memory）" class="headerlink" title="2.6 直接内存（Direct Memory）"></a>2.6 直接内存（Direct Memory）</h4><p>直接内存并不属于Java内存的一员，但这部分也经常被使用并也会出现OutOfMemoryError 异常。<br>虽然直接内存不受Java堆大小的限制，但还是会受到本机总内存的大小及处理器寻址空间的限制。如果内存区域总和大于物理内存的限制，也会出现OOM。</p><hr><h5 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h5><ul><li><a href="https://dyfloveslife.github.io/2019/11/18/java-memory-areas">https://dyfloveslife.github.io/2019/11/18/java-memory-areas</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>血常规/血分析</title>
      <link href="/posts/9e7d6171.html"/>
      <url>/posts/9e7d6171.html</url>
      
        <content type="html"><![CDATA[<h2 id="血常规相关指标解读"><a href="#血常规相关指标解读" class="headerlink" title="血常规相关指标解读"></a>血常规相关指标解读</h2><p>  按照每项指标进行解读，单纯的单项指标的意义，不具备临床参考意义。具体病因须整体分析。</p><h3 id="报告示例"><a href="#报告示例" class="headerlink" title="报告示例"></a>报告示例</h3><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/医学信息/血分析.jpg" alt="血分析"></p><h3 id="白细胞（WBC）"><a href="#白细胞（WBC）" class="headerlink" title="白细胞（WBC）"></a>白细胞（WBC）</h3><p>白细胞(white blood cell), 旧称白血球,是血液中一种重要的血细胞。白细胞与红血球，血小板并称三大血细胞。除白细胞外，人体血液中还含有红血球、血小板和血浆。</p><p>白细胞也通常被称为免疫细胞, 作为免疫系统的一部分帮助身体抵抗传染病以及外来的病原。正常情况下白细胞在健康成人体内为4×10^9到10×10^9/每升血液。</p><p>白细胞无色，呈球形，直径在7～20μm之间。白细胞有细胞核，能作变形运动。白细胞一般有活跃的移动能力，它们可以从血管内迁移到血管外，或从血管外组织迁移到血管内。因此, 除了在血液外，白细胞还存在于淋巴系统、脾以及身体的其它组织中。</p><p>由于白细胞的增生失去控制而引起的一种癌症称为“白血病”。</p><h4 id="白细胞意义"><a href="#白细胞意义" class="headerlink" title="白细胞意义"></a>白细胞意义</h4><h5 id="正常值范围"><a href="#正常值范围" class="headerlink" title="正常值范围"></a>正常值范围</h5><ul><li>成人：（4.0-10.0）×10^9个/L</li><li>新生儿：（15-20）×10^9个/L</li><li>6个月到2岁：（11-12）×10^9个/L</li><li>4到14岁：8×10^9个/L</li><li>儿童：（5.0-12.0）×10^9/L<h5 id="临床意义"><a href="#临床意义" class="headerlink" title="临床意义"></a>临床意义</h5>1.升高<br>白细胞计数升高并不完全是疾病的表现，因此有生理性和病理性升高之分。<br>各种细胞感染,炎症,严重烧伤.明显升高时应除外白血病.</li><li>降低：白细胞减少症,脾功能亢进,造血功能障碍,放射线,药物,化学毒素等引起骨髓抑制,疟疾,伤寒,病毒感染,副伤寒.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 化验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 化验-验血 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM调优之jps jinfo jstat jmap jhat</title>
      <link href="/posts/10c0b7f2.html"/>
      <url>/posts/10c0b7f2.html</url>
      
        <content type="html"><![CDATA[<h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>虽然jvm调优成熟的工具已经有很多：jconsole、大名鼎鼎的VisualVM，IBM的Memory Analyzer等等。但生产环境出现问题时，一是受环境所限，二是所有工具几乎都是依赖JDK的接口和底层连接命令，所以研究JDK的这些命令有助我们进一步了解JDK的构成和特性。</p><h4 id="调优原则"><a href="#调优原则" class="headerlink" title="调优原则"></a>调优原则</h4><p>多数应用在服务器不需要怎么进行GC优化，多数导致GC问题的应用，主要问题并不在于GC的参数上，而更多的在代码上面。如：全局变量对象创建过多等。GC是最后不得已下的手段而已。所以通过GC情况分析并优化代码比GC调优要更多。</p><p>本文基于JDK8，相关监控和处理故障的命令有：jps、jinfo、jstat、jmap、jhat。</p><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>jps（JVM Process Status Tool）：显示指定系统内所有Hotspot虚拟机进程</p><p>命令格式：<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></tbody></table></figure><br>options参数：  <p></p><ul><li>-l：输入主类的全名或路径  </li><li>-q：输出LVMID  </li><li>-m：输出JVM启动时传递给main()的参数  </li><li>-v：输出JVM启动时显示指定的参数    </li></ul><p>示例：<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">λ jps -l</span><br><span class="line">39392 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">77060 sun.tools.jps.Jps</span><br><span class="line">115404 org.jetbrains.idea.maven.server.RemoteMavenServer</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p>jinfo(JVM Configuration info)：生成指定进程的JVM配置信息。</p><p>命令格式：<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo -&lt;options&gt; vmid</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="options参数"><a href="#options参数" class="headerlink" title="options参数"></a>options参数</h3><ul><li>-flag <name>：打印指定参数的名称和值。</name></li><li>-flag [+|-]name：启用或禁用指定的布尔命令标志。</li><li>-flag <name>=<value>：设定指定参数的值。</value></name></li><li>-flags：输出所有JVM参数。</li><li>-sysprops：以key-value形式，输出Java系统属性。</li></ul><p>示例：<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">λ jinfo -flag MaxNewSize 75052</span><br><span class="line">  -XX:MaxNewSize=1418723328</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p>jstat（JVM Statistics Monitoring）：监视虚拟机运行时状态信息的命令，它可显示JVM的类加载、内存、垃圾收集、JIT编译等运行数据等。</p><p>命令格式：<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>option：操作参数</li><li>-t ：将时间戳列显示为输出的第一列。时间戳是自目标JVM启动时间以来的时间。</li><li>-h<lines>：即-h跟数字，代表隔几行显示标题，默认为0</lines></li><li>vmid ：代表vm进程id</li><li>interval：代表监控间隔时间段，默认毫秒做单位</li><li>count：代表取数次数</li></ul><h3 id="options参数-1"><a href="#options参数-1" class="headerlink" title="options参数"></a>options参数</h3><h4 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h4><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">class</td><td style="text-align:left">class loader的行为统计<br>Statistics about the behavior of the class loader.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">compiler</td><td style="text-align:left">HotSpt JIT编译器行为统计。<br>Statistics about the behavior of the Java HotSpot VM Just-in-Time compiler.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">gc</td><td style="text-align:left">垃圾收集堆行为统计.<br>Statistics about the behavior of the garbage collected heap.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">gccapacity</td><td style="text-align:left">代的容量及其相应空间的统计信息。<br>Statistics about the capacities of the generations and their corresponding spaces.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">gccause</td><td style="text-align:left">垃圾收集器统计概述(同gcutil)，及最近两次垃圾回收原因。<br>A summary about garbage collection statistics (same as -gcutil), with the cause of the last and current (when applicable) garbage collection events.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">gcnew</td><td style="text-align:left">新生代代行为统计<br>Statistics about the behavior of the new generation.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">gcnewcapacity</td><td style="text-align:left">新生代与其相应的内存空间统计。<br>Statistics about the sizes of the new generations and their corresponding spaces.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">gcold</td><td style="text-align:left">老年代和元空间的行为统计。<br>Statistics about the behavior of the old generation and metaspace statistics.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">gcoldcapacity</td><td style="text-align:left">老年代大小统计。<br>Statistics about the sizes of the old generation.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">gcmetacapacity</td><td style="text-align:left">元空间大小统计。<br>Statistics about the sizes of the metaspace.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">gcutil</td><td style="text-align:left">垃圾收集器统计概述。<br>A summary about garbage collection statistics.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">printcompilation</td><td style="text-align:left">HotSpot编译方法统计。<br>Java HotSpot VM compilation method statistics.</td><td style="text-align:left"></td></tr></tbody></table></div><h4 id="options参数详解"><a href="#options参数详解" class="headerlink" title="options参数详解"></a>options参数详解</h4><h5 id="class"><a href="#class" class="headerlink" title="-class"></a>-class</h5><p>Class loader statistics.<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -class 62044</span><br><span class="line">  Loaded  Bytes    Unloaded  Bytes     Time</span><br><span class="line">  6152    12149.8     0       0.0       8.72</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>Loaded：加载class数量。  </li><li>Bytes：加载的class字节大小（KB）。</li><li>Unloaded：未加载的class数量。</li><li>Bytes：未加载calss字节大小（KB）。</li><li>Time：执行类加载和卸载的总时间。</li></ul><h5 id="compiler"><a href="#compiler" class="headerlink" title="-compiler"></a>-compiler</h5><p>Java HotSpot VM Just-in-Time compiler statistics.<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -compiler 62044</span><br><span class="line">  Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line">      8306      2       0    34.24          1 com/alibaba/druid/pool/DruidDataSource shrink</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>Compilerd：编译数量</li><li>Failed：编译失败的数量</li><li>Invalid：无效的数量</li><li>Time：执行编译时长</li><li>FailedType : 失败类型</li><li>FailedMethod : 失败方法的全限定名</li></ul><h5 id="gc"><a href="#gc" class="headerlink" title="-gc"></a>-gc</h5><p>Garbage collected heap statistics.<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -gc 62044</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">512.0  512.0   0.0    96.0  27648.0   6616.5   67584.0    55474.4   42112.0 41055.1 4736.0 4522.8  50299   94.002  12      0.677   94.679</span><br></pre></td></tr></tbody></table></figure><br>C：Capacity，即总容量，容量单位为KB；U：Used，即已使用容量。  <p></p><ul><li>S0C：survivor0总容量  </li><li>S1C：survivor1总容量  </li><li>S0U：survivor0已使用容量</li><li>S1U：survivor1已使用容量</li><li>EC：Eden区总容量</li><li>EU：Eden区已使用容量</li><li>OC：老年代总容量</li><li>OU：老年代已使用容量</li><li>MC：元空间承诺大小</li><li>MU：元空间已使用容量</li><li>CCSC：压缩类容量大小</li><li>CCSU：压缩类已使用容量</li><li>YGC：新生代垃圾回收次数</li><li>YGCT：新生代垃圾回收时间</li><li>FGC：老年代垃圾回收次数</li><li>FGCT：老年代垃圾回收时间</li><li>GCT：垃圾回收总耗时</li></ul><h5 id="gccapacity"><a href="#gccapacity" class="headerlink" title="-gccapacity"></a>-gccapacity</h5><p>Memory pool generation and space capacities.<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -gccapacity 62044</span><br><span class="line"> NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC</span><br><span class="line"> 86528.0 1385472.0  32256.0  512.0  512.0  30720.0   173568.0  2771968.0    83968.0    83968.0      0.0 1085440.0  39936.0      0.0 1048576.0   4608.0   1306     2</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>NGCMN：新生代最小容量</li><li>NGCMX：新生代最大容量</li><li>NGC：当前新生代容量</li><li>S0C：survivor0总容量  </li><li>S1C：survivor1总容量  </li><li>EC：Eden区总容量  </li><li>OGCMN：老年代最小容量</li><li>OGCMX：老年代最大容量</li><li>OGC：当前老年代容量</li><li>OC：老年代总容量</li><li>MCMN：元空间最小容量</li><li>MCMX：元空间最大容量</li><li>MC：元空间当前容量</li><li>CCSMN：压缩类空间最小容量</li><li>CCSMX：压缩类空间最大容量</li><li>CCSC：当前压缩类空间容量</li><li>YGC：年轻的GC次数</li><li>FGC：老年代GC次数</li></ul><h5 id="gccause"><a href="#gccause" class="headerlink" title="-gccause"></a>-gccause</h5><p>垃圾收集器统计概述(同gcutil)，及最近两次垃圾回收原因。<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -gccause 62044</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC</span><br><span class="line"> 25.00   0.00  49.19  37.97  97.21  96.06   2360    4.765     2    0.099    4.865 Allocation Failure   No GC</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>LGCC：上次垃圾回收原因</li><li>GCC：当前垃圾回收原因</li></ul><h5 id="gcnew"><a href="#gcnew" class="headerlink" title="-gcnew"></a>-gcnew</h5><p>新生代代行为统计<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -gcnew 62044</span><br><span class="line"> S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT</span><br><span class="line"> 512.0  512.0    0.0   96.0 15  15  512.0  30720.0   6082.8   2557    5.169</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>S0C：survivor0总容量  </li><li>S1C：survivor1总容量  </li><li>S0U：survivor0已使用容量</li><li>S1U：survivor1已使用容量</li><li>TT：Tenuring threshold.(任期阈值)</li><li>DTT： Maximum tenuring threshold.</li><li>DSS：DSS: Desired survivor size (KB).survivor的容量</li><li>EC：Eden区总容量</li><li>EU：Eden区已使用容量</li><li>YGC：新生代垃圾回收次数</li><li>YGCT：新生代垃圾回收时间</li></ul><h4 id="gcnewcapacity"><a href="#gcnewcapacity" class="headerlink" title="-gcnewcapacity"></a>-gcnewcapacity</h4><p>新生代与其相应的内存空间统计。<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -gcnewcapacity 105308</span><br><span class="line">  NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC</span><br><span class="line">   86528.0  1385472.0    64512.0 461824.0   9728.0 461824.0    512.0  1384448.0    45056.0    25     2</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>NGCMN：新生代最小容量</li><li>NGCMX：新生代最大容量</li><li>NGC：当前新生代容量</li><li>S0CMX：survivor0最大容量</li><li>S0C：当前survivor0容量</li><li>ECMX：Eden最大容量</li><li>EC：当前Eden容量</li><li>YGC：新生代垃圾回收次数</li><li>FGC：老年代GC次数</li></ul><h5 id="gcold"><a href="#gcold" class="headerlink" title="-gcold"></a>-gcold</h5><p>老年代和元空间的行为统计。<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -gcold 105308</span><br><span class="line">   MC       MU      CCSC     CCSU       OC          OU       YGC    FGC    FGCT     GCT</span><br><span class="line"> 39680.0  38773.6   4608.0   4422.3     80896.0     22094.7    313     2    0.098    0.805</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>MC：元空间承诺大小</li><li>MU：元空间已使用容量</li><li>CCSC：压缩类容量大小</li><li>CCSU：压缩类已使用容量</li><li>OC：老年代总容量</li><li>OU：老年代已使用容量</li><li>YGC：新生代垃圾回收次数</li><li>FGC：老年代垃圾回收次数</li><li>FGCT：老年代垃圾回收时间</li><li>GCT：垃圾回收总耗时</li></ul><h5 id="gcoldcapacity"><a href="#gcoldcapacity" class="headerlink" title="-gcoldcapacity"></a>-gcoldcapacity</h5><p>老年代大小统计。<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -gcoldcapacity 105308</span><br><span class="line">   OGCMN       OGCMX        OGC         OC       YGC   FGC    FGCT     GCT</span><br><span class="line">   173568.0   2771968.0     80896.0     80896.0   740     2    0.098    1.668</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>OGCMN：老年代最小容量</li><li>OGCMX：老年代最大容量</li><li>OGC：当前老年代容量</li><li>OC：老年代总容量</li><li>YGC：年轻的GC次数</li><li>FGC：老年代GC次数</li><li>FGCT：老年代垃圾回收时间</li><li>GCT：垃圾回收总耗时</li></ul><h5 id="gcmetacapacity"><a href="#gcmetacapacity" class="headerlink" title="-gcmetacapacity"></a>-gcmetacapacity</h5><p>元空间大小统计。<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -gcmetacapacity 105308</span><br><span class="line">   MCMN       MCMX        MC       CCSMN      CCSMX       CCSC     YGC   FGC    FGCT     GCT</span><br><span class="line">       0.0  1085440.0    40448.0        0.0  1048576.0     4608.0   848     2    0.098    1.885</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>MCMN：元空间最小容量</li><li>MCMX：元空间最大容量</li><li>MC：元空间当前容量</li><li>CCSMN：压缩类空间最小容量</li><li>CCSMX：压缩类空间最大容量</li><li>CCSC：当前压缩类空间容量</li><li>YGC：年轻的GC次数</li><li>FGC：老年代GC次数</li><li>FGCT：老年代垃圾回收时间</li><li>GCT：垃圾回收总耗时</li></ul><h5 id="gcutil"><a href="#gcutil" class="headerlink" title="-gcutil"></a>-gcutil</h5><p>垃圾收集器统计概述。<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -gcutil 105308</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">  0.00  31.25  57.06  30.97  97.41  96.00    959    2.047     2    0.098    2.145</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>S0、S1、E、O、M、CCS分别为对应内存空间已使用容量占总容量的百分比。</li></ul><h4 id="printcompilation"><a href="#printcompilation" class="headerlink" title="-printcompilation"></a>-printcompilation</h4><p>HotSpot编译方法统计。<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -printcompilation 105308</span><br><span class="line">Compiled  Size  Type Method</span><br><span class="line">    7351     30    1 org/apache/http/message/TokenParser isWhitespace</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>Compiled：被执行的编译任务的数量</li><li>Size：方法字节码的字节数</li><li>Type：编译类型</li><li>Method：编译方法的类名和方法名。类名使用”/“ 代替 “.” 作为空间分隔符. 方法名是给出类的方法名. 格式是一致于HotSpot - XX:+PrintComplation 选项</li></ul><h3 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -gcutil 105308 200 10</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line"> 31.25   0.00  69.70  41.31  97.43  96.12   3050    6.466     2    0.098    6.564</span><br><span class="line">  0.00  25.00  25.65  41.31  97.43  96.12   3051    6.468     2    0.098    6.566</span><br><span class="line">  0.00  25.00  38.43  41.31  97.43  96.12   3051    6.468     2    0.098    6.566</span><br><span class="line">  0.00  25.00  50.31  41.31  97.43  96.12   3051    6.468     2    0.098    6.566</span><br><span class="line">  0.00  25.00  63.75  41.31  97.43  96.12   3051    6.468     2    0.098    6.566</span><br><span class="line">  0.00  25.00  73.27  41.31  97.43  96.12   3051    6.468     2    0.098    6.566</span><br><span class="line">  0.00  25.00  84.72  41.31  97.43  96.12   3051    6.468     2    0.098    6.566</span><br><span class="line">  0.00  25.00  99.04  41.31  97.43  96.12   3051    6.468     2    0.098    6.566</span><br><span class="line"> 31.25   0.00  11.40  41.31  97.43  96.12   3052    6.469     2    0.098    6.567</span><br><span class="line"> 31.25   0.00  20.88  41.31  97.43  96.12   3052    6.469     2    0.098    6.567</span><br></pre></td></tr></tbody></table></figure><p>示例中vmid为105308，指令含义为输出垃圾收集统计概述，输出策略为每200毫秒一次共输出10次<br>根据结果可得出以下结果：</p><ol><li>10次内进行两次新生代GC</li><li>第一次新生代GC耗时0.002秒，第二次耗时0.001秒。</li><li>没有进行老年代收集，老年代没有空间上的变化，说明Eden区没有对象年龄晋升到老年代</li><li>第一次YGC将S0内对象提升到S1，S1部分对象提升到Eden区</li><li>元空间没有变化，但元空间使用程度已经极高，到了96.12%，这个时候就可以考虑下元空间调优的问题了。</li></ol><h2 id="jmap-print-details-of-a-specified-process"><a href="#jmap-print-details-of-a-specified-process" class="headerlink" title="jmap - print details of a specified process"></a>jmap - print details of a specified process</h2><p>jmap(JVM Memory Map)：用于生成heap dump文件，还可以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。<br>可以使用XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候·自动生成dump文件。</p><p>命令格式：<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -&lt;options&gt; &lt;vmid&gt;</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="options参数-2"><a href="#options参数-2" class="headerlink" title="options参数"></a>options参数</h3><h4 id="总览-1"><a href="#总览-1" class="headerlink" title="总览"></a>总览</h4><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">-clstats</td><td style="text-align:left">打印java堆类加载统计信息<br>Prints class loader wise statistics of Java heap.</td></tr><tr><td style="text-align:left">-finalizerinfo</td><td style="text-align:left">打印等待结束的对象信息<br>Prints information about objects that are awaiting finalization.</td></tr><tr><td style="text-align:left">-histo[:live]</td><td style="text-align:left">打印堆的对象统计，包括对象数量，大小等。也可以单独指定子项：live，只打印存活对象。<br>Prints a histogram of the heap. For each Java class, the number of objects, memory size in bytes, and the fully qualified class names are printed. The JVM internal class names are printed with an asterisk (*) prefix. If the live suboption is specified, then only active objects are counted.</td></tr><tr><td style="text-align:left">-dump:[live,] format=b, file=filename</td><td style="text-align:left">将Java堆以hprof二进制格式转储为文件名filename。live子选项选定时，只转储存活对象。<br>Dumps the Java heap in hprof binary format to filename. The live suboption is optional, but when specified, only the active objects in the heap are dumped. To browse the heap dump, you can use the jhat(1) command to read the generated file.</td></tr><tr><td style="text-align:left">-heap</td><td style="text-align:left">输出java堆概览.<br>Prints a heap summary of the garbage collection used, the head configuration, and generation-wise heap usage. In addition, the number and size of interned Strings are printed.</td></tr></tbody></table></div><h4 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h4><h5 id="clstats"><a href="#clstats" class="headerlink" title="-clstats"></a>-clstats</h5><p>连接正在运行的进程，打印类加载器的统计信息<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">λ jmap -clstats 75052</span><br><span class="line">Attaching to process ID 75052, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.131-b11</span><br><span class="line">finding class loader instances ..done.</span><br><span class="line">computing per loader stat ..done.</span><br><span class="line">please wait.. computing liveness.liveness analysis may be inaccurate ...</span><br><span class="line">class_loader    classes bytes   parent_loader   alive?  type</span><br><span class="line"></span><br><span class="line">&lt;bootstrap&gt;     3735    6715263   null          live    &lt;internal&gt;</span><br><span class="line">0x00000006c24851c8      1       889     0x00000006c24853f0      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c3220ba0      1       1471    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c3820380      1       1471    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c383c380      1       1471    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2cea748      1       878       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2bf8178      1       1472      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c337c6f0      1       1483    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2485100      1       878       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2418f08      2749    5382011 0x00000006c2418f68      dead    sun/misc/Launcher$AppClassLoader@0x00000007c000f6a0</span><br><span class="line">0x00000006c3220c68      1       1471    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2cea680      1       880       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c337c838      1       1473    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c3908b40      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2ceab58      1       880       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c3908c08      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c28bafd0      0       0       0x00000006c2418f08      dead    java/util/ResourceBundle$RBClassLoader@0x00000007c0089950</span><br><span class="line">0x00000006c2ceaa90      1       1472    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2bf87a0      1       1473      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2bf89a0      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2485328      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c39089b0      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c3222ec0      1       880     0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c37cced8      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2bd2298      40      93710   0x00000006c2418f08      dead    com/alibaba/fastjson/util/ASMClassLoader@0x00000007c02af098</span><br><span class="line">0x00000006c2cea428      1       1474      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2bf86d8      1       1473      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c337d290      1       1485    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c3908a78      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2418f68      124     266033    null          dead    sun/misc/Launcher$ExtClassLoader@0x00000007c000fa48</span><br><span class="line">0x00000006c3222f88      1       1471    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c37cce10      1       1471    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2cea360      1       1485      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2bf8610      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2485038      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2cea5b8      1       880       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2bf8308      1       1471    0x00000006c2418f68      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2bf8548      1       1473      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c337cf80      1       878       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2484ef0      1       880       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c24853f0      12      37276   0x00000006c2418f08      dead    sun/reflect/misc/MethodUtil@0x00000007c0116af8</span><br><span class="line">0x00000006c2cea4f0      1       880       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2bf8240      1       1473      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c337d048      1       878       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c37fe380      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line"></span><br><span class="line">total = 45      6699    12545217            N/A         alive=1, dead=44            N/A</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>class_loader：类加载器</li><li>classes：加载的class数</li><li>bytes：加载字节码大小</li><li>parent_loader：父类加载器</li><li>live：存活状态</li><li>type：加载器类型</li></ul><h5 id="finalizerinfo"><a href="#finalizerinfo" class="headerlink" title="-finalizerinfo"></a>-finalizerinfo</h5><p>打印等待结束的对象信息<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">λ jmap -finalizerinfo 75052</span><br><span class="line">  Attaching to process ID 75052, please wait...</span><br><span class="line">  Debugger attached successfully.</span><br><span class="line">  Server compiler detected.</span><br><span class="line">  JVM version is 25.131-b11</span><br><span class="line">  Number of objects pending for finalization: 0</span><br></pre></td></tr></tbody></table></figure><br>可以看出来，目前没有等待结束的对象<p></p><h5 id="histo"><a href="#histo" class="headerlink" title="-histo"></a>-histo</h5><p>打印堆的对象统计，包括对象数量，大小等。也可以单独指定子项：live，只打印存活对象。<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">λ jmap -histo:live 75052|more</span><br><span class="line"></span><br><span class="line"> num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:          4071        5668128  [I</span><br><span class="line">   2:         52491        4982384  [C</span><br><span class="line">   3:          3629        1511648  [B</span><br><span class="line">   4:         51380        1233120  java.lang.String</span><br><span class="line">   5:          6620         751480  java.lang.Class</span><br><span class="line">   6:         16354         523328  java.util.concurrent.ConcurrentHashMap$Node</span><br><span class="line">   7:         15464         494848  java.util.HashMap$Node</span><br><span class="line">   8:          6599         409624  [Ljava.lang.Object;</span><br><span class="line">   9:          2787         245256  java.lang.reflect.Method</span><br><span class="line">  10:          1363         200728  [Ljava.util.HashMap$Node;</span><br><span class="line">  11:          8237         197688  sun.font.TrueTypeFont$DirectoryEntry</span><br><span class="line">  12:          6121         195872  java.util.Hashtable$Entry</span><br><span class="line">  13:           209         143976  [J</span><br><span class="line">-- More  --</span><br></pre></td></tr></tbody></table></figure><br>因histo统计对象的类型很多，带上more后，可根据命令窗口大小进行部分展示，可回车后继续展示。<br>其中class name为对象类型的，部分为简写，含义如下：<p></p><ul><li>B  byte</li><li>C  char</li><li>D  double</li><li>F  float</li><li>I  int</li><li>J  long</li><li>Z  boolean</li><li>[  数组，如[I表示int[]</li><li>[L+类名 其他对象</li></ul><h5 id="dump"><a href="#dump" class="headerlink" title="-dump"></a>-dump</h5><p>转储java堆信息，包含子项如下：</p><ul><li>live：当指定后，只转储存活对象</li><li>format=b：转储格式，以hprof二进制格式转储Java堆</li><li>file=filename：转储文件名  </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jmap -dump:live,format=b,file=heap 75052</span><br><span class="line">  Dumping heap to C:\Users\Y\heap1 ...</span><br><span class="line">  Heap dump file created</span><br></pre></td></tr></tbody></table></figure><p>示例中转储文件会生成在C:\Users\Y\目录下，后续dump文件分析可以根据文件大小进行选择。<br>分析工具：</p><ul><li>JDK自带程序jvisiualvm.exe</li><li>jhat命令</li><li>Eclipse Memory Analyzer(MAT)</li></ul><h5 id="heap"><a href="#heap" class="headerlink" title="-heap"></a>-heap</h5><p>输出java堆概览<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">λ jmap -heap 75052</span><br><span class="line">Attaching to process ID 75052, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.131-b11</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)  //GC方式，并行</span><br><span class="line"></span><br><span class="line">Heap Configuration://堆初始配置，可以通过 -XX:*(eg:NewSize) 进行对应参数设置</span><br><span class="line">   MinHeapFreeRatio         = 0//最小空闲比率</span><br><span class="line">   MaxHeapFreeRatio         = 100//最大空闲比率</span><br><span class="line">   MaxHeapSize              = 4257218560 (4060.0MB)//最大堆内存</span><br><span class="line">   NewSize                  = 88604672 (84.5MB)//新生代内存容量</span><br><span class="line">   MaxNewSize               = 1418723328 (1353.0MB)//最大新生代内存容量</span><br><span class="line">   OldSize                  = 177733632 (169.5MB)//老年代内存容量</span><br><span class="line">   NewRatio                 = 2//新生代和老年代大小比例</span><br><span class="line">   SurvivorRatio            = 8//Eden区与Survivor区的大小比值</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)//元空内存容量</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)//压缩类空间内存容量</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB//最大元空间内存</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)//G1垃圾回收器中指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space://Eden区使用情况：总容量、已使用、空闲、使用比例</span><br><span class="line">   capacity = 31981568 (30.5MB)</span><br><span class="line">   used     = 5003392 (4.7716064453125MB)</span><br><span class="line">   free     = 26978176 (25.7283935546875MB)</span><br><span class="line">   15.644611296106557% used</span><br><span class="line">From Space://survivor0使用情况</span><br><span class="line">   capacity = 524288 (0.5MB)</span><br><span class="line">   used     = 131072 (0.125MB)</span><br><span class="line">   free     = 393216 (0.375MB)</span><br><span class="line">   25.0% used</span><br><span class="line">To Space://survivor1使用情况</span><br><span class="line">   capacity = 524288 (0.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 524288 (0.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation//老年代使用情况</span><br><span class="line">   capacity = 88604672 (84.5MB)</span><br><span class="line">   used     = 22120552 (21.095802307128906MB)</span><br><span class="line">   free     = 66484120 (63.404197692871094MB)</span><br><span class="line">   24.965446517312316% used</span><br><span class="line"></span><br><span class="line">21409 interned Strings occupying 2142768 bytes.</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h2><p>jhat(JVM Heap Analysis Tool)与jmap结合使用，用来分析dump文件。jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看.<br>本文基于JDK8来分析使用相关命令，所以依旧存在jhat命令。从JDK9的时候已经删除了（JEP 241: Remove the jhat Tool）。现在Oracle官方推荐的分析工具是Eclipse Memory Analyzer Tool (MAT) 和 VisualVM(jvisualvm.exe)。</p><p>相关操作参数,有兴趣的可以深入了解一下：<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Usage:  jhat [-stack &lt;bool&gt;] [-refs &lt;bool&gt;] [-port &lt;port&gt;] [-baseline &lt;file&gt;] [-debug &lt;int&gt;] [-version] [-h|-help] &lt;file&gt;</span><br><span class="line"></span><br><span class="line">        -J&lt;flag&gt;          Pass &lt;flag&gt; directly to the runtime system. For</span><br><span class="line">                          example, -J-mx512m to use a maximum heap size of 512MB</span><br><span class="line">        -stack false:     Turn off tracking object allocation call stack.</span><br><span class="line">        -refs false:      Turn off tracking of references to objects</span><br><span class="line">        -port &lt;port&gt;:     Set the port for the HTTP server.  Defaults to 7000</span><br><span class="line">        -exclude &lt;file&gt;:  Specify a file that lists data members that should</span><br><span class="line">                          be excluded from the reachableFrom query.</span><br><span class="line">        -baseline &lt;file&gt;: Specify a baseline object dump.  Objects in</span><br><span class="line">                          both heap dumps with the same ID and same class will</span><br><span class="line">                          be marked as not being "new".</span><br><span class="line">        -debug &lt;int&gt;:     Set debug level.</span><br><span class="line">                            0:  No debug output</span><br><span class="line">                            1:  Debug hprof file parsing</span><br><span class="line">                            2:  Debug hprof file parsing, no server</span><br><span class="line">        -version          Report version number</span><br><span class="line">        -h|-help          Print this help and exit</span><br><span class="line">        &lt;file&gt;            The file to read</span><br></pre></td></tr></tbody></table></figure><p></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker日常命令</title>
      <link href="/posts/23c1b730.html"/>
      <url>/posts/23c1b730.html</url>
      
        <content type="html"><![CDATA[<h3 id="容器挂载文件相关"><a href="#容器挂载文件相关" class="headerlink" title="容器挂载文件相关"></a>容器挂载文件相关</h3><ol><li>查看容器挂的文件信息：<ul><li>命令：docker inspect containerID | grep Source -A 1</li><li>结果：<blockquote><p>“Source”: “/Users/workerspace/mysql/mysql2/mysql”,<br>“Destination”: “/var/lib/mysql”,</p><p>“Source”: “/host_mnt/Users/workerspace/mysql/mysql2/mysqld.cnf”,<br>“Destination”: “/etc/mysql/mysql.conf.d/mysqld.cnf”,</p></blockquote></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker之MySQL安装</title>
      <link href="/posts/bd5c77e2.html"/>
      <url>/posts/bd5c77e2.html</url>
      
        <content type="html"><![CDATA[<h1 id="docker-安装-mysql"><a href="#docker-安装-mysql" class="headerlink" title="docker 安装 mysql"></a>docker 安装 mysql</h1><h2 id="一、下载镜像"><a href="#一、下载镜像" class="headerlink" title="一、下载镜像"></a>一、下载镜像</h2><p>以最新版为例：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></tbody></table></figure><br>下载后通过 <strong>docker images</strong> 查看：<p></p><blockquote><p>REPOSITORY              TAG       IMAGE ID       CREATED        SIZE<br>mysql                   latest    7b94cda7ffc7   2 weeks ago    446MB<br>redis                   latest    7614ae9453d1   8 months ago   113MB</p></blockquote><h2 id="二、启动mysql容器"><a href="#二、启动mysql容器" class="headerlink" title="二、启动mysql容器"></a>二、启动mysql容器</h2><h3 id="2-1、启动"><a href="#2-1、启动" class="headerlink" title="2.1、启动"></a>2.1、启动</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name mysql-2 \</span><br><span class="line">-p 9000:3306 \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">mysql:latest</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>-d</strong>：后台运行</li><li><strong>—name</strong>：设置容器名称</li><li><strong>-p</strong>：将主机的9000端口绑定到容器的3306端口，<strong>-p格式：主机(宿主)端口:容器端口</strong></li><li><strong>-e</strong>：设置root用户密码</li><li><strong>mysql:latest</strong>：指定镜像和版本</li></ul><h3 id="2-2、数据用户密码加密机制"><a href="#2-2、数据用户密码加密机制" class="headerlink" title="2.2、数据用户密码加密机制"></a>2.2、数据用户密码加密机制</h3><p><strong>mysql8及以上</strong>，需要使用navicat链接的话需要修改用户密码的加密方式，该版本有修改：<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'password';</span><br></pre></td></tr></tbody></table></figure><br>修改后可查看 mysql库下的user表：<p></p><blockquote><p>mysql&gt; select host,user,plugin from user;<br>+—————-+—————————+———————————-+<br>| host      | user             | plugin                |<br>+—————-+—————————+———————————-+<br>| %         | root             | mysql_native_password |<br>| localhost | mysql.infoschema | caching_sha2_password |<br>| localhost | mysql.session    | caching_sha2_password |<br>| localhost | mysql.sys        | caching_sha2_password |<br>+—————-+—————————+———————————-+<br>4 rows in set (0.01 sec)</p></blockquote><h2 id="三、文件挂载"><a href="#三、文件挂载" class="headerlink" title="三、文件挂载"></a>三、文件挂载</h2><p>以为启动容器，但文件及配置信息均在容器内部，为了防止数据丢失可将容器内文件挂在到宿主机上，命令如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将容器中的 mysql 配置文件复制到宿主机中指定路径下，路径你可以根据需要，自行修改</span></span><br><span class="line">docker <span class="built_in">cp</span> mysql:/etc/mysql/mysql.conf.d/mysqld.cnf /usr/local/docker/mysql/config</span><br><span class="line"><span class="comment"># 将容器中的 mysql 存储目录复制到宿主机中</span></span><br><span class="line">docker <span class="built_in">cp</span> mysql:/var/lib/mysql/ /usr/local/docker/mysql/data</span><br></pre></td></tr></tbody></table></figure><p></p><p>总和挂在一起创建及启动容器的命令如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name mysql \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">-v /usr/local/docker/mysql/config/mysqld.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf \</span><br><span class="line">-v /usr/local/docker/mysql/data/mysql:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">mysql:latest</span><br></pre></td></tr></tbody></table></figure><br>其余命令不变，多了两个 <strong>-v</strong> 参数用于文件挂载。<br>后续即可直接使用数据库。<p></p><h2 id="MySQL配置文件"><a href="#MySQL配置文件" class="headerlink" title="MySQL配置文件"></a>MySQL配置文件</h2><p>通过 <strong>mysql —help</strong> 可以获得以下描述：</p><blockquote><p>Default options are read from the following files in the given order:<br>/etc/my.cnf /etc/mysql/my.cnf /usr/etc/my.cnf ~/.my.cnf</p></blockquote><p><strong>/etc/my.cnf</strong> 文件结尾处：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!includedir /etc/mysql/conf.d/</span><br><span class="line">!includedir /etc/mysql/mysql.conf.d/</span><br></pre></td></tr></tbody></table></figure><p></p><p>所以几处的配置文件按照顺序都会加载到mysql中，所以只需求一处即可，因此本文挂载文件为：<strong>/etc/mysql/mysql.conf.d/mysqld.cnf</strong></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL主从、主主、主备模式</title>
      <link href="/posts/30e0af.html"/>
      <url>/posts/30e0af.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、主从、主主、主备模式介绍"><a href="#一、主从、主主、主备模式介绍" class="headerlink" title="一、主从、主主、主备模式介绍"></a>一、主从、主主、主备模式介绍</h2><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/mysql/MySQL主主、主从、主备、单点模型.png" alt="主从、主主、主备模式">  </p><p>主从、主主、主备的基层逻辑都是数据的同步，而主从则将相关的数据同步机制全涉及，所以数据同步逻辑以解析主从逻辑为主。</p><p><strong>mysql主从配置分为三种模式，分别是：</strong></p><ul><li>异步复制（Asynchronous replication）：即使用二进制日志文件进行异步操作。master在执行完事后会直接给返回客户端，不考虑从库同步是否完成，从库的同步操做是通过异步线程读取二进制日志文件完成的。</li><li>全同步复制（Fully synchronous replication）：指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。</li><li>半同步复制（Semisynchronous replication）：介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP/IP往返的时间。所以，半同步复制最好在低延时的网络中使用。</li></ul><h2 id="二、主从同步——异步复制（Asynchronous-replication）"><a href="#二、主从同步——异步复制（Asynchronous-replication）" class="headerlink" title="二、主从同步——异步复制（Asynchronous replication）"></a>二、主从同步——异步复制（Asynchronous replication）</h2><h3 id="2-1、异步复制——原理"><a href="#2-1、异步复制——原理" class="headerlink" title="2.1、异步复制——原理"></a>2.1、异步复制——原理</h3><h4 id="2-1-1、复制线程"><a href="#2-1-1、复制线程" class="headerlink" title="2.1.1、复制线程"></a>2.1.1、复制线程</h4><p>MySQL 复制功能使用三个主线程实现，一个在源服务器上，两个在副本上：</p><ul><li><p><strong>二进制日志转储线程（Binary log dump thread）</strong>：当副本连接时，源创建一个线程以将二进制日志内容发送到副本。该线程可以在 <strong>SHOW PROCESSLIST</strong> 源上的输出中标识为该Binlog Dump线程。<br>二进制日志转储线程获取源二进制日志上的锁，以读取要发送到副本的每个事件。一旦事件被读取，锁就会被释放，甚至在事件被发送到副本之前。<br>具备多个从库的主库会为每个链接到主库的从库创建一个Binary log dump thread。</p></li><li><p><strong>复制 I/O 线程（Replication I/O thread）</strong>：当 <strong>START SLAVE</strong> 在副本服务器上发出语句时，副本会创建一个 I/O 线程，该线程连接到源并要求它发送记录在其二进制日志中的更新。<br>复制 I/O 线程读取源 Binlog Dump线程发送的更新（参见上一项）并将它们复制到组成 <strong>副本中继日志的本地文件中</strong>。<br>该线程的状态：可以通过<strong>SHOW SLAVE STATUS</strong>语句查询 <strong>Slave_IO_running</strong>字段的状态值。</p></li><li><p><strong>复制 SQL 线程（Replication SQL thread）</strong>。  副本创建一个 SQL 线程来读取由复制 I/O 线程写入的中继日志并执行其中包含的事务。</p></li></ul><h4 id="2-1-2、主从复制流程图"><a href="#2-1-2、主从复制流程图" class="headerlink" title="2.1.2、主从复制流程图"></a>2.1.2、主从复制流程图</h4><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/mysql/主从同步流程图.jpeg" alt="主从复制流程图"> </p><h3 id="2-2、异步复制——配置"><a href="#2-2、异步复制——配置" class="headerlink" title="2.2、异步复制——配置"></a>2.2、异步复制——配置</h3><h4 id="2-2-1、编码值设置"><a href="#2-2-1、编码值设置" class="headerlink" title="2.2.1、编码值设置"></a>2.2.1、编码值设置</h4><p>主从同步或多数据源同步时，一定要保证多个数据的编码值一致，否则在同步阶段会出现乱码，甚至无法解析的情况。编码设置如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysqld.cnf</span></span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line"><span class="comment"># 客户端设置</span></span><br><span class="line">default_character_set=utf8mb4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 服务端设置</span></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line">collation-server=utf8mb4_general_ci</span><br></pre></td></tr></tbody></table></figure><br>主从库均需要设置编码。<p></p><h4 id="2-2-2、主库配置"><a href="#2-2-2、主库配置" class="headerlink" title="2.2.2、主库配置"></a>2.2.2、主库配置</h4><p><strong>主库设置分为：server-id设置、二进制日志设置、同步用户设置等三部。</strong></p><h5 id="1-服务ID"><a href="#1-服务ID" class="headerlink" title="1. 服务ID"></a>1. 服务ID</h5><p>要将源配置为使用基于二进制日志文件位置的复制，必须确保启用二进制日志记录，并建立唯一的服务ID。并且必须是介于 1 和 (2 32 )-1 之间的正整数。<br>使用默认服务器 ID 为 0，且拒绝来自副本的任何连接，所以必须保证服务ID各个数据库服务不重复且大于0。配置如下：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务唯一ID</span></span><br><span class="line">server-id=9000</span><br></pre></td></tr></tbody></table></figure><p></p><h5 id="2-二进制日志（binlog）"><a href="#2-二进制日志（binlog）" class="headerlink" title="2. 二进制日志（binlog）"></a>2. 二进制日志（binlog）</h5><h6 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a><strong>日志格式</strong></h6><p><strong>binlog日志</strong>：数据库每提交一次事务，都会把数据变更，记录到一个二进制文件中，这个二进制文件就叫binlog。需注意：只有写操作才会记录至binlog，只读操作是不会的（如select、show语句）。<br><strong>binlog的3种格式：</strong><br><strong>1. statement格式：</strong> <strong>MySQL</strong> 中的复制功能最初是基于 <strong>SQL</strong> 语句从源到副本的传播，即记录的是实际执行的sql语句。这称为 <strong>基于语句的日志记录</strong>。</p><ul><li>优点：<ul><li>成熟的技术</li><li>写入日志文件的数据更少。当更新或删除影响许多行时，这会导致 日志文件所需的存储空间大大减少。</li><li>日志文件包含进行任何更改的所有语句，因此它们可用于审计数据库。</li></ul></li><li>缺点：<ul><li>对 SBR 不安全的语句。</li><li><strong>INSERT … SELECT</strong> 与基于行的复制相比，它需要更多的行级锁。</li><li><strong>UPDATE</strong> 需要表扫描的语句（因为 WHERE子句中没有使用索引）必须锁定比基于行的复制更多的行。</li><li>For InnoDB： INSERT使用 AUTO_INCREMENT阻塞其他非冲突语句的INSERT 语句。</li><li>对于复杂的语句，在更新或插入行之前，必须在副本上评估和执行该语句。使用基于行的复制，副本只需要修改受影响的行，而不是执行完整的语句。</li><li>如果对副本的评估存在错误，尤其是在执行复杂语句时，基于语句的复制可能会随着时间的推移慢慢增加受影响行的误差幅度。</li><li>存储函数以与 NOW()调用语句相同的值执行。但是，存储过程并非如此。</li><li>确定性可加载函数必须应用于副本。</li><li>表定义在源和副本上必须（几乎）相同。</li></ul></li></ul><p><strong>2. row格式：</strong> binlog记录的是变化前后的数据（涉及所有列），例如update table_a set col1=value1, col2=value2 … where col1=condition1 and col2=condition2 …，这称为 <strong>基于行的日志记录</strong>。</p><ul><li>优点：<ul><li>所有更改都可以复制。这是最安全的复制形式。</li><li>INSERT对于任何、UPDATE或 DELETE语句，副本上需要的行锁更少。</li><li>对于以下类型的语句，源上需要更少的行锁，从而实现更高的并发性：<ul><li>INSERT … SELECT</li><li>INSERT与声明 AUTO_INCREMENT</li><li>UPDATE或 带有不使用键或不更改大多数检查行的子句的 DELETE语句 。WHERE</li></ul></li></ul></li><li>缺点：<ul><li><strong>RBR</strong> 可以生成更多必须记录的数据。</li><li>生成大  <strong>BLOB</strong> 值的确定性可加载函数使用基于行的复制进行复制比使用基于语句的复制花费更长的间。这是因为 BLOB记录的是列值，而不是生成数据的语句。</li><li>无法在副本上看到从源接收并执行了哪些语句。</li><li>对于使用存储引擎的表，与将它们作为语句应用时相比，将它们作为基于行的事件应用到二进制日志时，语句<strong>MyISAM</strong>的副本需要更强的锁定。INSERT这意味着MyISAM在使用基于行的复制时不支持对表进行并发插入。</li></ul></li></ul><p><strong>3. mixed格式</strong>：默认选择statement格式，只在需要时改用row格式。这称为 <strong>混合日志记录</strong>。</p><p><strong>为获取前后变化的数据，建议使用 <font color="red">基于行的日志记录</font>，具体配置信息如下：</strong><br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 配置bin-log信息</span></span><br><span class="line"><span class="comment"># 日志文件名</span></span><br><span class="line">log-bin=master-bin</span><br><span class="line">log_bin_index = master-bin.index</span><br><span class="line"><span class="comment"># 日志格式</span></span><br><span class="line">binlog_format=row</span><br><span class="line"><span class="comment"># 日志保存天数</span></span><br><span class="line">expire-logs-days=7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 mysql 8.0.x 引进的，单位：秒</span></span><br><span class="line"><span class="comment"># binlog_expire_logs_seconds=2592000</span></span><br></pre></td></tr></tbody></table></figure><p></p><h6 id="同步过滤"><a href="#同步过滤" class="headerlink" title="同步过滤"></a><strong>同步过滤</strong></h6><p>基于业务情况，我们的数据库中并不是所有的库都需要进行复制同步。所以在开启同步前需要指定哪些库是需要进行同步操作的，即同步过滤。同步过滤有两种方式可以设置，分别是直接指定过滤库以及通过指定库记录二进制日志的方式，两种方式情况如下：</p><ul><li>指定复制库方式<ul><li>同步：<strong>replicate-do-db=db_name</strong></li><li>不同步：<strong>replicate-ignore-db=db_name</strong></li></ul></li><li>记录二进制方式：<ul><li>加入记录即同步：<strong>binlog-do-db=db_name</strong></li><li>不加入记录即不同步：<strong>binlog-ignore-db=db_name</strong></li></ul></li></ul><p><strong>两种方式区别：</strong></p><ul><li>相同点：都可以达到过滤的目的；可每个库需单独配置，可配置多个</li><li>不同点：针对日志的解析和复制有细微区别，详细可查看 <a href="https://dev.mysql.com/doc/refman/5.7/en/replication-options-binary-log.html#replication-optvars-binlog">二进制日志记录选项和变量</a></li></ul><p>配置示例：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 需要同步的数据库</span></span><br><span class="line">binlog-do-db=test_sync</span><br><span class="line"><span class="comment"># 不需要同步的库</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=sys</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line">binlog-ignore-db=performance_schema</span><br></pre></td></tr></tbody></table></figure><p></p><h5 id="3-为复制创建用户"><a href="#3-为复制创建用户" class="headerlink" title="3. 为复制创建用户"></a>3. 为复制创建用户</h5><p>每个从库都需要用于读取master库日志的账户信息，前提是它已被授予 <strong>REPLICATION SLAVE</strong> 特权。虽然可以直接使用root用户，但还是建议单独创建一个独立用户用于从库同步，因为 <strong>复制用户名和密码以纯文本形式存储在复制元数据存储库（slave的mysql.slave_master_info表）中</strong>。<br>创建用户示例：如果只是为了同步数据，该账户只需要 <strong>REPLICATION SLAVE</strong> 权限即可<br></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'slave_read'</span>@<span class="string">'%'</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">'password'</span>;</span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">'slave_read'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="2-2-3、从库及同步机制配置"><a href="#2-2-3、从库及同步机制配置" class="headerlink" title="2.2.3、从库及同步机制配置"></a>2.2.3、从库及同步机制配置</h4><p>主库设置好之后，进入从库配置及主从同步机制配置</p><h5 id="1-设置从库配置"><a href="#1-设置从库配置" class="headerlink" title="1. 设置从库配置"></a>1. 设置从库配置</h5><ul><li>编码设置</li><li>服务ID：设置服务ID，原因同主库。</li><li>日志：副本不需要启用二进制日志记录以进行复制。但是，副本上的二进制日志记录意味着副本的二进制日志可用于数据备份和崩溃恢复。启用了二进制日志记录的副本也可以用作更复杂的复制拓扑的一部分。</li><li>配置如下：<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端设置编码字符集为UTF8mb4</span></span><br><span class="line">[client]</span><br><span class="line">default_character_set=utf8mb4</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 服务端设置编码</span></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line">collation-server=utf8mb4_general_ci</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务唯一ID</span></span><br><span class="line">server-id=9001</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置bin-log信息</span></span><br><span class="line"><span class="comment"># 日志文件名</span></span><br><span class="line">log-bin=slave-bin</span><br><span class="line">log_bin_index=slave-bin.index</span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="2-从库设置主库链接信息"><a href="#2-从库设置主库链接信息" class="headerlink" title="2. 从库设置主库链接信息"></a>2. 从库设置主库链接信息</h5><p>要将从库设置为与主库通信，则要进行必要的连接信息配置，主要分为三个模块：</p><ul><li>主库ip，port等信息</li><li>主库用户同步的账户信息</li><li>二进制相关信息。</li></ul><p>主库ip、port和账户信息在上面已经获取或配置好，下面获取主库的二进制日志相关的信息，获取脚本如下：<br></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> MASTER STATUS;</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>查询结果如下：</strong>   </p><div class="table-container"><table><thead><tr><th style="text-align:left">File</th><th style="text-align:left">Position</th><th style="text-align:left">Binlog_Do_DB</th><th style="text-align:left">Binlog_Ignore_DB</th></tr></thead><tbody><tr><td style="text-align:left">master-bin.000001</td><td style="text-align:left">86</td><td style="text-align:left">cm_sync</td><td style="text-align:left">mysql,sys,information_schema,performance_schema</td></tr></tbody></table></div><ul><li>File：显示日志文件的名称，表格中二进制日志文件是mysql-bin.000001</li><li>Position：显示文件中的位置。表格中位置是位置是 86</li><li>Binlog_Do_DB：启用二进制日志的库</li><li>Binlog_Ignore_DB：未启用二进制日志的库</li></ul><p><strong>File和Position</strong> 稍后在设置副本时需要它们。它们表示副本应该开始处理来自源的新更新的复制坐标。</p><p>通过 <strong>CHANGE MASTER TO</strong> （更多信息请查看官方文档：<a href="https://dev.mysql.com/doc/refman/5.7/en/change-master-to.html">CHANGE MASTER TO 语句</a>）语句进行设置，登录MySQL数据，执行以下Sql：<br></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> CHANGE MASTER <span class="keyword">TO</span> MASTER_HOST <span class="operator">=</span> <span class="string">'172.17.0.2'</span>,</span><br><span class="line">    MASTER_USER <span class="operator">=</span> <span class="string">'slave_read'</span>,</span><br><span class="line">    MASTER_PASSWORD <span class="operator">=</span> <span class="string">'123456'</span>,</span><br><span class="line">    MASTER_PORT <span class="operator">=</span> <span class="number">3306</span>,</span><br><span class="line">    MASTER_LOG_FILE <span class="operator">=</span> <span class="string">'master-bin.000001'</span>,</span><br><span class="line">    MASTER_LOG_POS <span class="operator">=</span> <span class="number">86</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>此处只使用几个常用参数：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">含义</th><th style="text-align:left">最大长度</th></tr></thead><tbody><tr><td style="text-align:left">MASTER_HOST</td><td style="text-align:left">主库IP</td><td style="text-align:left">60</td></tr><tr><td style="text-align:left">MASTER_USER</td><td style="text-align:left">用于连接主库的用户</td><td style="text-align:left">96</td></tr><tr><td style="text-align:left">MASTER_PASSWORD</td><td style="text-align:left">用于连接主库的密码</td><td style="text-align:left">32</td></tr><tr><td style="text-align:left">MASTER_PORT</td><td style="text-align:left">主库端口</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">MASTER_LOG_FILE</td><td style="text-align:left">日志文件名称</td><td style="text-align:left">511</td></tr><tr><td style="text-align:left">MASTER_LOG_POS</td><td style="text-align:left">日志文件中的位置</td><td style="text-align:left"></td></tr></tbody></table></div><blockquote><p>注：如果使用docker部署mysql，则ip为容器的ip，端口为容器内部mysql端口。MASTER_LOG_POS参数一定要与主库查询出来的结果一致，否则无法同步。</p></blockquote><h5 id="3-新的主库和从库配置"><a href="#3-新的主库和从库配置" class="headerlink" title="3. 新的主库和从库配置"></a>3. 新的主库和从库配置</h5><p>无历史数据，全新的主库和从库，上面两步配置完毕后，直接启动复制线程：<br></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> SLAVE;</span><br></pre></td></tr></tbody></table></figure><br>执行此过程后，从库将连接到主库并复制自拍摄快照以来在主库上发生的任何更新。<p></p><h5 id="4-使用现有数据设置复制"><a href="#4-使用现有数据设置复制" class="headerlink" title="4. 使用现有数据设置复制"></a>4. 使用现有数据设置复制</h5><p>针对已有数据的主库，主从启动之前需要先将主库数据通过快照方式导入从库，以便数据同步。<br>步骤如下：</p><ul><li><p>1、先锁定主库，以防止数据新增遗漏</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> FLUSH TABLES <span class="keyword">WITH</span> READ LOCK;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>1、此过程使用FLUSH TABLES WITH READ LOCK, 阻止 表COMMIT的操作 InnoDB。<br>2、 FLUSH TABLES语句的客户端保持运行，以便读取锁保持有效。如果退出客户端，锁就会被释放。</p></blockquote></li><li><p>2、创建数据快照</p><ul><li>使用 <strong><a href="https://dev.mysql.com/doc/refman/5.7/en/mysqldump.html">mysqldump</a></strong> 创建数据快照：<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="comment">--all-databases --master-data &gt; dbdump.db</span></span><br></pre></td></tr></tbody></table></figure></li><li>使用原始数据文件创建数据快照</li></ul></li><li><p>3、重新启动源服务器。</p></li><li>4、在从库导入快照数据</li><li>5、启动复制线程</li><li>6、解锁<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> UNLOCK TABLES;</span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="5-将新的从库添加到复制拓扑"><a href="#5-将新的从库添加到复制拓扑" class="headerlink" title="5. 将新的从库添加到复制拓扑"></a>5. 将新的从库添加到复制拓扑</h5><p>可以在不停止源服务器的情况下将另一个副本添加到现有复制配置。方式为通过复制现有副本的数据目录来设置新副本，并为新副本提供不同的 <strong>服务器 ID（由用户指定）</strong>和 <strong>服务器 UUID（在启动时生成）</strong>。</p><ul><li><p>1、停止现有副本并记录副本状态信息，特别是源的二进制日志文件和中继日志文件位置。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> STOP SLAVE;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> SLAVE STATUS</span><br></pre></td></tr></tbody></table></figure></li><li><p>2、关闭现有副本</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="operator">&gt;</span> mysqladmin shutdown</span><br></pre></td></tr></tbody></table></figure></li><li><p>3、将现有副本的数据目录复制到新副本，包括日志文件和中继日志文件。可以通过使用tar或创建存档来执行此操作 ，或者使用cp或rsyncWinZip等工具执行直接复制 。</p><ul><li>在复制之前，请验证与现有副本相关的所有文件实际上都存储在数据目录中。例如，InnoDB 系统表空间、撤消表空间和重做日志可能存储在其他位置。</li><li>在复制期间，如果文件已用于复制元数据存储库，确保还将这些文件从现有副本复制到新副本。如果表已用于存储库，则表位于数据目录中。</li><li>复制后，从新副本上的数据目录副本中删除该 auto.cnf文件，以便新副本以不同的生成服务器 UUID 启动。服务器 UUID 必须是唯一的。</li></ul></li><li><p>4、复制完成后，重新启动现有副本。</p></li><li><p>5、在新副本上，编辑配置并为新副本提供唯一的服务器 ID（使用 server_id系统变量），源或任何现有副本均未使用该 ID。</p></li><li><p>6、启动新的副本服务器，指定 —skip-slave-start选项以便复制尚未开始。使用性能模式复制表或问题SHOW SLAVE STATUS来确认新副本与现有副本相比具有正确的设置。还要显示服务器 ID 和服务器 UUID，并验证这些对于新副本是否正确且唯一。</p></li><li>7、通过发出一条 <strong>START SLAVE</strong> 语句来启动复制线程。</li></ul><h4 id="2-2-4、从库状态查询"><a href="#2-2-4、从库状态查询" class="headerlink" title="2.2.4、从库状态查询"></a>2.2.4、从库状态查询</h4><p>异步复制线程开启后，查看从库的相关状态：<br></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> SLAVE STATUS</span><br></pre></td></tr></tbody></table></figure><br><strong>结果中关键字段是：</strong><p></p><ul><li>Slave_IO_State：副本的当前状态。</li><li>Slave_IO_Running: 读取源二进制日志的I/O线程是否正在运行。执行完 <strong>START SLAVE</strong> 后为 <strong>Yes</strong>。</li><li>Slave_SQL_Running：用于执行中继日志中事件的SQL线程是否正在运行。与 I/O 线程一样，执行完 <strong>START SLAVE</strong> 后为 <strong>Yes</strong>。</li><li>Last_IO_Error, Last_SQL_Error: I/O 和 SQL 线程在处理中继日志时注册的最后一个错误。理想情况下，这些应该是空白的，表示没有错误。</li><li>Seconds_Behind_Master：复制 SQL 线程在处理源的二进制日志之后的秒数。较大的数字（或增加的数字）可能表明副本无法及时处理来自源的事件。</li></ul><p>在主库上进行状态查询的语句有：</p><ul><li><strong>SHOW PROCESSLIST</strong>：用于检查正在运行的进程列表。</li><li><strong>SHOW SLAVE HOSTS</strong>：显示有关副本的基本信息。</li></ul><h4 id="2-2-5、配置汇总"><a href="#2-2-5、配置汇总" class="headerlink" title="2.2.5、配置汇总"></a>2.2.5、配置汇总</h4><p><strong>主库配置</strong><br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysqld.cnf</span></span><br><span class="line">[client]</span><br><span class="line"><span class="comment"># 客户端设置编码字符集为UTF8mb4</span></span><br><span class="line">default_character_set=utf8mb4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 服务端设置编码</span></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line">collation-server=utf8mb4_general_ci</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务唯一ID</span></span><br><span class="line">server-id=9000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置bin-log信息</span></span><br><span class="line"><span class="comment"># 日志文件名</span></span><br><span class="line">log-bin=master-bin</span><br><span class="line">log_bin_index = master-bin.index</span><br><span class="line"><span class="comment"># 日志格式</span></span><br><span class="line">binlog_format=row</span><br><span class="line"><span class="comment"># 日志保存天数</span></span><br><span class="line">expire-logs-days=7</span><br><span class="line"><span class="comment"># 需要同步的数据库</span></span><br><span class="line"><span class="comment">#binlog-do-db=cm_sync</span></span><br><span class="line"><span class="comment"># 不需要同步的库</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=sys</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line">binlog-ignore-db=performance_schema</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>从库配置</strong><br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysqld.cnf</span></span><br><span class="line"><span class="comment"># 客户端设置编码字符集为UTF8mb4</span></span><br><span class="line">[client]</span><br><span class="line">default_character_set=utf8mb4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 服务端设置编码</span></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line">collation-server=utf8mb4_general_ci</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务唯一ID</span></span><br><span class="line">server-id=9001</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置bin-log信息</span></span><br><span class="line"><span class="comment"># 日志文件名</span></span><br><span class="line">log-bin=slave-bin</span><br><span class="line">log_bin_index=slave-bin.index</span><br><span class="line"></span><br><span class="line">relay_log=slave-relay-bin</span><br><span class="line">read_only=1</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="2-3、强一致性——GTID"><a href="#2-3、强一致性——GTID" class="headerlink" title="2.3、强一致性——GTID"></a>2.3、强一致性——GTID</h3><h4 id="2-3-1、GTID"><a href="#2-3-1、GTID" class="headerlink" title="2.3.1、GTID"></a>2.3.1、GTID</h4><p>GTID：<strong>全局事务标识符</strong> 是在源服务器（master）上创建并与提交的每个事务相关联的唯一标识符。这个标识符不仅对于它起源的服务器是唯一的，而且在给定的复制拓扑中的所有服务器中都是唯一的。<br>针对GTID相关操作可以分为两部分：</p><ul><li>客户端事务在master上提交：提交时它会被分配一个新的 GTID，前提是该事务已写入二进制日志。保证客户端事务具有单调递增的 GTID，生成的数字之间没有间隙。如果客户端事务没有写入二进制日志（例如，因为事务被过滤掉，或者事务是只读的），则不会在源服务器上为其分配 GTID。</li><li>同步复制事务：从库会根据主库日志中各个GTID对应的事务操作进行数据同步操作，且在主库上提交的事务只能在副本上应用一次，这有助于保证一致性。</li></ul><h5 id="GTID组成"><a href="#GTID组成" class="headerlink" title="GTID组成"></a>GTID组成</h5><p>GTID 表示为一对坐标，由冒号字符 ( : ) 分隔，如下所示：</p><blockquote><p>GTID = source_id:transaction_id</p></blockquote><p><strong>source_id</strong>：标识始发服务器 。通常，源 server_uuid用于此目的。<br><strong>transaction_id</strong>：是一个序列号，由在源上提交事务的顺序确定。其实就是一个自增序列，从1递增。</p><p>MySQL 系统表 <strong>mysql.gtid_executed</strong> 用于保存在 MySQL 服务器上应用的所有事务的分配 GTID，但存储在当前活动的二进制日志文件中的事务除外。</p><h4 id="2-3-2、使用-GTID-设置复制"><a href="#2-3-2、使用-GTID-设置复制" class="headerlink" title="2.3.2、使用 GTID 设置复制"></a>2.3.2、使用 GTID 设置复制</h4><p><strong>GTID</strong> 模式是基于开启二进制服务的基础上进行的，下面操作步骤均已 <strong>开启二进制日志为前提</strong>。</p><h5 id="1、同步服务器"><a href="#1、同步服务器" class="headerlink" title="1、同步服务器"></a>1、同步服务器</h5><p>将mysql服务设置为只读，保证操作期间无数据丢失。<br></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> @<span class="variable">@GLOBAL</span>.read_only <span class="operator">=</span> <span class="keyword">ON</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>等待所有正在进行的事务提交或回滚。然后，让副本赶上源。在继续之前确保副本已处理所有更新非常重要。</p><p>如果是新服务则直接从第三步开始</p><h5 id="2、停止所有服务器"><a href="#2、停止所有服务器" class="headerlink" title="2、停止所有服务器"></a>2、停止所有服务器</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt;  mysqladmin -uusername -p shutdown</span><br></pre></td></tr></tbody></table></figure><h5 id="3、开启主库和从库的GTID设置"><a href="#3、开启主库和从库的GTID设置" class="headerlink" title="3、开启主库和从库的GTID设置"></a>3、开启主库和从库的GTID设置</h5><p>开启方式增加配置文件：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">gtid_mode=ON</span><br><span class="line">enforce-gtid-consistency=ON</span><br></pre></td></tr></tbody></table></figure><br>主库和从库均需设置，设置后重启mysql服务。<p></p><h5 id="4、将副本配置为使用基于-GTID-的自动定位"><a href="#4、将副本配置为使用基于-GTID-的自动定位" class="headerlink" title="4、将副本配置为使用基于 GTID 的自动定位"></a>4、将副本配置为使用基于 GTID 的自动定位</h5><p>在副本上发出一条 <strong>CHANGE MASTER TO</strong> 语句，包括 <strong>MASTER_AUTO_POSITION</strong> 在语句中告诉副本源的事务由 GTID 标识的选项。如果除 <strong>MASTER_AUTO_POSITION</strong> 参数外其它参数均已设置，则可以不进行重复设置。</p><blockquote><font color="red">MASTER_LOG_FILE选项和 选项 都MASTER_LOG_POS不能与 MASTER_AUTO_POSITION=1 一起使用。尝试这样做会导致CHANGE MASTER TO语句失败并出现错误。</font></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> CHANGE MASTER <span class="keyword">TO</span></span><br><span class="line">     <span class="operator">&gt;</span>     MASTER_HOST <span class="operator">=</span> host,</span><br><span class="line">     <span class="operator">&gt;</span>     MASTER_PORT <span class="operator">=</span> port,</span><br><span class="line">     <span class="operator">&gt;</span>     MASTER_USER <span class="operator">=</span> <span class="keyword">user</span>,</span><br><span class="line">     <span class="operator">&gt;</span>     MASTER_PASSWORD <span class="operator">=</span> password,</span><br><span class="line">     <span class="operator">&gt;</span>     MASTER_AUTO_POSITION <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><h5 id="5、启动复制线程并禁用只读模式"><a href="#5、启动复制线程并禁用只读模式" class="headerlink" title="5、启动复制线程并禁用只读模式"></a>5、启动复制线程并禁用只读模式</h5><p>启动复制线程：<br></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> SLAVE;</span><br></pre></td></tr></tbody></table></figure><p></p><p>仅当在 <strong>步骤 1</strong> 中将服务器配置为只读时，才需要执行以下步骤。要允许服务器再次开始接受更新，请发出以下语句：<br></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> @<span class="variable">@GLOBAL</span>.read_only <span class="operator">=</span> OFF;</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="2-3-3、使用-GTID-复制的限制"><a href="#2-3-3、使用-GTID-复制的限制" class="headerlink" title="2.3.3、使用 GTID 复制的限制"></a>2.3.3、使用 GTID 复制的限制</h4><p>因为基于 GTID 的复制依赖于事务，所以在使用 MySQL 时不支持一些原本在 MySQL 中可用的特性。相关限制如下：</p><ul><li>涉及非事务性存储引擎的更新。 </li><li>CREATE TABLE … SELECT 语句。基于 GTID 的复制时不允许使用语句。</li><li>临时表。  使用 GTID 时（即当 系统变量设置为时），事务、过程、函数和触发器中不支持CREATE TEMPORARY TABLE和 语句。</li><li>防止执行不受支持的语句。  为了防止执行会导致基于 GTID 的复制失败的语句，所有服务器都必须 —enforce-gtid-consistency在启用 GTID 时使用该选项启动。</li><li>跳过交易。  sql_slave_skip_counter使用 GTID 时不支持。</li><li>忽略服务器。  使用 GTID 时不推荐使用该语句的 IGNORE_SERVER_IDS 选项CHANGE MASTER TO，因为已应用的事务将被自动忽略。</li></ul><h2 id="三、主从同步——半同步复制（Semisynchronous-replication）"><a href="#三、主从同步——半同步复制（Semisynchronous-replication）" class="headerlink" title="三、主从同步——半同步复制（Semisynchronous replication）"></a>三、主从同步——半同步复制（Semisynchronous replication）</h2><p>主从同步的三种机制分别是异步、半同步、全同步，异步逻辑已经分析完了，下面看下半同步和全同步。先了解下全同步。</p><p><strong>全同步（完全同步复制）</strong>：当源提交事务时，所有副本也必须在源返回到执行事务的会话之前提交事务。即master每次提交都要等所有副本接收并记录了事件，所有副本都通知master记录成功，master才能提交本次事务。</p><ul><li>优点：完全同步复制意味着可以随时从源故障转移到任何副本。</li><li>缺点完全同步复制的缺点是完成事务可能会有很多延迟。</li></ul><p><strong>半同步复制（Semisynchronous Replication）</strong>：介于异步复制和完全同步复制之间。源等待直到至少一个副本接收并记录了事件（所需的副本数量是可配置的），然后提交事务。源不等待所有副本确认接收，它只需要来自副本的确认，而不是事件已在副本端完全执行并提交。因此，半同步复制保证如果源崩溃，它已提交的所有事务都已传输到至少一个副本。</p><ul><li>与完全同步复制相比，半同步复制更快，因为它可以配置为平衡您对数据完整性的要求（确认收到事务的副本数）和提交速度，提交速度由于需要等待而较慢复制品。</li><li>与异步复制相比，半同步复制的性能影响是提高数据完整性的权衡。</li></ul><p><strong>源与其副本之间的半同步复制操作如下：</strong></p><ul><li>副本在连接到源时指示它是否具有半同步能力。</li><li>如果在源端启用了半同步复制并且至少有一个半同步副本，则在源上执行事务提交的线程会阻塞并等待，直到至少一个半同步副本确认它已收到事务的所有事件，或者直到发生超时。</li><li>只有在将事件写入其中继日志并刷新到磁盘后，副本才会确认收到事务的事件。</li><li>如果在没有任何副本确认事务的情况下发生超时，则源将恢复为异步复制。当至少一个半同步副本赶上时，源返回到半同步复制。</li><li>必须在源端和副本端都启用半同步复制。如果在源上禁用半同步复制，或者在源上启用但没有副本，则源使用异步复制。</li></ul><h3 id="3-1、半同步实现"><a href="#3-1、半同步实现" class="headerlink" title="3.1、半同步实现"></a>3.1、半同步实现</h3><p>半同步复制是使用插件实现的，因此必须将插件安装到服务器中以使其可用。安装插件后，可以通过与其关联的系统变量来控制它。</p><h4 id="3-1-1、插件安装"><a href="#3-1-1、插件安装" class="headerlink" title="3.1.1、插件安装"></a>3.1.1、插件安装</h4><h5 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h5><p>服务器插件必须先加载到服务器中才能使用。MySQL 支持在服务器启动和运行时加载插件。还可以在启动时控制已加载插件的激活状态，并在运行时卸载它们。</p><p><strong>INSTALL PLUGIN</strong> 语句安装的插件：</p><ul><li>位于插件库文件中的插件可以在运行时使用该 <strong>INSTALL PLUGIN</strong> 语句加载。</li><li>该语句还在 mysql.plugin表中注册插件，以使服务器在后续重新启动时加载它。</li><li>插件库文件的基本名称取决于您的平台。常见的后缀 <strong>.so</strong> 适用于 Unix 和类 Unix 系统，<strong>.dll</strong> 适用于 Windows。</li></ul><h5 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h5><p><strong>安装语句：</strong><br></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 基于mac环境</span></span><br><span class="line"><span class="comment">-- 主库</span></span><br><span class="line">INSTALL PLUGIN rpl_semi_sync_master SONAME <span class="string">'semisync_master.so'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从库</span></span><br><span class="line">INSTALL PLUGIN rpl_semi_sync_slave SONAME <span class="string">'semisync_slave.so'</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>安装查看</strong></p><ul><li>可以查看 <strong>INFORMATION_SCHEMA.PLUGINS</strong> 表</li><li>使用 <strong>SHOW PLUGINS</strong> 语句</li></ul><p>此处查看PLUGINS表信息<br></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">PLUGIN_NAME,</span><br><span class="line">PLUGIN_STATUS </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">INFORMATION_SCHEMA.PLUGINS </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">PLUGIN_NAME <span class="keyword">LIKE</span> <span class="string">'%semi%'</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>结果：</strong><br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/mysql/查看插件信息.png" alt="安装的插件信息"></p><h5 id="3、配置"><a href="#3、配置" class="headerlink" title="3、配置"></a>3、配置</h5><p>半同步相关的配置项主要使用以下几项：</p><ul><li><strong>rpl_semi_sync_master_enabled：</strong> 控制是否在源上启用半同步复制。要启用或禁用插件，请将此变量分别设置为 1 或 0。默认值为 0（关闭）。</li><li><strong>rpl_semi_sync_master_timeout：</strong> 一个以毫秒为单位的值，用于控制源在超时和恢复到异步复制之前等待来自副本的确认提交的时间。默认值为 10000（10 秒）。</li><li><strong>rpl_semi_sync_slave_enabled：</strong> 类似于 rpl_semi_sync_master_enabled，但控制副本插件。</li></ul><p>mysql实例运行时：<br></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 主库</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> rpl_semi_sync_master_enabled <span class="operator">=</span> {<span class="number">0</span><span class="operator">|</span><span class="number">1</span>};</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> rpl_semi_sync_master_timeout <span class="operator">=</span> N;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从库</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> rpl_semi_sync_slave_enabled <span class="operator">=</span> {<span class="number">0</span><span class="operator">|</span><span class="number">1</span>};</span><br></pre></td></tr></tbody></table></figure><p></p><p>如果在运行时在副本上启用半同步复制，则还必须启动复制 I/O 线程（如果它已经在运行，则首先停止它）以使副本连接到源并注册为半同步副本：<br></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STOP SLAVE IO_THREAD;</span><br><span class="line"><span class="keyword">START</span> SLAVE IO_THREAD;</span><br></pre></td></tr></tbody></table></figure><p></p><p>实例启动时配置文件配置：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主库</span></span><br><span class="line">[mysqld]</span><br><span class="line">rpl_semi_sync_master_enabled=1</span><br><span class="line">rpl_semi_sync_master_timeout=1000 <span class="comment"># 1 second</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从库</span></span><br><span class="line">[mysqld]</span><br><span class="line">rpl_semi_sync_slave_enabled=1</span><br></pre></td></tr></tbody></table></figure><br>自此半同步配置即完成<p></p><h2 id="四、延迟复制"><a href="#四、延迟复制" class="headerlink" title="四、延迟复制"></a>四、延迟复制</h2><p>MySQL 5.7 支持延迟复制，这样副本服务器故意滞后源至少指定的时间量。默认延迟为 0 秒。设置：<br></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- N 为延迟秒数</span></span><br><span class="line">CHANGE MASTER <span class="keyword">TO</span> MASTER_DELAY <span class="operator">=</span> N;</span><br></pre></td></tr></tbody></table></figure><br>从源接收到的事件直到在源上执行至少 N几秒钟后才会执行。例外情况是格式描述事件或日志文件轮换事件没有延迟，它们只影响 SQL 线程的内部状态。<p></p><p>作用：</p><ul><li>防止用户在源上出错。DBA 可以将延迟的副本回滚到灾难发生前的时间。</li><li>测试存在滞后时系统的行为。</li><li>检查数据库很久以前的样子，而无需重新加载备份。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 同步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java的future体系</title>
      <link href="/posts/9fca4482.html"/>
      <url>/posts/9fca4482.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、Future概念"><a href="#一、Future概念" class="headerlink" title="一、Future概念"></a>一、Future概念</h2><h3 id="1-1、概念"><a href="#1-1、概念" class="headerlink" title="1.1、概念"></a>1.1、概念</h3><p><font color="blue"> <strong><a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/concurrent/Future.html">Oracle官方文档</a></strong> </font> 针对Future接口解释如下：未来表示异步计算的结果。提供了检查计算是否完成，等待计算完成以及检索计算结果的方法。只有在计算完成时，才能使用方法 <strong>get()</strong> 检索结果，如有必要，在计算准备就绪之前将其阻止。取消由取消方法执行。</p><p>举个例子：发快递时的快递单号，整个快递过程中单号就是唯一的重要标识与凭证。<strong>Future</strong> 就类似于这个单号，在异步操作中，可以根据 <strong>Future</strong> 去提取相关的操作结果。所以<strong>Future</strong> 表示的是异步任务还没完成提前给出的未来结果。</p><h3 id="1-2、Future"><a href="#1-2、Future" class="headerlink" title="1.2、Future"></a>1.2、Future</h3><p>java中 Future 就是对于具体的 <strong>Runnable</strong> 或者 <strong>Callable</strong>（下面会详细介绍） 任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p><p><strong>代码定义</strong>：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; {</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>提供功能点：</strong></p><ul><li>cancel：用来取消任务，成功：true，失败：false。如果任务【已完成】或【未执行】或【被取消过】则返回false。<ul><li>参数 <strong>mayInterruptIfRunning</strong> 表示是否允许取消正在执行却没有执行完毕的任务。</li></ul></li><li>isCancelled：方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</li><li>isDone方法表示任务是否已经完成，若任务完成，则返回true；</li><li>get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</li><li>get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</li></ul><p><strong>也就是说Future提供了三种功能：</strong></p><ul><li>判断任务是否完成；</li><li>能够中断任务；</li><li>能够获取任务执行结果。<br>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。</li></ul><h3 id="1-2、与Thread区别"><a href="#1-2、与Thread区别" class="headerlink" title="1.2、与Thread区别"></a>1.2、与Thread区别</h3><p>常见的两种创建线程的方式。一种是直接继承Thread，另外一种就是实现Runnable接口。Future与这二者的唯一区别就是：<strong>Thread是没有返回结果的，而Future模式是有返回结果的。</strong></p><h2 id="二、Future使用"><a href="#二、Future使用" class="headerlink" title="二、Future使用"></a>二、Future使用</h2><p>先假设个场景，我们要做烧仙草奶茶。那么就需要分别把烧仙草和奶茶做好，然后再做出烧仙草奶茶，前面的烧仙草的制作和奶茶的制作都耗时不短，而且二者完全独立，所以可以有二者同时进行即有两个线程分别去制作。等均完成后进行最后的制作。<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    FutureTask&lt;String&gt; makeGrassJelly = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"开始制作烧仙草。。。。。"</span>);</span><br><span class="line">            <span class="comment">// 模拟制作耗时耗时</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span>  + <span class="string">"烧仙草已经做好了..."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"烧仙草"</span>;</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    executorService.submit(makeGrassJelly);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可使用如下方式，两种方式的效果一样，只不过一个使用的是ExecutorService，一个使用的是Thread</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Thread thread = new Thread(makeGrassJelly);</span></span><br><span class="line"><span class="comment">    thread.start();</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在制作烧仙草的同时制作奶茶</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span>  + <span class="string">" 烧仙草的线程已经开始，下面我们做奶茶..."</span>);</span><br><span class="line">    <span class="comment">// 模拟奶茶制作的耗时</span></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span>  + <span class="string">"奶茶准备好了"</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">milkTea</span> <span class="operator">=</span> <span class="string">"奶茶"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开水已经稍好，我们取得烧好的开水</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">grassJelly</span> <span class="operator">=</span> makeGrassJelly.get();</span><br><span class="line"></span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span>  + grassJelly  + milkTea + <span class="string">"：制作完成了，可以开吃了"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>执行结果：</p><blockquote><p>main: 烧仙草的线程已经开始，下面我们做奶茶…<br>pool-1-thread-1:开始制作烧仙草。。。。。<br>main:奶茶准备好了<br>pool-1-thread-1:烧仙草已经做好了…<br>main:烧仙草奶茶：制作完成了，可以开吃了</p></blockquote><p><strong>从demo可知，使用Future步骤如下：</strong></p><ul><li>新建一个Callable匿名函数实现类对象，我们的业务逻辑在Callable的call方法中实现，其中Callable的泛型是返回结果类型；</li><li>然后把Callable匿名函数对象作为FutureTask的构造参数传入，构建一个futureTask对象；</li><li>然后再把futureTask对象作为Thread构造参数传入并开启这个线程执行去执行业务逻辑；</li><li>最后我们调用futureTask对象的get方法得到业务逻辑执行结果。</li></ul><p>可以看到跟 Future 使用有关的JDK类主要有 <strong>FutureTask</strong> 和 <strong>Callable</strong> 两个，下面分别对对 <strong>Callable</strong> 和 <strong>FutureTask</strong> 进行源码分析。</p><h2 id="三、Callable"><a href="#三、Callable" class="headerlink" title="三、Callable"></a>三、Callable</h2><p>正式进入Future模式讲解前，先了解下预备知识之——Callable。</p><h3 id="3-1、Callable-介绍"><a href="#3-1、Callable-介绍" class="headerlink" title="3.1、Callable 介绍"></a>3.1、Callable 介绍</h3><p><strong>Callable：</strong> 代表一段可以调用并返回结果的代码；<strong>Future接口</strong> 表示异步任务，是还没有完成的任务给出的未来结果。所以说 <strong>Callable</strong> 用于产生结果，<strong>Future</strong> 用于获取结果。 </p><p><strong>代码声明</strong>：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，如果计算失败则抛出异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>可以看到，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。<br>一般情况下是配合 ExecutorService 来使用的，在 ExecutorService 接口中声明了若干个submit方法的重载版本：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></tbody></table></figure><br>第一个 <strong>submit</strong> 方法里面的参数类型就是 <strong>Callable</strong>。返回的是 <strong>Future</strong> 类型对象。<p></p><h3 id="3-2、与Runnable"><a href="#3-2、与Runnable" class="headerlink" title="3.2、与Runnable"></a>3.2、与Runnable</h3><ol><li><p>相同点</p><ul><li>都可以开发多线程。</li><li>都可以使用ExecutorService来执行。   </li></ul></li><li><p>不同点</p><ul><li>Callable有返回值，可以向上抛异常。Runnable不行。</li><li>都使用 ExecutorService 来执行，Callable 的返回值有意义，Runnable 的返回值为空。</li></ul></li></ol><h3 id="3-3、Callable执行"><a href="#3-3、Callable执行" class="headerlink" title="3.3、Callable执行"></a>3.3、Callable执行</h3><p><strong>Callable</strong> 的使用方式有两种一种是结合 <strong>ExecutorService</strong> 提交使用，一种是构建 <strong>FutureTask</strong> 对象来使用。</p><p>就先聊聊 Callable 的使用方法之一是：ExecutorService 的 submit 方法，那么我们就看下具体的执行逻辑和涉及的相关类型。</p><p><strong>异步执行demo</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeTask</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交带有返回值的任务以供执行，并返回表示任务挂起结果的 Future</span></span><br><span class="line">    <span class="type">Future</span> <span class="variable">submit</span> <span class="operator">=</span> executorService.submit(()-&gt;{</span><br><span class="line">        <span class="comment">//业务逻辑执行</span></span><br><span class="line">        log.info(<span class="string">"in callable!!!!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"callable"</span>;</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//获取执行结果</span></span><br><span class="line">        submit.get();</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        log.error(<span class="string">"==== Asynchronous execution exception"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>执行逻辑：</strong><br><strong>1. 获取 ExecutorService 实例</strong>：<br>获取 <strong>ExecutorService</strong> 实例，用于任务提交操作。<strong>newCachedThreadPool()</strong> 将返回 <strong>ThreadPoolExecutor</strong> 类型对象实例。</p><p><strong>2. submit() 提交任务</strong></p><ul><li>执行对象类型<br><strong>Executors.newCachedThreadPool()</strong> 产生的对象实例类型为 <strong>ThreadPoolExecutor</strong>。其继承实现模型为：<br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/java/多线程/ThreadPoolExecutor类结构模型.png" alt="ThreadPoolExecutor类结构模型"></li><li>方法调用源码分析<br>提交任务的方法 <strong>submit</strong> 由 <strong>ExecutorService</strong> 接口定义，在 <strong>AbstractExecutorService</strong> 里面实现。<strong>ThreadPoolExecutor</strong> 类没有再次覆盖实现。因此最终调用的代码逻辑为 AbstractExecutorService 内的逻辑，其实现逻辑如下：    </li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractExecutorService.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> {</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// newTaskFor实现</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(callable);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由源码可知，submit执行时：</p><ol><li>先将Callable接口实现转化为 <strong>FutureTask</strong> 类型对象。</li><li>然后再通过 <strong>execute</strong> 执行。  </li></ol><p>具体执行逻辑下面聊到 <strong>FutureTask</strong> 会详细说明。此处已经说明了 <strong>Callable 最终一定通过与 Future 结合进行使用</strong>，达到异步执行任务且返回相关结果的功能。所以两种执行方式的底层实现实为一种：即结合 <strong>FutureTask</strong> 进行使用。</p><p>那么接下来就聊聊 <strong>FutureTask</strong> 。</p><h2 id="四、FutureTask"><a href="#四、FutureTask" class="headerlink" title="四、FutureTask"></a>四、FutureTask</h2><h3 id="4-1、FutureTask类结构分析"><a href="#4-1、FutureTask类结构分析" class="headerlink" title="4.1、FutureTask类结构分析"></a>4.1、FutureTask类结构分析</h3><p>FutureTask的类结构：<br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/java/多线程/FutureTask类结构模型.png" alt="FutureTask类结构模型"></p><p>通过类图我们不难看出,<strong>RunnableFuture</strong> 继承了 <strong>Runable</strong> 以及 <strong>Future</strong> 接口，所以它即可以被线程异步执行，也可作为Future得到callable的计算结果。</p><p>下面进入正题聊聊 <strong>FutureTask</strong>，它实现了<strong>RunnableFuture</strong> 接口，所以也是 <strong>Future</strong> 和<strong>Runnable</strong> 接口的具体实现类，即异步任务执行后我们能够获取到异步任务的执行结果。</p><p>下面就详详细的通过源码分析下 <strong>FutureTask</strong> 的执行逻辑。</p><h3 id="4-2、源码分析——属性"><a href="#4-2、源码分析——属性" class="headerlink" title="4.2、源码分析——属性"></a>4.2、源码分析——属性</h3><p>先看下具体属性，这个在整体运行逻辑中都是很重要的。<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FutureTask.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Possible state transitions:</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment"> * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 任务执行状态标识</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义运行状态码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NEW</span>          <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COMPLETING</span>   <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORMAL</span>       <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCEPTIONAL</span>  <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span>    <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTING</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTED</span>  <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Callable对象实现，用于异步执行 */</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 从 get() 返回的结果或抛出的异常 */</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** 用来执行callable任务的线程 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 在 Treiber 中记录等待线程的简单链表节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// VarHandle mechanics</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle STATE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle RUNNER;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle WAITERS;</span><br></pre></td></tr></tbody></table></figure><br>根据Java并发工具类三板斧：<p></p><ul><li>状态</li><li>队列</li><li>CAS操作<br>从这个方面分别对不同的属性进行详细的解析。</li></ul><h4 id="4-2-1、属性——状态"><a href="#4-2-1、属性——状态" class="headerlink" title="4.2.1、属性——状态"></a>4.2.1、属性——状态</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FutureTask.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NEW</span>          <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COMPLETING</span>   <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORMAL</span>       <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCEPTIONAL</span>  <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span>    <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTING</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTED</span>  <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>FutureTask</strong> 中定义了七种状态，一种初始状态，四种终态，两种中间态，由 <strong>0-6</strong> 分别代表分别如下：</p><ol><li>初始状态：<ul><li>NEW：初始状态，这是由构造函数保证的。</li></ul></li><li>中间态：<strong>瞬间状态，而且此状态并不代表任务正执行，而是已经执行完成正（成功或失败异常）在设置返回结果</strong><ul><li>COMPLETING： 正在设置任务结果</li><li>INTERRUPTING： 正在中断运行任务的线程</li></ul></li><li>终态<ul><li>NORMAL：任务正常执行完毕</li><li>EXCEPTIONAL：任务执行过程中发生异常</li><li>CANCELLED：任务被取消</li><li>INTERRUPTED：任务被中断</li></ul></li></ol><p><strong>执行状态流转顺序如下</strong>：</p><ol><li><strong>NEW -&gt; COMPLETING -&gt; NORMAL</strong><ul><li>任务正常执行且完成设置返回结果。</li><li>状态由 <strong>set</strong> 方法设置。</li></ul></li><li><strong>NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</strong><ul><li>任务执行异常。</li><li>状态由 <strong>setException</strong> 方法设置。</li></ul></li><li><strong>NEW -&gt; CANCELLED</strong><ul><li>任务取消，即调用了 <strong>cancel(false)</strong></li><li>状态由 <strong>cancel</strong> 方法设置。</li></ul></li><li><strong>NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</strong><ul><li>任务取消，即调用了 <strong>cancel(true)</strong></li><li>状态由 <strong>cancel</strong> 方法设置。</li></ul></li></ol><p>因此涉及状态修改的只有 set、setException、cancel这三个方法，方法的具体逻辑后面再详细分析。</p><h4 id="4-2-2、属性——队列"><a href="#4-2-2、属性——队列" class="headerlink" title="4.2.2、属性——队列"></a>4.2.2、属性——队列</h4><p>聊队列时同时将其它相关操作的属性一块聊一聊，</p><ol><li><strong>处理逻辑（callable）</strong><br>包含具体的异步执行逻辑内容，整个生命周期从构造函数接收，到call()方法调用执行，到最后的移除销毁整个过程与线程的具体执行逻辑息息相关。后面聊到具体执行逻辑再分析。</li><li><strong>执行（runner）</strong><br>用来执行 callable 任务的线程，<strong>runner 属性是在运行时被初始化的。</strong> 简单点说，就是run方法被调用时赋值。</li><li><strong>结果（outcome）</strong><br>任务的执行结果，成功为 callable 内的返回结果，失败为异常对象。</li><li><strong>队列（waiters）</strong><br>所有等待任务执行完毕的线程的集合。</li></ol><p>在并发编程中使用队列通常是将 <strong>当前线程包装成某种类型的数据结构扔到等待队列中，</strong> 接下来看下waiters的结构定义：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WaitNode</span> {</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">    WaitNode() { thread = Thread.currentThread(); }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>简单的单项链表结构，仅有两个属性一个是当前线程 <strong>thread</strong>，一个是下一个队列节点对象 <strong>next</strong>。<p></p><ul><li><strong>thread</strong>：存放当前调用 <strong>FutureTask</strong> 内各相关方法的线程信息。</li><li><strong>next</strong>：指向下一个节点的next属性。</li></ul><p>根据 <strong>WaitNode</strong> 对象的数据结构和属性内容，可以很明显的知道它的作用，即：将当前线程信息存放至链表，按照 <strong>后进先出</strong> 的规则进行相关操作。</p><p>因为 <strong>Future</strong> 的 <strong>get()/get(timeout)</strong> 在 task 处于非完成状态时是需要 <strong>阻塞等待</strong> 的，如果多个线程进行 get 操作，显然需要一个链表/队列来维护这些等待线程，这就是waiters的意义所在。</p><p>简答模拟了一下五个线程同时调用 <strong>get()</strong> 方法，可看到当第5个线程进行时，<strong>队列（waiters）</strong> 已经有五个等待线程了：</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/java/多线程/Future-waiters模拟.png" alt="Future-waiters模拟"></p><p>其中 <strong>runner</strong> , <strong>waiters</strong> 和 <strong>state</strong> 都是用 <strong>volatile</strong> 关键字修饰，说明这三个变量都是多线程共享的对象（成员变量），会被多线程操作，此时用volatile关键字修饰是为了一个线程操作volatile属性变量值后，能够及时对其他线程可见。当然仅仅如此依旧存在线程安全的问题，所以其相关操作使用的CAS机制来确保线程的安全性。下面就聊下CAS。</p><h4 id="4-2-3、属性——CAS"><a href="#4-2-3、属性——CAS" class="headerlink" title="4.2.3、属性——CAS"></a>4.2.3、属性——CAS</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FutureTask.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle STATE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle RUNNER;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle WAITERS;</span><br><span class="line"><span class="keyword">static</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        MethodHandles.<span class="type">Lookup</span> <span class="variable">l</span> <span class="operator">=</span> MethodHandles.lookup();</span><br><span class="line">        STATE = l.findVarHandle(FutureTask.class, <span class="string">"state"</span>, <span class="type">int</span>.class);</span><br><span class="line">        RUNNER = l.findVarHandle(FutureTask.class, <span class="string">"runner"</span>, Thread.class);</span><br><span class="line">        WAITERS = l.findVarHandle(FutureTask.class, <span class="string">"waiters"</span>, WaitNode.class);</span><br><span class="line">    } <span class="keyword">catch</span> (ReflectiveOperationException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExceptionInInitializerError</span>(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从这个静态代码块中我们也可以看出，CAS操作主要针对3个属性，包括 <strong>STATE</strong>、<strong>RUNNER</strong> 和  <strong>WAITERS</strong>，说明这3个属性基本是会被多个线程同时访问的。其中 <strong>STATE</strong>属性代表了任务的状态，<strong>WAITERS</strong> 属性代表了指向栈顶节点的指针。<strong>RUNNER</strong> 主要是为了 <strong>中断或者取消任务</strong> 做准备的，只有知道了执行任务的线程是谁，我们才能去中断它。</p><p>具体的操作也是使用了CAS方法即 <strong>compareAndSet</strong> 来完成的。</p><h3 id="4-3、源码分析——构造函数"><a href="#4-3、源码分析——构造函数" class="headerlink" title="4.3、源码分析——构造函数"></a>4.3、源码分析——构造函数</h3><p>FutureTask有两个构造函数，分别看下源码：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数1</span></span><br><span class="line"><span class="comment">// FutureTask.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> {</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.callable = callable;</span><br><span class="line">    <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数2</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Runnable runnable, V result)</span> {</span><br><span class="line">    <span class="built_in">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>构造函数1很好理解，传入 <strong>Callable</strong> 的实现类，将参数赋值属性 <strong>callable</strong>，同时将状态 <strong>state</strong> 置为初始状态 <strong>NEW</strong>，代表新建任务状态。</p><p>接着看构造函数2，很明显的区别在于入参变成了 <strong>Runnable</strong> 实现类，且增加了返回结果的泛型集。然后将二者通过 <strong>Executors.callable()</strong> 方法转变成了 <strong>callable</strong> 类型，那么就进入方法具体看下源码：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FutureTask.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="title function_">callable</span><span class="params">(Runnable task, T result)</span> {</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt;(task, result);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;T&gt; {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable task;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T result;</span><br><span class="line"></span><br><span class="line">    RunnableAdapter(Runnable task, T result) {</span><br><span class="line">        <span class="built_in">this</span>.task = task;</span><br><span class="line">        <span class="built_in">this</span>.result = result;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">call</span><span class="params">()</span> {</span><br><span class="line">        task.run();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString() + <span class="string">"[Wrapped task = "</span> + task + <span class="string">"]"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>由源码可知，方法直接调用了 <strong>RunnableAdapter</strong> 的构造函数，这个方法采用了设计模式中的适配器模式，将一个Runnable类型对象适配成Callable类型。当然 <strong>result</strong> 参数的存在只是为了将一个Runnable 类型适配成 Callable 类型，确实没什么实际意义。   </p><h3 id="4-4、源码分析——执行-run方法"><a href="#4-4、源码分析——执行-run方法" class="headerlink" title="4.4、源码分析——执行(run方法)"></a>4.4、源码分析——执行(run方法)</h3><h4 id="4-4-1、执行-run方法-——执行逻辑"><a href="#4-4-1、执行-run方法-——执行逻辑" class="headerlink" title="4.4.1、执行(run方法)——执行逻辑"></a>4.4.1、执行(run方法)——执行逻辑</h4><p><strong>FutureTask</strong> 实现了 <strong>Runnable</strong>，覆写了 <strong>run</strong> 方法，即用于异步执行的线程逻辑。<strong>Callable</strong> 即是需要执行的业务逻辑，他是业务逻辑的基本表现形式，保存在类属性callable，在run函数里面，调用callalbe.call()来执行业务逻辑。下面从源码来了解具体的执行逻辑：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FutureTask.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">//1、判断是否满足执行条件，满足条件设置runner属性</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !RUNNER.compareAndSet(<span class="built_in">this</span>, <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 2、具体执行业务逻辑，根据执行情况做不同处理</span></span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="comment">// 执行前再次判断状态</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) {</span><br><span class="line">            V result;</span><br><span class="line">            <span class="comment">// 执行状态标识</span></span><br><span class="line">            <span class="type">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 具体业务执行</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="literal">true</span>;</span><br><span class="line">            } <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">                result = <span class="literal">null</span>;</span><br><span class="line">                ran = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 失败结果集设置</span></span><br><span class="line">                setException(ex);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">            <span class="comment">// 成功结果集设置</span></span><br><span class="line">                set(result);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">//3、执行完的后处理逻辑</span></span><br><span class="line">        runner = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>从源码可知，具体执行共三步：<p></p><ol><li>判断是否满足执行条件，满足条件设置runner属性<ul><li>判断任务状态是否为 <strong>NEW</strong> 状态，如果不是，则可能执行完毕或已经被取消，所以直接返回。</li><li>如果任务为 <strong>NEW</strong> 状态，则通过 <strong>CAS操作</strong> 将 <strong>runner</strong> 置为当前正在执行异步任务的线程。此处有两种情况：<ul><li><strong>runner!=null</strong>：则说明任务依旧处于NEW状态，但已经有线程在执行该任务，所以无需再次执行，CAS操作失败，直接返回。</li><li><strong>runner==null</strong> ：说明还未有线程执行过异步任务，此时满足执行异步任务的条件，CAS操作成功，继续执行任务。</li></ul></li></ul></li><li>具体执行，并根据结果进行相关操作<ul><li><strong>if (c != null &amp;&amp; state == NEW)</strong>：再次判断任务状态，状态为NEW则继续执行。</li><li><strong>result = c.call();</strong>：调用call()方法执行具体的业务逻辑，根据结果进行操作。<ul><li>失败则进入异常操作设置结果集 <strong>setException(ex)</strong>；并设置失败标识 <strong>ran = false</strong>。</li><li>成功则设置成功标识 <strong>ran = true</strong> ，并进行成功后结果集的设置 <strong>set(result)</strong>；</li></ul></li></ul></li><li>后处理逻辑<br>不管异步任务执行成功还是失败，首先将当前执行任务线程 <strong>runner</strong> 置为空，若其他线程有调用 <strong>FutureTask.cancel(true)</strong>，此时需要调用<strong>handlePossibleCancellationInterrupt</strong> 方法处理中断。</li></ol><h4 id="4-4-2、执行-run方法-——Java线程的实现"><a href="#4-4-2、执行-run方法-——Java线程的实现" class="headerlink" title="4.4.2、执行(run方法)——Java线程的实现"></a>4.4.2、执行(run方法)——Java线程的实现</h4><p>Java线程的使用方式有很多，但最后都会归于 <strong>Thread.start()</strong>方法，无论是使用 Thread 直接调用 start()方法还是使用线程池进行多线程调用，最终都会归于此处。start()内容：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">        group.add(<span class="built_in">this</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="literal">true</span>;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> (!started) {</span><br><span class="line">                    group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (Throwable ignore) {</span><br><span class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                  it will be passed up the call stack */</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地方法start</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册本地方法栈</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">static</span> {</span><br><span class="line">    registerNatives();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>可以看到，最终实现都是调用本地方法栈的 <strong>start0();</strong>。而这些native方法的注册是在Thread对象初始化的时候完成的，即上面的静态代码块内调用的 <strong>registerNatives();</strong> 。当该类被加载到 JVM 中的时候，它就会被调用，进而注册相应的本地方法。<p></p><p>而本地方法 <strong>registerNatives</strong> 是定义在 Thread.c 文件中的。Thread.c 是个很小的文件，它定义了各个操作系统平台都要用到的关于线程的公用数据和操作，如下：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// openJdk-10版本  THread.c</span></span><br><span class="line"><span class="type">static</span> JNINativeMethod methods[] = {</span><br><span class="line">    {<span class="string">"start0"</span>,           <span class="string">"()V"</span>,        (<span class="type">void</span> *)&amp;JVM_StartThread}, <span class="comment">//java start0</span></span><br><span class="line">    {<span class="string">"stop0"</span>,            <span class="string">"("</span> OBJ <span class="string">")V"</span>, (<span class="type">void</span> *)&amp;JVM_StopThread},</span><br><span class="line">    {<span class="string">"isAlive"</span>,          <span class="string">"()Z"</span>,        (<span class="type">void</span> *)&amp;JVM_IsThreadAlive},</span><br><span class="line">    {<span class="string">"suspend0"</span>,         <span class="string">"()V"</span>,        (<span class="type">void</span> *)&amp;JVM_SuspendThread},</span><br><span class="line">    {<span class="string">"resume0"</span>,          <span class="string">"()V"</span>,        (<span class="type">void</span> *)&amp;JVM_ResumeThread},</span><br><span class="line">    {<span class="string">"setPriority0"</span>,     <span class="string">"(I)V"</span>,       (<span class="type">void</span> *)&amp;JVM_SetThreadPriority},</span><br><span class="line">    {<span class="string">"yield"</span>,            <span class="string">"()V"</span>,        (<span class="type">void</span> *)&amp;JVM_Yield},</span><br><span class="line">    {<span class="string">"sleep"</span>,            <span class="string">"(J)V"</span>,       (<span class="type">void</span> *)&amp;JVM_Sleep},</span><br><span class="line">    {<span class="string">"currentThread"</span>,    <span class="string">"()"</span> THD,     (<span class="type">void</span> *)&amp;JVM_CurrentThread},</span><br><span class="line">    {<span class="string">"countStackFrames"</span>, <span class="string">"()I"</span>,        (<span class="type">void</span> *)&amp;JVM_CountStackFrames},</span><br><span class="line">    {<span class="string">"interrupt0"</span>,       <span class="string">"()V"</span>,        (<span class="type">void</span> *)&amp;JVM_Interrupt},</span><br><span class="line">    {<span class="string">"isInterrupted"</span>,    <span class="string">"(Z)Z"</span>,       (<span class="type">void</span> *)&amp;JVM_IsInterrupted},</span><br><span class="line">    {<span class="string">"holdsLock"</span>,        <span class="string">"("</span> OBJ <span class="string">")Z"</span>, (<span class="type">void</span> *)&amp;JVM_HoldsLock},</span><br><span class="line">    {<span class="string">"getThreads"</span>,        <span class="string">"()["</span> THD,   (<span class="type">void</span> *)&amp;JVM_GetAllThreads},</span><br><span class="line">    {<span class="string">"dumpThreads"</span>,      <span class="string">"(["</span> THD <span class="string">")[["</span> STE, (<span class="type">void</span> *)&amp;JVM_DumpThreads},</span><br><span class="line">    {<span class="string">"setNativeName"</span>,    <span class="string">"("</span> STR <span class="string">")V"</span>, (<span class="type">void</span> *)&amp;JVM_SetNativeThreadName},</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> THD</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> OBJ</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> STE</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> STR</span></span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="type">void</span> JNICALL</span><br><span class="line"><span class="title function_">Java_java_lang_Thread_registerNatives</span><span class="params">(JNIEnv *env, jclass cls)</span></span><br><span class="line">{</span><br><span class="line">    (*env)-&gt;RegisterNatives(env, cls, methods, ARRAY_LENGTH(methods));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>下面就要找具体是怎么调用的 <strong>Thread.run()</strong> 方法，在 jvm.cpp 中有如下代码：<br><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hotSpot-10版本  jvm.cpp</span></span><br><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_StartThread</span>(JNIEnv* env, jobject jthread))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">"JVM_StartThread"</span>);</span><br><span class="line">  JavaThread *native_thread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> throw_illegal_thread_state = <span class="literal">false</span>;</span><br><span class="line">  {</span><br><span class="line">    <span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (java_lang_Thread::<span class="built_in">thread</span>(JNIHandles::<span class="built_in">resolve_non_null</span>(jthread)) != <span class="literal">NULL</span>) {</span><br><span class="line">      throw_illegal_thread_state = <span class="literal">true</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      jlong size =</span><br><span class="line">             java_lang_Thread::<span class="built_in">stackSize</span>(JNIHandles::<span class="built_in">resolve_non_null</span>(jthread));</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">NOT_LP64</span>(<span class="keyword">if</span> (size &gt; SIZE_MAX) size = SIZE_MAX;)</span><br><span class="line">      <span class="type">size_t</span> sz = size &gt; <span class="number">0</span> ? (<span class="type">size_t</span>) size : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//主要看这里</span></span><br><span class="line">      native_thread = <span class="keyword">new</span> <span class="built_in">JavaThread</span>(&amp;thread_entry, sz);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (native_thread-&gt;<span class="built_in">osthread</span>() != <span class="literal">NULL</span>) {</span><br><span class="line">        </span><br><span class="line">        native_thread-&gt;<span class="built_in">prepare</span>(jthread);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><br>这里JVM_ENTRY是一个宏，用来定义JVM_StartThread 函数，可以看到函数内创建了真正的平台相关的本地线程，其线程函数是<strong>thread_entry</strong>，如下：<br><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hotSpot-10版本  jvm.cpp</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> {</span><br><span class="line">    HandleMark <span class="title function_">hm</span><span class="params">(THREAD)</span>;</span><br><span class="line">    Handle <span class="title function_">obj</span><span class="params">(THREAD, thread-&gt;threadObj()</span>);</span><br><span class="line">    JavaValue <span class="title function_">result</span><span class="params">(T_VOID)</span>;</span><br><span class="line">    JavaCalls::call_virtual(&amp;result,obj,</span><br><span class="line">    KlassHandle(THREAD,SystemDictionary::Thread_klass()),</span><br><span class="line">    vmSymbolHandles::run_method_name(),    <span class="comment">//看这里</span></span><br><span class="line">    vmSymbolHandles::void_method_signature(),THREAD);</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vmSymbolHandles</span>: AllStatic {</span><br><span class="line">   ...</span><br><span class="line">    template(run_method_name,<span class="string">"run"</span>)  <span class="comment">//这里!!! 这里决定了调用的方法名称是 “run”!</span></span><br><span class="line">   ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>自此调用流程就清晰了：<br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/java/多线程/Thread-JVM运行机制.png" alt="Thread-JVM运行机制.png"> <p></p><h4 id="4-4-3、执行-run方法-——成功结果set"><a href="#4-4-3、执行-run方法-——成功结果set" class="headerlink" title="4.4.3、执行(run方法)——成功结果set()"></a>4.4.3、执行(run方法)——成功结果set()</h4><p>老规矩，首先看源码：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FutureTask.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(V v)</span> {</span><br><span class="line">    <span class="keyword">if</span> (STATE.compareAndSet(<span class="built_in">this</span>, NEW, COMPLETING)) {</span><br><span class="line">        outcome = v;</span><br><span class="line">        STATE.setRelease(<span class="built_in">this</span>, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>该方法的调用只有通过 <strong>FutureTask.run()</strong> 方法才可以被调用，而 run 方法本身能执行到此处也是不会存在多线程的情况，因为能进行的前置要求存在 <strong>CAS操作修改状态</strong> 的步骤，由此分析其代码逻辑及含义：<p></p><ol><li>状态校验<br>其校验操作位<strong>CAS修改NEW状态为COMPLETING</strong>，所以只有状态为 <strong>NEW</strong> 的任务才可以进入其操作逻辑。这么做的意义在于执行<strong>run</strong> 方法逻辑时可能存在<strong>cancel</strong> 方法被调用，所以需要CAS操作来保证任务的状态为 NEW 才可以进入结果集设置的操作。</li><li>设置结果集<br>根据执行结果即 <strong>set的入参：V</strong> 设置返回结果集。</li><li>修改状态<br>将任务状态设置为 <strong>NORMAL</strong>，表示任务正常结束。此处对应的状态变化为：<strong>NEW -&gt; COMPLETING -&gt; NORMAL。</strong> </li><li>唤醒阻塞进程<br>调用任务执行完成方法，此时会唤醒阻塞的线程，调用done()方法和清空等待线程链表等。具体阻塞的进程的来源，上面聊队列的时候分析过具体的原因和情况。</li></ol><h4 id="4-4-4、执行-run方法-——异常结果setException"><a href="#4-4-4、执行-run方法-——异常结果setException" class="headerlink" title="4.4.4、执行(run方法)——异常结果setException()"></a>4.4.4、执行(run方法)——异常结果setException()</h4><p>先上源码：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FutureTask.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setException</span><span class="params">(Throwable t)</span> {</span><br><span class="line">    <span class="keyword">if</span> (STATE.compareAndSet(<span class="built_in">this</span>, NEW, COMPLETING)) {</span><br><span class="line">        outcome = t;</span><br><span class="line">        STATE.setRelease(<span class="built_in">this</span>, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>可以看到 <strong>setException</strong> 内的逻辑与 <strong>set</strong> 基本一致，区别在于返回结果此处是将异常设置进去，终态设置为 <strong>EXCEPTIONAL</strong> ，其它无区别。此处状态转换为： <strong>NEW -&gt; COMPLETING -&gt; EXCEPTIONAL。</strong><p></p><h4 id="4-4-5、执行-run方法-——finishCompletion"><a href="#4-4-5、执行-run方法-——finishCompletion" class="headerlink" title="4.4.5、执行(run方法)——finishCompletion()"></a>4.4.5、执行(run方法)——finishCompletion()</h4><p>先上源码：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FutureTask.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">finishCompletion</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="comment">// 根据 get 方法阻塞的队列，进行唤醒、移除等操作，若是get方法未被调用，则不进入循环</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="literal">null</span>;) {</span><br><span class="line">        <span class="keyword">if</span> (WAITERS.weakCompareAndSet(<span class="built_in">this</span>, q, <span class="literal">null</span>)) {</span><br><span class="line">            <span class="keyword">for</span> (;;) {</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="literal">null</span>) {</span><br><span class="line">                    q.thread = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// 唤醒线程</span></span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                }</span><br><span class="line">                <span class="type">WaitNode</span> <span class="variable">next</span> <span class="operator">=</span> q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="literal">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 无论有无阻塞队列，都调用done()，FutureTask内done()无任务实现内容。</span></span><br><span class="line">    done();</span><br><span class="line">    <span class="comment">// 任务已执行完毕，已将结果存储至outcome中，因此将callable属性置为空</span></span><br><span class="line">    callable = <span class="literal">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>此处主要是针对 <strong>waiters</strong> 内被阻塞的线程队列，针对阻塞的线程进行唤醒、移除等操作。由于FutureTask中的队列本质上是一个Treiber栈，因此操作的顺序是 <strong>后进先出</strong> 即后面先来的线程先被先操作。  <p></p><h4 id="4-4-6、执行-run方法-——执行完成共有操作handlePossibleCancellationInterrupt"><a href="#4-4-6、执行-run方法-——执行完成共有操作handlePossibleCancellationInterrupt" class="headerlink" title="4.4.6、执行(run方法)——执行完成共有操作handlePossibleCancellationInterrupt()"></a>4.4.6、执行(run方法)——执行完成共有操作handlePossibleCancellationInterrupt()</h4><p>先上源码：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePossibleCancellationInterrupt</span><span class="params">(<span class="type">int</span> s)</span> {</span><br><span class="line">    <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">        <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">            Thread.yield(); <span class="comment">// wait out pending interrupt</span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><br>可见该方法是一个自旋操作，如果当前的state状态是 <strong>INTERRUPTING</strong>，我们在原地自旋，直到 <strong>state</strong> 状态转换成终止态。意义在于：检查是否有遗漏的中断，如果有，等待中断状态完成。具体 <strong>handlePossibleCancellationInterrupt</strong> 为什么在任务执行完毕后调用，等聊到 <strong>cancel()</strong> 方法再详细分析。<p></p><h3 id="4-5、源码分析——获取执行结果"><a href="#4-5、源码分析——获取执行结果" class="headerlink" title="4.5、源码分析——获取执行结果"></a>4.5、源码分析——获取执行结果</h3><h4 id="4-5-1、获取执行结果——get"><a href="#4-5-1、获取执行结果——get" class="headerlink" title="4.5.1、获取执行结果——get()"></a>4.5.1、获取执行结果——get()</h4><p>先上源码：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException {</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">            s = awaitDone(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> CancellationException {<span class="doctag">@inheritDoc</span>}</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException {</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">        (s = awaitDone(<span class="literal">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>由源码可知，获取执行结果有两个方法：<p></p><ul><li><strong>get()</strong>：获取执行结果，如果未执行完毕，则阻塞等待。</li><li><strong>get(long timeout, TimeUnit unit)</strong>：获取执行结果，并设置超时时间，如果未超时则阻塞等待，如果已超时则 <strong>移除当前阻塞线程</strong> 并 <strong>直接返回当前执行状态</strong><br>除了后者存在超时时间设置外，其他执行逻辑并无区别，主要阻塞获取执行结果的方法都是 <strong>awaitDone</strong> 下面详细分析下此方法。</li></ul><h4 id="4-5-2、获取执行结果——awaitDone"><a href="#4-5-2、获取执行结果——awaitDone" class="headerlink" title="4.5.2、获取执行结果——awaitDone()"></a>4.5.2、获取执行结果——awaitDone()</h4><p>先上源码：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">awaitDone</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//超时相关设置</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">// 线程链表头节点</span></span><br><span class="line">    <span class="type">WaitNode</span> <span class="variable">q</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//是否已入阻塞队列</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">queued</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="comment">// 【1-4】状态校验，如果已执行完毕，且当前队列节点不为空则将队列当前线程置为空后返回状态。如果当前队列节点为空则直接返回状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) {</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="literal">null</span>)</span><br><span class="line">                q.thread = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态为COMPLETING则说明正在设置结果集，当前线程让出CPU时间片段，等待设置结果集完毕</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING)</span><br><span class="line">            Thread.yield();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【3-1】当前执行线程被中断，则移除队列节点，抛出中断异常</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Thread.interrupted()) {</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【1-1】当前线程还未进入阻塞队列，则创建包含当前线程信息的队列节点。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            q = <span class="keyword">new</span> <span class="title class_">WaitNode</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【1-2】如果当前队列节点未入阻塞队列，则加入队列头部</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            queued = WAITERS.weakCompareAndSet(<span class="built_in">this</span>, q.next = waiters, q);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 【2-1】若有超时设置，那么处理超时获取任务结果的逻辑</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) {</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> parkNanos;</span><br><span class="line">            <span class="keyword">if</span> (startTime == <span class="number">0L</span>) { <span class="comment">// first time</span></span><br><span class="line">                startTime = System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (startTime == <span class="number">0L</span>)</span><br><span class="line">                    startTime = <span class="number">1L</span>;</span><br><span class="line">                parkNanos = nanos;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="type">long</span> <span class="variable">elapsed</span> <span class="operator">=</span> System.nanoTime() - startTime;</span><br><span class="line">                <span class="keyword">if</span> (elapsed &gt;= nanos) {</span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                }</span><br><span class="line">                parkNanos = nanos - elapsed;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// nanoTime may be slow; recheck before parking</span></span><br><span class="line">            <span class="keyword">if</span> (state &lt; COMPLETING)</span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span>, parkNanos);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【1-3】阻塞当前线程</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>获取结果集的自旋循环处理逻辑，存在多个分支处理，每个分支的校验条件和操作逻辑均已在注释中描述，那么下面就看下每次循环都会执行哪些分支，同时进一步了解为什么每个分支的逻辑如此设计。<p></p><p><strong>情况 1：1、任务状态为NEW；2、无超时时间设置时，3、不存在中断操做时。循环内的情况</strong>：</p><ol><li>第一次循环：<br>此时 <strong>q=null</strong>，进入队列节点创建操作，即：【1-1】，操作完此次循环结束。此时队列节点已创建，但尚未放入阻塞队列内。</li><li>第二次循环：<br>此时  <strong>queued=false</strong>，进入将当前节点放入阻塞队列操作，即【1-2】，操作完此次循环结束。</li><li>第三次循环<br>当前队列节点已创建且已放入阻塞队列，此时进入阻塞阶段，即【1-3】，操作完成循环结束。</li><li>第四次循环<br>此时任务已执行完毕，阻塞线程被激活，进入结果集获取操作，即【1-4】，<strong>awaitDone</strong> 方法执行完毕，返回异步任务结果集。</li></ol><p><strong>情况 2：1、任务状态为NEW；2、存在超时时间设置时，3、不存在中断操做时。循环内的情况</strong>：<br>则在【1-3】和【1-4】中间加入【2-1】超时判断操作。其它同 <strong>情况1</strong>。</p><p><strong>情况 3：1、任务状态为NEW；2、无超时时间设置时，3、存在中断操做时。循环内情况：</strong><br>直接进入中断操作，移除当前队列节点，抛出异常即【3-1】。任务执行和任务取消都调用 <strong>finishCompletion()</strong> 方法，那么此处调用的意义在哪？此处调用意义：执行 <strong>awaitDone</strong> 时存在一种情况，即刚进行队列节点创建但还未将队列节点放入阻塞队列即【第一次循环】时。此时进行任务中断则队列节点无法在 <strong>finishCompletion()</strong> 中移除，所以需要在此处进行置空操作，方便GC回收。</p><p><strong>情况 4：1、任务状态为不为NEW。循环内情况：</strong><br>直接返回当前任务状态，存在当前队列节点则移除当前队列节点即【1-4】。原因类似 <strong>情况2</strong>，只不过中断操作变为任务完成。</p><h4 id="4-5-3、获取执行结果——report"><a href="#4-5-3、获取执行结果——report" class="headerlink" title="4.5.3、获取执行结果——report()"></a>4.5.3、获取执行结果——report()</h4><p>先上源码：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">report</span><span class="params">(<span class="type">int</span> s)</span> <span class="keyword">throws</span> ExecutionException {</span><br><span class="line">    <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CancellationException</span>();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutionException</span>((Throwable)x);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>根据状态获取结果集就很简单了，一共三个分支：<p></p><ol><li>状态为 <strong>NORMAL</strong>：即正常执行完成，返回 <strong>Callable.call()</strong> 方法执行结果即可。</li><li>状态 <strong>s &gt;= CANCELLED</strong>，说明存在取消情况，则抛出中断异常。</li><li>其它状态为执行过程存在异常，则将异常类返回即可。</li></ol><h3 id="4-6、源码分析——取消任务"><a href="#4-6、源码分析——取消任务" class="headerlink" title="4.6、源码分析——取消任务"></a>4.6、源码分析——取消任务</h3><p>线上源码：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span> {</span><br><span class="line">    <span class="comment">// 任务状态为NEW且根据mayInterruptIfRunning参数修改状态为INTERRUPTING或CANCELLED，二者任一</span></span><br><span class="line">    <span class="comment">// 失败或同时失败均返回 False</span></span><br><span class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp; STATE.compareAndSet</span><br><span class="line">            (<span class="built_in">this</span>, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {    </span><br><span class="line">        <span class="comment">// 如果mayInterruptIfRunning=true，则获取当前任务执行线程，进行中断操作</span></span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> runner;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">                    t.interrupt();</span><br><span class="line">            } <span class="keyword">finally</span> { <span class="comment">// final state</span></span><br><span class="line">                <span class="comment">// 最后任务状态赋值为INTERRUPTED</span></span><br><span class="line">                STATE.setRelease(<span class="built_in">this</span>, INTERRUPTED);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 针对阻塞进程进行唤醒、移除等操作</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>由源码可知：<p></p><ol><li>状态校验：<ul><li>状态不为NEW，直接返回false</li><li>状态为NEW，根据参数 <strong>mayInterruptIfRunning</strong> 不同值，进行不同的状态修改，此处修改为CAS操作，修改失败则返回false。成功则继续执行取消操作。</li></ul></li><li><p>根据 mayInterruptIfRunning 不同值进行操作：</p><ul><li>为flase：跳过 <strong>try</strong> 代码块，直接执行 <strong>finally</strong> 操作。此时状态变化为：<strong>NEW -&gt; CANCELLED。</strong></li><li>为true：则 <strong>runner==null</strong>，因为可能存在此时任务已经执行完成，将 runner 置为空了。如果不为空，则发送线程中断信号，发送中中断信号并不代表一定会真正的中断线程。此时状态变化为：<strong>NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</strong>。</li></ul></li><li><p>唤醒阻塞线程<br>无论 <strong>mayInterruptIfRunning</strong> 参数为何值，最终都会唤醒阻塞的线程，即调用 <strong>finishCompletion</strong> 方法，因为此时任务已经是终态了。 <strong>cancel()</strong> 方法返回true。<br>如果<strong>cancel()</strong> 返回true了，那么线程无论最终是否执行，<strong>get()</strong> 方法都会抛出<strong>CancellationException</strong>异常，因为 <strong>report(int s)</strong> 内会校验 <strong>s &gt;= CANCELLED</strong>，具体可看上一节的 <strong>report()</strong>源码。</p></li></ol><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="4-7、源码分析——移除任务"><a href="#4-7、源码分析——移除任务" class="headerlink" title="4.7、源码分析——移除任务"></a>4.7、源码分析——移除任务</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeWaiter</span><span class="params">(WaitNode node)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) {</span><br><span class="line">        node.thread = <span class="literal">null</span>;</span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) {          <span class="comment">// restart on removeWaiter race</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">WaitNode</span> <span class="variable">pred</span> <span class="operator">=</span> <span class="literal">null</span>, q = waiters, s; q != <span class="literal">null</span>; q = s) {</span><br><span class="line">                s = q.next;</span><br><span class="line">                <span class="keyword">if</span> (q.thread != <span class="literal">null</span>)</span><br><span class="line">                    pred = q;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="literal">null</span>) {</span><br><span class="line">                    pred.next = s;</span><br><span class="line">                    <span class="keyword">if</span> (pred.thread == <span class="literal">null</span>) <span class="comment">// check for race</span></span><br><span class="line">                        <span class="keyword">continue</span> retry;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!WAITERS.compareAndSet(<span class="built_in">this</span>, q, s))</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>移除指定节点，该方法仅在 <strong>awaitDone</strong> 方法内 <strong>等待执行结果超时</strong> 和 <strong>遇到线程中断</strong> 时调用。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>至此 <strong>FutureTask</strong> 体系相关的逻辑已经分析完毕。直接使用就只关心三块内容即可：</p><ol><li>Callable实现想要做的业务逻辑，</li><li>构建FutureTask类。</li><li>使用 Thread或ExecutorService来执行，并在执行后阻塞获取执行结果。</li></ol><p><strong>Callable</strong>也可直接执行，但只能通过 <strong>ExecutorService.submit</strong> 方法来执行，但内部实际上还是转换为FutureTask来执行，FutureTask则既可以 <strong>ExecutorService.submit</strong> 来执行，也可以直接使用 <strong>Thread</strong> 来直接执行，因为它既实现 <strong>Runnable</strong> 又实现了 <strong>Future</strong> 。</p><p><strong>FutureTask</strong> 内部则关系主要是 <strong>runner,waiters和state</strong> 这三个属性的定义概念和执行逻辑理清晰差不多也就把<strong>FutureTask</strong> 理解透彻了。</p><p>至此 <strong>future体系</strong> 算是分析完毕了。</p><p>参考：<br><a href="https://juejin.cn/post/6844903774985650183">https://juejin.cn/post/6844903774985650183</a><br><a href="https://segmentfault.com/a/1190000015739343">https://segmentfault.com/a/1190000015739343</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯</title>
      <link href="/posts/f92eff5d.html"/>
      <url>/posts/f92eff5d.html</url>
      
        <content type="html"><![CDATA[<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><p><strong>回溯法</strong>（英语：backtracking）是暴力搜索法中的一种。<br>对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解）。  </p><p>回溯算法又称 <font color="#0099ff">试探法</font>，采用试错的思想。在分步解决问题的过程中，当它通过尝试发现，现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p><ul><li>找到一个可能存在的正确的答案</li><li>在尝试了所有可能的分步方法后宣告该问题没有答案  </li></ul><p>在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。</p><p><strong>例如:</strong><br>在统计1~N中整数的所有子集问题时，就可以使用 <font color="#0099ff">回溯法</font> 进行处理。从1开始每个数字都有两种可能，存在子集或不存在子集，每种可能都会有一种结果，那么问题的结果就是所有可能的子集的集合。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a><strong>实例</strong></h3><p><strong>1. 实例1</strong><br><a href="https://leetcode-cn.com/problems/subsets/"></a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找法</title>
      <link href="/posts/aee0601b.html"/>
      <url>/posts/aee0601b.html</url>
      
        <content type="html"><![CDATA[<h2 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>二分搜索是一种在有序数组中查找某一特定元素的搜索算法。  </p><ul><li>搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；</li><li>如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。</li><li>如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a><strong>实例</strong></h3><p><strong>1. 实例1</strong><br>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。  </p><p>示例1  </p><blockquote><p>输入: nums = [-1,0,3,5,9,12], target = 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4  </p></blockquote><p>示例2  </p><blockquote><p>输入: nums = [-1,0,3,5,9,12], target = 2<br>输出: -1<br>解释: 2 不存在 nums 中因此返回 -1  </p></blockquote><p><strong>代码</strong><br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start &lt;= end){</span><br><span class="line">        <span class="comment">//取中间元素下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + (end - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//比较大小，进行区间区分或直接返回结果</span></span><br><span class="line">        <span class="keyword">if</span>(target == nums[mid])</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(target &gt; nums[mid]){</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>2. 实例2</strong><br>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>示例 1:  </p><blockquote><p>输入: nums = [1,3,5,6], target = 5<br>输出: 2  </p></blockquote><p>示例 2:  </p><blockquote><p>输入: nums = [1,3,5,6], target = 2<br>输出: 1</p></blockquote><p><strong>代码</strong><br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end){</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + (end - start) / <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(target == nums[mid])</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(target &gt; nums[mid])</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            end = mid -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>3. 实例3</strong><br><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">leetcode-33. 搜索旋转排序数组</a>  </p><p>整数数组 nums 按升序排列，数组中的值 互不相同 。<br>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。<br>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>示例 1：</p><blockquote><p>输入：nums = [4,5,6,7,0,1,2], target = 0<br>输出：4</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [4,5,6,7,0,1,2], target = 3<br>输出：-1</p></blockquote><p><strong>解1：</strong> 根据其旋转坐标，可将数组分为两个升序数组。分别对二者进行二分法查找即可。</p><p><strong>代码</strong><br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> rotatedIndex=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//查询第一组升序的最大值下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;size-<span class="number">1</span>;i++){</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;nums[i+<span class="number">1</span>]){</span><br><span class="line">            rotatedIndex = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> binarySearch(nums,target,<span class="number">0</span>,rotatedIndex);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> binarySearch(nums,target,rotatedIndex+<span class="number">1</span>,size-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ans1!=-<span class="number">1</span>){</span><br><span class="line">        <span class="keyword">return</span> ans1;</span><br><span class="line">    }<span class="keyword">else</span> <span class="keyword">if</span>(ans2!=-<span class="number">1</span>){</span><br><span class="line">        <span class="keyword">return</span> ans2;</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target,<span class="type">int</span> left,<span class="type">int</span> reight)</span>{</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=reight){</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (reight - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target){</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[mid]){</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line">            reight = mid - <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><strong>解2：</strong> 直接进行二分法查找。数组旋转后一定分为各自两段有序数组，可进行如下步骤：<p></p><ol><li>进行二分操作,可分为两部分，一定有有一部分为有序数组</li><li>如果target在有序数组的部分，则以有序数组为基础继续进行二分法查找。</li><li>如果target不在有序数组部分，继续进行【1】操作</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) {</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[mid]) {</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid]) {</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - <span class="number">1</span>]) {</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针</title>
      <link href="/posts/91a7e4d1.html"/>
      <url>/posts/91a7e4d1.html</url>
      
        <content type="html"><![CDATA[<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>双指针是一种简单而又灵活的技巧和思想，单独使用可以轻松解决一些特定问题，和其他算法结合也能发挥多样的用处。<br>双指针顾名思义，就是同时使用两个指针，在数组、序列、链表结构上指向的是位置，在树、图结构中指向的是节点，通过或同向移动，或相向移动来维护、统计信息。  </p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a><strong>实例</strong></h3><p><strong>1. 实例1</strong><br><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">leetcode-167. 两数之和 II - 输入有序数组</a><br>给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;= index1 &lt; index2 &lt;= numbers.length 。</p><p>以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。</p><p>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。</p><p>你所设计的解决方案必须只使用常量级的额外空间。</p><p>示例1  </p><blockquote><p>输入：numbers = [2,7,11,15], target = 9<br>输出：[1,2]<br>解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。</p></blockquote><p>给出数组为升序排序，所以双指针一头一尾，根据二者之和与目标值的大小比较来判断指针移动方向。</p><p><strong>代码</strong><br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) {</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> n= numbers.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>,j=n-<span class="number">1</span>;i&lt;j;){</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers[i]+numbers[j];</span><br><span class="line">        <span class="keyword">if</span>(sum==target){</span><br><span class="line">            ans[<span class="number">0</span>] = i+<span class="number">1</span>;</span><br><span class="line">            ans[<span class="number">1</span>] = j+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;target){</span><br><span class="line">            --j;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> (sum&lt;target){</span><br><span class="line">            ++i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>2. 实例2</strong><br><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">leetcode-19. 删除链表的倒数第 N 个结点</a><br>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。  </p><p>示例 1:<br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/algorithm/双指针1.jpg" alt="">  </p><blockquote><p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]</p></blockquote><p>双指针形式，当快慢两个指针之差为n时，二者保持同时移动，当快到达最后节点，慢指针正好符合删除的节点要求。</p><p><strong>代码</strong><br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">zero</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> zero;</span><br><span class="line">    ListNode fast= head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="literal">null</span>){</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast =fast.next;</span><br><span class="line">    }</span><br><span class="line">    slow.next = slow.next.next;</span><br><span class="line">    <span class="keyword">return</span> zero.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-时间复杂度</title>
      <link href="/posts/5cfaff95.html"/>
      <url>/posts/5cfaff95.html</url>
      
        <content type="html"><![CDATA[<h2 id="算法-时间复杂度"><a href="#算法-时间复杂度" class="headerlink" title="算法-时间复杂度"></a>算法-时间复杂度</h2><h3 id="1、数据结构-算法"><a href="#1、数据结构-算法" class="headerlink" title="1、数据结构-算法"></a>1、数据结构-算法</h3><p>数据结构和算法是相辅相成的，<strong>数据结构是为算法服务的，算法要作用在特定的数据结构之上</strong>。所以二者的学习不能互相孤立。</p><h3 id="2、算法复杂度分析"><a href="#2、算法复杂度分析" class="headerlink" title="2、算法复杂度分析"></a>2、算法复杂度分析</h3><ol><li>时间复杂度： 指算法需要消耗的时间资源。计算机算法是问题规模n 的函数f(n)，算法的时间复杂度也因此记做。<br>T(n)=Ο(f(n))</li><li>空间复杂度：算法需要消耗的空间资源。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。</li></ol><h4 id="2-1、事后统计法"><a href="#2-1、事后统计法" class="headerlink" title="2.1、事后统计法"></a>2.1、事后统计法</h4><p>事后统计法：通过统计、分析等，计算出算法的实际执行时间和实际内存占用，从而得到算法的时间复杂度。</p><ul><li>测试结果非常依赖测试环境。（服务器资源配置）</li><li>测试结果受限于数据规模</li></ul><h4 id="2-2、大O复杂度表示法"><a href="#2-2、大O复杂度表示法" class="headerlink" title="2.2、大O复杂度表示法"></a>2.2、大O复杂度表示法</h4><p>时间复杂度通俗来讲，就是代码运行的时间。大O表示法就是在不运算代码的情况下来分析一段代码的时间复杂度。<br>看下面的例子：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> n)</span>{</span><br><span class="line">  <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;i&lt;n;++i){</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>从CPU的角度来看，代码的每一行都执行着类似的操作：<strong>读操作-运算-写操作</strong>。这里我们假设每行代码的执行时间一样，为unit_time，那么2，3行执行了1个unit_time，3，4行n个unit_time，总的执行时间就是（2n+2）<em>unit_time。<br>按照这个思路再来看下面一段代码：<br><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> n)</span>{</span><br><span class="line">  <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;i&lt;n;i++){</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;j&lt;=n;j++){</span><br><span class="line">      sum += sum + i * j;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>依旧假设单位时间为unit_time，2、3、4行执行时间分别为1unti_time，5、6加起来就是2n。7、8加起来就是2n²unit_time;总的时间就为(2n²+2n+3)unit_time.<br>这两段代码分析我们可得到一个重要的规律，那就是<em>*代码的执行时间T(n)和每段代码的执次数成正比</em></em>，所以就得到了以下公式：<p></p><blockquote><font color="orange">T(n)=O(f(n))</font></blockquote><p>其中T(n)代表了代码的执行时间，n代表数据规模，f(n)代表每行代码执行的次数总和。因为是公式，所以用f(n)表达。公式中的O则表示代码执行时间T(n)和表达式f(n)成正比。   </p><p>两个例子中的T(n)=O(2n+2)和T(n)=O(2n²+2n+3)就是大O时间复杂度表示法，它并不代表具体的执行时间，而是代表<strong>代码的执行时间随着数据规模增加的变化趋势</strong>，所以也叫渐进时间复杂度（asymptotic time complexity），简称时间复杂度。  </p><p>当n很大时，表达式中的低阶、常量、系数等部分并不左右增长趋势，所以大O表示法可记为：T(n)=O(n)、T(n)=O(n²)。</p><h4 id="2-3-常见复杂度分析方法"><a href="#2-3-常见复杂度分析方法" class="headerlink" title="2.3 常见复杂度分析方法"></a>2.3 常见复杂度分析方法</h4><ol><li>单段代码看高频：如循环<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> n)</span>{</span><br><span class="line">  <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;i&lt;n;++i){</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>多段代码取最高：如一段代码中存在单重循环和多重循环，则取多重循环。<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> n)</span>{</span><br><span class="line">  <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;a&lt;n;++a){</span><br><span class="line">    temp = temp + i;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;i&lt;n;i++){</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;j&lt;=n;j++){</span><br><span class="line">      sum += sum + i * j;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>嵌套循环取乘积：比如多重循环，递归等。<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> n)</span>{</span><br><span class="line">  <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;i&lt;n;i++){</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;j&lt;=n;j++){</span><br><span class="line">      sum += sum + i * j;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>多数据规模取和：O(n+m)。<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span>{</span><br><span class="line">  <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;a&lt;n;++a){</span><br><span class="line">    temp = temp + i;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;i&lt;m;i++){</span><br><span class="line">    sum += sum + i * j;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="2-4-常见的时间复杂度"><a href="#2-4-常见的时间复杂度" class="headerlink" title="2.4 常见的时间复杂度"></a>2.4 常见的时间复杂度</h4><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/algorithm/常见时间复杂度.jpg" alt="常见时间复杂度"></p><ol><li>多项式阶，随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。  </li></ol><ul><li>O(1)（常数阶）<br>常数阶的概念并不是只执行一行代码，一般情况下算法中不存在循环、递归等语句，即使有成千上万行代码，复杂度也是O(1)</li><li>O(logn)（对数阶）<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n){</span><br><span class="line">  i = i * <span class="number">2</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>当2^x&gt;=n时，循环结束，所以这段代码的执行次数就是x= $log_2n$;大O法记作：$O(log_2n)$。那么再看下面这段代码：<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n){</span><br><span class="line">  i = i * <span class="number">3</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>按照上面的逻辑，这段的复杂度为$O(log_3n)$。二者之间是可以转换的$log_3n=log_32 * log_2n$；基于大O法的理论：在采用大O计数法时可以忽略系数等。则此类复杂度可统一记为O(logn)。   </li><li>O(n)（线性阶）</li><li>O(nlogn)（线性对数阶）<br>基于O(logn)，那么O(nlogn)就容易理解了，就相当于上面的嵌套取乘积规则一样，就是O(logn)执行的n遍。</li><li>O(n^2)（平方阶）、O(n^3)（立方阶）….、O(n^k)(K次方阶)</li></ul><ol><li>非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。</li></ol><ul><li>O(2^n)（指数阶）</li><li>O(n!)（阶乘阶）</li></ul><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h3><p>虽然上面说的事后统计法有一定的缺点，但时间复杂度的分析与其并不是对立冲突的。时间复杂度是一个理论上的模型，可以比较直观的给我们一个算法的效率上的感性认知，只能提供粗略的分析。它是与宿主平台无关的，并不是说O(n)的效率一定就优于O(n²)。针对不同的宿主平台环境，不同的数据集，不同的数据规模，在实际应用上性能可能会各有不同，所以实际应用中进行一定的性能基准测试是有必要的。<br>综上所述，时间复杂度分析和性能测试是相辅相成的。但一个低阶的时间复杂度确实有极大的可能优于高阶的时间复杂度，所以在编程中时刻关心复杂度的趋势走向是很有必要的，而且能很大幅度的提升输出质量。因此在编程中具有这种复杂度分析的思维还是十分有必要的。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析最好、最坏、平均、均摊时间复杂度</title>
      <link href="/posts/880fa53b.html"/>
      <url>/posts/880fa53b.html</url>
      
        <content type="html"><![CDATA[<p>对大O复杂度分析有一定基础的情况，可以进一步了解 <strong>最好情况时间复杂度</strong>（best case time complexity）、 <strong>最坏情况时间复杂度</strong>（worst case time complexity）、 <strong>平均情况时间复杂度</strong>（average case time complexity）、 <strong>均摊时间复杂度</strong>（amortized time complexity）。如果这几个概念你都能掌握，那对你来说，复杂度分析这部分内容就没什么大问题了。</p><h2 id="1、最好、最坏时间复杂度"><a href="#1、最好、最坏时间复杂度" class="headerlink" title="1、最好、最坏时间复杂度"></a>1、最好、最坏时间复杂度</h2><p>先分析下下面的例子：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">find</span> <span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> x)</span>{</span><br><span class="line">  <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;array.length;i++){</span><br><span class="line">    <span class="keyword">if</span>(array[i] == x) {</span><br><span class="line">      pos = i;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>按照大O分析法，这段代码的复杂度就为O(n)；n代表数组的长度。但其实我们在查找数组中某个元素时，不一定非要把整个数组都遍历一遍，可以进行简单优化，如：<br><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">find</span> <span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> x)</span>{</span><br><span class="line">  <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;array.length;i++){</span><br><span class="line">    <span class="keyword">if</span>(array[i] == x) {</span><br><span class="line">      pos = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>优化后的代码的时间复杂度还是O(n)吗？其实看一下也不尽然。这样就可以引进三个新的概念：最好时间复杂度、最坏时间复杂度和平均时间复杂度。<br>可以比较直观的分析得到两种情况：<p></p><ul><li>当x位于数组的最前面的下标，极端一些就在下标0的位置，那么时间复杂度就为O(1)，这就是最好时间复杂度。</li><li>另一种情况则是所查询的x不存在与数组之中，那么就要遍历整个数组，这样时间复杂度就为O(n)。这种极度糟糕的情况对应的就是最坏时间复杂度。</li></ul><h2 id="2、平均时间复杂度"><a href="#2、平均时间复杂度" class="headerlink" title="2、平均时间复杂度"></a>2、平均时间复杂度</h2><p>依旧拿上面例子为主，发生最好和最坏的情况的概率还是很小的。为了更好的表示平均情况下的时间复杂度，就需要引入一个新的概念：平均情况时间复杂度，简称平均时间复杂度。</p><p>我们知道要找的x在数组和不在数组的准确概率计算是极其复杂的，我们概括性的假设二者的概率均为1/2。另外查找的x出现在0~(n-1)这n个位置的概率为1/n。那么考虑在数组或不在数组的概率，根据概率乘积法则，x出现在0~(n-1)这n个位置的概率为1/2n，由此可以推到出以下公式：<br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/algorithm/平均时间复杂度.jpg" alt="推到公式">  </p><p>这个值就是概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 O(n)。  </p><p>平均时间复杂度看起来很复杂，又是引入概率又是需要推导。不过平常情况下只需要一种复杂度就可以满足需求。除非是在同一个代码块因不同情况出现，时间复杂度有量级上的差距，才需要用这三种时间复杂度进行分析。  </p><h2 id="3、均摊时间复杂度"><a href="#3、均摊时间复杂度" class="headerlink" title="3、均摊时间复杂度"></a>3、均摊时间复杂度</h2><p>均摊复杂度听起来和平均时间复杂度十分相似，而且也经常容易混淆。那具体均摊复杂度是什么呢？我们还是通过具体例子来了解一下，以及它的分析方法：摊还分析/平摊分析.<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> element)</span>{</span><br><span class="line">  <span class="type">int</span> sum;</span><br><span class="line">  <span class="keyword">if</span>(count==array.length){</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.length;i++){</span><br><span class="line">      sum = sum + array[i];</span><br><span class="line">    }</span><br><span class="line">    array[<span class="number">0</span>] = sum;</span><br><span class="line">    count = <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line">  array[count] = element;</span><br><span class="line">  count++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>上面是一个很简单的数组插入数据的代码块，当数组满了时，将数组所有内容求和放入下标为0的位置，再继续插入数据。按照大O分析法，我们进行最好、最坏和平均时间复杂度分析。<p></p><p>通过分析代码，我们可知。只有在数组满时才会进行数组遍历并求和，此时的时间复杂度为O(n)，其余时间的复杂度均为O(1)。所以最坏时间复杂度为O(n)，最好时间复杂度为O(1)。<br>那么接下来进行平均时间复杂度分析。假设插入的数组位于0~(n-1)间位置的概率是一样的均为1/n，由此推导出平均时间复杂度为O(1)，以下为推导过程：<br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/algorithm/平均时间复杂度-1.jpg" alt="推到公式">    </p><p>到此最好、最坏、平均时间复杂度进阶推导出来，其实这个例子的时间复杂度大可不必如此麻烦，还引入概率。我们仔细分析一下find()和insert()两个方法的区别。</p><ul><li>O(n)的出现是小概率事件，O(1)反而出现的概率很大。</li><li>O(n)和O(1)出现是极其有规律的。当出现一次O(n)后，后面就会跟着n-1个O(1)。循环往复。  </li></ul><p>这种情况其实就没必要引入概率来进行平均时间复杂度的计算。针对这种特殊的场景，引入一种更简单的分析方法：摊还分析法，由此引出新的时间复杂度：摊还时间复杂度。具体分析如下：在了解O(n)和O(1)出现的规律后，可以把耗时多的O(n)的时间均摊到接下来的n-1次操作上，这样下来，摊还时间复杂度就为O(1)。</p><p>摊还时间复杂度可以针对特殊的场景进行简单化的分析，如：针对特殊的数据结构，在一段连续操作的代码块中，其中大多数操作耗时很短，只有极少数的操作耗时较长，就可以针对性的适用摊还分析进行时间复杂度分析。个人认为摊还时间复杂度可以算作一种特殊的评价时间复杂度</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式CAP</title>
      <link href="/posts/97c733b2.html"/>
      <url>/posts/97c733b2.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以下引用至维基百科：  </p><blockquote><p>在理论计算机科学中，CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p><ul><li>一致性（Consistency）：等同于所有节点访问同一份最新的数据副本</li><li>可用性（Availability）：每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据</li><li>分区容错性（Partition tolerance）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在<br>限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li></ul><p>根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项。理解CAP理论的最简单方式：<br><strong>想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CAP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust基础信息</title>
      <link href="/posts/fd45b18c.html"/>
      <url>/posts/fd45b18c.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、rust基础信息"><a href="#一、rust基础信息" class="headerlink" title="一、rust基础信息"></a>一、rust基础信息</h3><ol><li><strong>在 Linux 或 macOS 上安装 rustup</strong><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --proto '=https' --tlsv1.<span class="number">2</span> https:<span class="comment">//sh.rustup.rs -sSf | sh</span></span><br></pre></td></tr></tbody></table></figure>此命令下载一个脚本并开始安装 rustup 工具，这会安装最新稳定版 Rust。过程中可能会提示你输入密码。如果安装成功，将会出现如下内容：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Rust is installed now. Great!</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">2. **rust版本**</span><br><span class="line">```rust</span><br><span class="line">rustc --version</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="二、cargo基础信息"><a href="#二、cargo基础信息" class="headerlink" title="二、cargo基础信息"></a>二、cargo基础信息</h3><ol><li><p><strong>cargo版本</strong></p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo --version</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>使用 Cargo 创建项目</strong></p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo new hello_cargo</span><br><span class="line">cd hello_cargo</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>编译运行</strong></p><ul><li>编译<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br><span class="line">    Compiling world_hello v0.<span class="number">1.0</span> (/Users/workerspace/rust/world_hello)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">1.72</span>s</span><br></pre></td></tr></tbody></table></figure></li><li>编译运行<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cargo run</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.00</span>s</span><br><span class="line">    Running `target/debug/world_hello`</span><br><span class="line">    Hello, world!</span><br></pre></td></tr></tbody></table></figure></li><li>检查，check，该命令会快速很多，因为它不会生成相关的可执行文件<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cargo check</span><br><span class="line">    Checking world_hello v0.<span class="number">1.0</span> (/Users/workerspace/rust/world_hello)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.14</span>s</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><strong>发布（release）构建</strong><br>当项目最终准备好发布时，可以使用 cargo build —release 来优化编译项目。这会在 target/release 而不是 target/debug 下生成可执行文件。这些优化可以让 Rust 代码运行的更快，不过启用这些优化也需要消耗更长的编译时间。这也就是为什么会有两种不同的配置：一种是为了开发，你需要经常快速重新构建；另一种是为用户构建最终程序，它们不会经常重新构建，并且希望程序运行得越快越好。如果你在测试代码的运行时间，请确保运行 cargo build —release 并使用 target/release 下的可执行文件进行测试。</li></ol><h3 id="三、基础概念"><a href="#三、基础概念" class="headerlink" title="三、基础概念"></a>三、基础概念</h3><h4 id="3-1、变量与可变性"><a href="#3-1、变量与可变性" class="headerlink" title="3.1、变量与可变性"></a>3.1、变量与可变性</h4><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>(){</span><br><span class="line">    <span class="comment">// 定义不可变变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;  <span class="comment">//不可变量</span></span><br><span class="line">    x = <span class="number">1</span>;  <span class="comment">//会报错：cannot assign twice to immutable variable</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义可变变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = <span class="number">2</span>;</span><br><span class="line">    y = <span class="number">3</span>;  <span class="comment">//允许</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//常量</span></span><br><span class="line">    <span class="keyword">const</span> THREE_HOURS_IN_SECONDS: <span class="type">u32</span> = <span class="number">60</span> * <span class="number">60</span> * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个不会被使用（unused variable）的变量，并且忽略警告（warning）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_x</span> = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="3-2、数据类型"><a href="#3-2、数据类型" class="headerlink" title="3.2、数据类型"></a>3.2、数据类型</h4><ol><li><p><strong>标量类型</strong><br>整型、浮点型、布尔类型和字符类型。    </p><p> 长度 | 有符号 | 无符号<br> :-|:-|:-|<br> 8-bit    |i8         |u8<br> 16-bit    |i16     |u16<br> 32-bit    |i32     |u32<br> 64-bit    |i64     |u64<br> 128-bit    |i128     |u128<br> arch    |isize     |usize</p></li><li><p><strong>元组类型</strong><br>元组是一个将多个其他类型的值组合进一个复合类型的主要方式。元组长度固定：一旦声明，其长度不会增大或缩小。</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>); <span class="comment">//定义</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">five_hundred</span> = x.<span class="number">0</span>; <span class="comment">//取值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);    <span class="comment">//绑定</span></span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup;        <span class="comment">//解构</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"The value of y is: {}"</span>, y);   <span class="comment">//取值应用</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>数组类型</strong><br>包含多个相同类型数值的方式就是数组，且长度固定。</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>; <span class="number">5</span>]; <span class="comment">//等价于 let a = [3,3,3,3,3];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>];   <span class="comment">//取值，下标以0为起始。</span></span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="3-3、函数定义"><a href="#3-3、函数定义" class="headerlink" title="3.3、函数定义"></a>3.3、函数定义</h4><ol><li><p>基础规则  </p><ul><li>关键字：fn</li><li>参数必须指定类型</li><li>函数名命名规则：snake case</li><li>函数具备返回值时，不对返回值指定命名，但要指定类型<br>示例：<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参、无返回</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>() {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Another function."</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参、无返回</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>(x: <span class="type">i32</span>) {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The value of x is: {}"</span>, x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参、有返回</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">five</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参、有返回</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">five</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">    x+<span class="number">5</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>语句和表达式的区别<br>函数体由一系列的语句和一个可选的结尾表达式构成。    </p></li></ol><ul><li><strong>语句（Statements）</strong>：是执行一些操作但不返回值的指令。</li><li><strong>表达式（Expressions）</strong>：计算并产生一个值。</li><li>区别:<ul><li>语句由 <strong>;</strong> 结尾，表达式无 <strong>;</strong> 结尾</li><li>语句代表执行某些逻辑，但不返回值，表达式则即有逻辑也返回具体值。</li><li>函数可以使用 return 关键字和指定值，从函数中提前返回；但大部分函数隐式的返回最后的表达式。</li></ul></li></ul><p>Rust 中的特殊返回类型：</p><ul><li>无返回值()，例如单元类型 <strong>()</strong>，是一个零长度的元组。它没啥作用，但是可以用来表达一个函数没有返回值：<ul><li>函数没有返回值，那么返回一个 ()</li><li>通过 ; 结尾的表达式返回一个 ()</li></ul></li><li>永不返回的发散函数 <strong>!</strong> ：当用 ! 作函数返回类型的时候，表示该函数永不返回( diverge function )</li></ul><p>示例：<br></p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回为：5</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回：（x+1）</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//无返回，会报错</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">    x + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">//其中下面代码块代表数值：4，因（x+1）无分号</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// （）</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">report</span>&lt;T: <span class="built_in">Debug</span>&gt;(item: T) {</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">"{:?}"</span>, item);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">clear</span>(text: &amp;<span class="keyword">mut</span> <span class="type">String</span>) <span class="punctuation">-&gt;</span> () {</span><br><span class="line">  *text = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">""</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ！</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dead_end</span>() <span class="punctuation">-&gt;</span> ! {</span><br><span class="line">  <span class="built_in">panic!</span>(<span class="string">"你已经到了穷途末路，崩溃吧！"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">forever</span>() <span class="punctuation">-&gt;</span> ! {</span><br><span class="line">  <span class="keyword">loop</span> {</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  };</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="3-4、控制流"><a href="#3-4、控制流" class="headerlink" title="3.4、控制流"></a>3.4、控制流</h4><ul><li>if</li><li>loop</li><li>while</li><li>for<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//if</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> number &gt; <span class="number">5</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"number greater than 5"</span>);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> number &gt; <span class="number">3</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"number greater than 3"</span>);</span><br><span class="line">    }<span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"number less than or equal to 3"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">condition</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition { <span class="number">5</span> } <span class="keyword">else</span> { <span class="number">6</span> };</span><br><span class="line"></span><br><span class="line">    <span class="comment">//loop</span></span><br><span class="line">    <span class="keyword">loop</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"again!"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">remaining</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">loop</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"remaining = {}"</span>, remaining);</span><br><span class="line">        <span class="keyword">if</span> remaining == <span class="number">9</span> {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">2</span> {</span><br><span class="line">            <span class="keyword">break</span> <span class="symbol">'counting_up</span>;</span><br><span class="line">        }</span><br><span class="line">        remaining -= <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> {</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> {</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">//while</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="number">5</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"the value is: {}"</span>, a[index]);</span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> a {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"the value is: {}"</span>, element);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="四、所有权"><a href="#四、所有权" class="headerlink" title="四、所有权"></a>四、所有权</h3><p>所有权（系统）是 Rust 最为与众不同的特性，对语言的其他部分有着深刻含义。它让 Rust 无需垃圾回收（garbage collector）即可保障内存安全，因此理解 Rust 中所有权如何工作是十分重要的。本章，我们将讲到所有权以及相关功能：借用（borrowing）、slice 以及 Rust 如何在内存中布局数据。</p><h4 id="4-1、基础规则"><a href="#4-1、基础规则" class="headerlink" title="4.1、基础规则"></a>4.1、基础规则</h4><ol><li><strong>赋值相关操作</strong></li></ol><ul><li>Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。  </li><li>值在任一时刻有且只有一个所有者。</li><li>当所有者（变量）离开作用域，这个值将被丢弃。<br>示例：<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>(){</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>; <span class="comment">//x有效</span></span><br><span class="line">    y = x;  <span class="comment">//x y均有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>); <span class="comment">//s1有效</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1;            <span class="comment">//s1无效，s2有效，此种赋值称为移动（move）</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ol><li><strong>克隆</strong><br>如果我们 确实 需要深度复制 String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 clone 的通用函数。<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"s1 = {}, s2 = {}"</span>, s1, s2);   <span class="comment">//s1,s2都有效</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><p>但针对存储在栈上的数据，因其大小都是固定的，所有拷贝是速度最快，所有才会有x赋值给y后，x依旧有效 。Rust 有一个叫做 <strong>Copy trait</strong> 的特殊注解，可以用在类似整型这样的存储在栈上的类型上（。如果一个类型实现了 <strong>Copy trait</strong>，那么一个旧的变量在将其赋值给其他变量后仍然可用。Rust 不允许自身或其任何部分实现了 <strong>Drop trait</strong> 的类型使用 <strong>Copy trait</strong>。</p><p>一般情况下任何一组简单标量值的组合都可以实现 Copy，任何不需要分配内存或某种形式资源的类型都可以实现 Copy。如下是一些 Copy 的类型：     </p><ul><li>所有整数类型，比如 u32。</li><li>布尔类型，bool，它的值是 true 和 false。</li><li>所有浮点数类型，比如 f64。</li><li>字符类型，char。</li><li>元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。</li></ul><ol><li><strong>所有权与函数</strong><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();         <span class="comment">// gives_ownership 将返回值</span></span><br><span class="line">                                        <span class="comment">// 转移给 s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);     <span class="comment">// s2 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);  <span class="comment">// s2 被移动到</span></span><br><span class="line">                                        <span class="comment">// takes_and_gives_back 中,</span></span><br><span class="line">                                        <span class="comment">// 它也将返回值移给 s3</span></span><br><span class="line">} <span class="comment">// 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span></span><br><span class="line">  <span class="comment">// 所以什么也不会发生。s1 离开作用域并被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> {             <span class="comment">// gives_ownership 会将</span></span><br><span class="line">                                             <span class="comment">// 返回值移动给</span></span><br><span class="line">                                             <span class="comment">// 调用它的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"yours"</span>); <span class="comment">// some_string 进入作用域.</span></span><br><span class="line"></span><br><span class="line">    some_string                              <span class="comment">// 返回 some_string </span></span><br><span class="line">                                             <span class="comment">// 并移出给调用的函数</span></span><br><span class="line">                                             <span class="comment">// </span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// takes_and_gives_back 将传入字符串并返回该值</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> { <span class="comment">// a_string 进入作用域</span></span><br><span class="line">                                                      <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// 返回 a_string 并移出给调用的函数</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="4-2、引用与借用"><a href="#4-2、引用与借用" class="headerlink" title="4.2、引用与借用"></a>4.2、引用与借用</h4><ol><li><strong>不可变引用</strong><br>当参数被传递给函数后，我们依旧需要使用它，如果单纯的使用函数返回的模式，就很形式主义了，所以我们需要一种方式，来保证将参数传递给函数我们依旧可以对其进行操作，这就是<strong>引用</strong>。<strong>引用</strong>（reference）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。与指针不同，引用确保指向某个特定类型的有效值。   </li></ol><p><strong>规则：</strong></p><ul><li>引用后变量并不具备该参数的所有权，所以当引用停止使用时，它所指向的值也不会被丢弃。</li><li>我们将创建一个引用的行为称为 借用（borrowing）。正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来。当你使用完毕，必须还回去。我们并不拥有它。</li><li>对引用变量进行修改会报错，（默认）不允许修改引用的值。</li></ul><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The length of '{}' is {}."</span>, s1, len);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The length of '{}' is {}."</span>, s1, len);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> { <span class="comment">// s is a reference to a String</span></span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">} <span class="comment">// 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，</span></span><br><span class="line">  <span class="comment">// 所以什么也不会发生</span></span><br></pre></td></tr></tbody></table></figure><ol><li>可变引用<br>针对不可变引用增加 <font color="red" size="5"><b>mut</b></font> 关键词即可变为可变引用。<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) {</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">", world"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><strong>可变引用和不可变引用的使用规则：</strong></li></ol><ul><li>在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。</li><li>引用必须总是有效的。</li></ul><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    } <span class="comment">// r1 在这里离开了作用域，所以我们完全可以创建一个新的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// 大问题</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}, {}, and {}"</span>, r1, r2, r3);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="4-3、Slice-类型"><a href="#4-3、Slice-类型" class="headerlink" title="4.3、Slice 类型"></a>4.3、Slice 类型</h4><p><strong>slice:</strong> 允许你引用集合中一段连续的元素序列，而不用引用整个集合。slice 是一类引用，所以它没有所有权。<br></p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="comment">//字符串类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello world"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span> = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="五、结构体"><a href="#五、结构体" class="headerlink" title="五、结构体"></a>五、结构体</h3><h4 id="5-1、实例化"><a href="#5-1、实例化" class="headerlink" title="5.1、实例化"></a>5.1、实例化</h4><ol><li>概念<br>结构体类型面向对象语言中的类的概念，一样含有自身的属性字段等信息。<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> {</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User {</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"someone@example.com"</span>),</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"someusername123"</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User {</span><br><span class="line">    User {</span><br><span class="line">        email: email,</span><br><span class="line">        username: username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User {</span><br><span class="line">    User {</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User {</span><br><span class="line">        active: user1.active,</span><br><span class="line">        username: user1.username,</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"another@example.com"</span>),</span><br><span class="line">        sign_in_count: user1.sign_in_count,</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>所有权<br>我们使用了自身拥有所有权的 String 类型而不是 &amp;str 字符串 slice 类型。这是一个有意而为之的选择，因为我们想要这个结构体拥有它所有的数据，为此只要整个结构体是有效的话其数据也是有效的。<br>可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上 生命周期（lifetimes）。</li></ol><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> {</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scale</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle {</span><br><span class="line">        width: dbg!(<span class="number">30</span> * scale),</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    dbg!(&amp;rect1);<span class="comment">/* 输出：&amp;rect1 = Rectangle {</span></span><br><span class="line"><span class="comment">                                width: 60,</span></span><br><span class="line"><span class="comment">                                height: 50,</span></span><br><span class="line"><span class="comment">                            } */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"rect1 is {:?}"</span>, rect1);<span class="comment">//输出：rect1 is Rectangle { width: 30, height: 50 }</span></span><br><span class="line">    <span class="comment">//{:#?}：也可用此表达书进行输出格式化</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>#[derive(Debug)]：</strong>配和 <strong>{:?}</strong> 方便输出调试<br><strong>dbg!：</strong> 放在表达式 30 * scale 周围，因为 dbg! 返回表达式的值的所有权。</p><h4 id="5-2、方法语法"><a href="#5-2、方法语法" class="headerlink" title="5.2、方法语法"></a>5.2、方法语法</h4><ul><li>方法（method）：与函数类似，它们使用 fn 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。不过方法与函数是不同的，因为它们在结构体的上下文中被定义（，并且它们第一个参数总是 self，它代表调用该方法的结构体实例。</li><li>impl：是 implementation 的缩写），这个 impl 块中的所有内容都将与<strong>所实现的结构体</strong>类型相关联。</li><li>每个结构体都允许拥有多个 impl 块。</li><li>关联函数：所有在 impl 块中定义的函数被称为 <strong>关联函数（associated functions）</strong>，因为它们与 <strong>impl</strong> 后面命名的类型相关。我们可以定义不以 self 为第一参数的关联函数（因此不是方法），因为它们并不作用于一个结构体的实例。如：代码示例中的《square》.</li><li>非结构体方法类关联函数使用 <strong>结构体名</strong> 和 <strong>::</strong> 语法来调用这个关联函数<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> {</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> {</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> {</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Rectangle {</span><br><span class="line">        Rectangle {</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle {</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect2</span> = Rectangle {</span><br><span class="line">        width: <span class="number">10</span>,</span><br><span class="line">        height: <span class="number">40</span>,</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect3</span> = Rectangle {</span><br><span class="line">        width: <span class="number">60</span>,</span><br><span class="line">        height: <span class="number">45</span>,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Can rect1 hold rect2? {}"</span>, rect1.<span class="title function_ invoke__">can_hold</span>(&amp;rect2));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Can rect1 hold rect3? {}"</span>, rect1.<span class="title function_ invoke__">can_hold</span>(&amp;rect3));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="六、枚举和模式匹配"><a href="#六、枚举和模式匹配" class="headerlink" title="六、枚举和模式匹配"></a>六、枚举和模式匹配</h3><h4 id="6-1、枚举"><a href="#6-1、枚举" class="headerlink" title="6.1、枚举"></a>6.1、枚举</h4><ol><li><strong>枚举</strong>：枚举是一个不同于结构体的定义自定义数据类型的方式。<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单型枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> {</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">four</span> = IpAddrKind::V4;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">six</span> = IpAddrKind::V6;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">route</span>(IpAddrKind::V4);</span><br><span class="line">    <span class="title function_ invoke__">route</span>(IpAddrKind::V6);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">route</span>(ip_kind: IpAddrKind) {}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标量类型为内容的枚举</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">IpAddr</span> {</span><br><span class="line">        <span class="title function_ invoke__">V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">        <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"::1"</span>));</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 结构体为内容的枚举</span></span><br><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Ipv4Addr</span> {</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Ipv6Addr</span> {</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">IpAddr</span> {</span><br><span class="line">        <span class="title function_ invoke__">V4</span>(Ipv4Addr),</span><br><span class="line">        <span class="title function_ invoke__">V6</span>(Ipv6Addr),</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><strong>Option</strong>：Option 是标准库定义的另一个枚举。Option 类型应用广泛因为它编码了一个非常普遍的场景，即一个值要么有值要么没值。在<a href="https://doc.rust-lang.org/std/option/enum.Option.html">标准库</a>中的源码：<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; {</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="6-2：match-控制流运算符"><a href="#6-2：match-控制流运算符" class="headerlink" title="6.2：match 控制流运算符"></a>6.2：match 控制流运算符</h4><p>Rust 有一个叫做 match 的极为强大的控制流运算符，它允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行相应代码。类似Java中的<strong>switch-case</strong>。<br></p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> {</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">    Other,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> {</span><br><span class="line">    <span class="keyword">match</span> coin {</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; {</span><br><span class="line">            <span class="comment">// 逻辑处理，此代码块，即{}之内的内容为表达式，而表达式的结果值将作为整个 match 表达式的返回值。</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Coin is Quarter!"</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// other:Other,    //此处为通配符，满足match为有穷尽的匹配规则。</span></span><br><span class="line">        <span class="comment">// _ =&gt; (),     //  "_"，这是一个特殊的模式，可以匹配任意值而不绑定到该值。</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="6-3、if-let-简单控制流"><a href="#6-3、if-let-简单控制流" class="headerlink" title="6.3、if let 简单控制流"></a>6.3、if let 简单控制流</h4><p><strong>if let</strong> 语法让我们以一种不那么冗长的方式结合 <strong>if</strong> 和 <strong>let</strong>，来处理只匹配一个模式的值而忽略其他模式的情况。换句话说，可以认为 <strong>if let</strong> 是 <strong>match</strong> 的一个语法糖，它当值匹配某一模式时执行代码而忽略所有其他值。<br></p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">UsState</span> {</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> {</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    <span class="title function_ invoke__">Quarter</span>(UsState),</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="comment">// let mut count = 0;</span></span><br><span class="line">    <span class="comment">// match coin {</span></span><br><span class="line">    <span class="comment">//     Coin::Quarter(state) =&gt; println!("State quarter from {:?}!", state),</span></span><br><span class="line">    <span class="comment">//     _ =&gt; count += 1,</span></span><br><span class="line">    <span class="comment">// }</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if let 模式</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">coin</span> = Coin::Penny;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Coin</span>::<span class="title function_ invoke__">Quarter</span>(state) = coin {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"State quarter from {:?}!"</span>, state);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="七、package-crate-module"><a href="#七、package-crate-module" class="headerlink" title="七、package/crate/module"></a>七、package/crate/module</h3><ol><li><strong>crate</strong><br><strong>crate</strong>：是一个二进制项或者库。crate root 是一个源文件，Rust 编译器以它为起始点，并构成你的 crate 的根模块。</li></ol><p><strong>create类型：</strong><br>rust里有两种crate，lib类型和bin类型，并且默认以文件名为标准按以下规则处理crate：</p><ul><li>src/main.rs：表示该crate是一个bin类型的crate</li><li>src/lib.rs：表示该crate是一个lib类型的crate<br>src/main.rs和src/lib.rs都是crate的根，也就是crate引用、rustc编译的入口。</li></ul><ol><li><strong>包（package）</strong><br><strong>包（package）</strong>：是提供一系列功能的一个或者多个 crate。cargo new 命令会创建一个新项目，也是一个package，里面有一个Cargo.toml文件，用于定义package、所需外部依赖，以及如何编译crate等。</li></ol><p><strong>包的规则：</strong></p><pre><code>* 包中可以包含至多一个库 crate(library crate)。* 包中可以包含任意多个二进制 crate(binary crate),但是必须至少包含一个 crate.     </code></pre><p>此外，一个package中的crate还有如下约束：</p><ul><li>多个bin类型的crate</li><li>0个或1个lib类型的crate<br>其中，1和2并不互斥，也就是说一个项目下可以有1个lib和多个bin类型的crate，即一个package还以编译出多个可执行文件。</li></ul><p>只是如果有多个bin类型的crate，一个src/main.rs就不行了，就得放到 src/bin 下面，每个crate一个文件，换句话说，每个文件都是一个不同的crate。</p><ol><li><p><strong>模块</strong><br><strong>模块</strong>：让我们可以将一个 crate 中的代码进行分组，以提高可读性与重用性。模块还可以控制项的 私有性，即项是可以被外部代码使用的（public），还是作为一个内部实现的内容，不能被外部代码使用（private）。</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house {</span><br><span class="line">    <span class="keyword">mod</span> hosting {</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() {}</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() {}</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving {</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>() {}</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">serve_order</span>() {}</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_payment</span>() {}</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们定义一个模块，是以 mod 关键字为起始，然后指定模块的名字（本例中叫做 front_of_house），并且用花括号包围模块的主体。在模块内，我们还可以定义其他的模块，就像本例中的 hosting 和 serving 模块。模块还可以保存一些定义的其他项，比如结构体、枚举、常量、特性、或者函数。</p></li><li><p><strong>路径及引用</strong><br><strong>use</strong>：在crate和模块了可能定义了函数、结构体等，要想在其他模块或crate使用，需要将其引入到当前scope中，类似java的import的功能，rust里需要使用use。  </p></li></ol><p><strong>路径</strong>：rust中use引用的路径分为两种：</p><ul><li>绝对路径（absolute path）从 crate 根开始，以 crate 名或者字面值 crate 开头。</li><li>相对路径（relative path）从当前模块开始，以 self、super 或当前模块的标识符开头。</li></ul><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house {</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting {</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() {}</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() {</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用相关操作</span></span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="comment">// 以上两行引用等价于：use std::{cmp::Ordering, io};</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"><span class="comment">// 等价于：use std::io::{self, Write};</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通配符</span></span><br><span class="line"><span class="keyword">use</span> std::collections::*;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>pub修饰符</strong><br>结构体和枚举:要想访问其他mod里的结构体，需要将结构体声明为pub，但是这也只能访问到结构体而已，如果要想操作里面的字段，可以有两种方式：</p><ul><li>提供pub的方法修改字段</li><li>将需要操作的字段直接修改为pub类型  </li><li>在父模块中不能使用子模块中的private项目</li><li>子模块可以使用父模块中的所有item</li></ul><p>可能前者更“面向对象”一些。<br>而枚举类型的话只需要在枚举名前面加上pub即可，不需要对其中的variant进行设置。</p><p><strong>re-exporting 再导出</strong><br>当使用use关键字将外部item导入到当前scope之后，这个item在当前scope是private的，如果使用 pub use 的话，还能让使用当前mod的第三者，使用在该mod中引入的item。</p><ol><li><strong>workspace</strong><br>workspace用于管理多个相关的package，不同的package有各自的Cargo.toml，但是整个workspace共享一个Cargo.lock，也只有一个target目录（编译输出）。</li></ol><p>虽然workspace内的项目共享一个Cargo.lock，但是他们之间默认不互相依赖，需要显示添加它们之间的依赖关系。而且在一个项目中添加的依赖，在其他项目中如果想使用，还需要再次声明依赖才行。</p><h3 id="八、错误处理"><a href="#八、错误处理" class="headerlink" title="八、错误处理"></a>八、错误处理</h3><p>Rust 将错误分为两大类：</p><ul><li><strong>可恢复的（recoverable）</strong>：比如文件未找到的错误，我们很可能只想向用户报告问题并重试操作。此种错误使用 <strong>Result<t, e=""></t,></strong> 类型来处理问题。</li><li><strong>不可恢复的（unrecoverable）</strong>：对于一个可恢复的错误，不可恢复的错误总是 bug 出现的征兆，比如试图访问一个超过数组末端的位置，因此我们要立即停止程序。此种错误由 <strong>panic! 宏</strong> 来处理。</li></ul><h4 id="8-1、panic-与不可恢复的错误"><a href="#8-1、panic-与不可恢复的错误" class="headerlink" title="8.1、panic! 与不可恢复的错误"></a>8.1、panic! 与不可恢复的错误</h4><p><strong>panic</strong> ：处理的两种机制：</p><ul><li><strong>展开（unwinding）</strong>：这意味着 Rust 会回溯栈并清理它遇到的每一个函数的数据，不过这个回溯并清理的过程有很多工作。</li><li><strong>终止（abort）</strong>：这会不清理数据就退出程序。<br>切换方式：Cargo.toml 的 [profile] 部分增加 panic = ‘abort’，可以由展开切换为终止。</li></ul><h4 id="8-2、Result-与可恢复的错误"><a href="#8-2、Result-与可恢复的错误" class="headerlink" title="8.2、Result 与可恢复的错误"></a>8.2、Result 与可恢复的错误</h4><ol><li><strong>Result枚举</strong>，它定义有如下两个成员，Ok 和 Err：<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; {</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用示例</span></span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">"hello.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f {</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() {</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">"hello.txt"</span>) {</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">"Problem creating the file: {:?}"</span>, e),</span><br><span class="line">            },</span><br><span class="line">            other_error =&gt; {</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">"Problem opening the file: {:?}"</span>, other_error)</span><br><span class="line">            }</span><br><span class="line">        },</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>失败时 panic 的简写：<strong>unwrap</strong> 和 <strong>expect</strong><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">"hello.txt"</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">"hello.txt"</span>).<span class="title function_ invoke__">expect</span>(<span class="string">"Failed to open hello.txt"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li>传播错误<br><strong>传播（propagating）错误</strong>：当编写一个其实先会调用一些可能会失败的操作的函数时，除了在这个函数中处理错误外，还可以选择让调用者知道这个错误并决定该如何处理。<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::{<span class="keyword">self</span>, Read};</span><br><span class="line"></span><br><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; {</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">"hello.txt"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f {</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s) {</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传播错误的简写：? 运算符</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">"hello.txt"</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="九、泛型、trait-与生命周期"><a href="#九、泛型、trait-与生命周期" class="headerlink" title="九、泛型、trait 与生命周期"></a>九、泛型、trait 与生命周期</h3><h4 id="9-1、泛型"><a href="#9-1、泛型" class="headerlink" title="9.1、泛型"></a>9.1、泛型</h4><p>我们可以使用泛型为像函数签名或结构体这样的项创建定义，这样它们就可以用于多种不同的具体数据类型。<br></p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;X1, Y1&gt; {</span><br><span class="line">    x: X1,</span><br><span class="line">    y: Y1,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mixup</span>&lt;X2, Y2&gt;(<span class="keyword">self</span>, other: Point&lt;X2, Y2&gt;) <span class="punctuation">-&gt;</span> Point&lt;X1, Y2&gt; {</span><br><span class="line">        Point {</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point { x: <span class="number">5</span>, y: <span class="number">10.4</span> };</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point { x: <span class="string">"Hello"</span>, y: <span class="string">'c'</span> };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = p1.<span class="title function_ invoke__">mixup</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"p3.x = {}, p3.y = {}"</span>, p3.x, p3.y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="9-2、trait：定义共享的行为"><a href="#9-2、trait：定义共享的行为" class="headerlink" title="9.2、trait：定义共享的行为"></a>9.2、trait：定义共享的行为</h4><p><strong>trait</strong> 告诉 Rust 编译器某个特定类型拥有可能与其他类型共享的功能。可以通过 trait 以一种抽象的方式定义共享的行为。可以使用 trait bounds 指定泛型是任何拥有特定行为的类型。<br><strong><font color="red">注意</font></strong>：trait 类似于其他语言中的常被称为 接口（interfaces）的功能，虽然有一些不同。  </p><ol><li><strong>trait</strong> 的定义和实现</li></ol><ul><li><strong>trait 定义</strong>：是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合。trait体中可以有多个方法：一行一个方法签名且都以分号结尾。<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><strong>trait 实现</strong>：在类型上实现 trait 类似于实现与 trait 无关的方法。区别在于 impl 关键字之后，我们提供需要实现 trait 的名称，接着是 for 和需要实现 trait 的类型的名称。<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认实现</span></span><br><span class="line"><span class="comment">// pub trait Summary {</span></span><br><span class="line"><span class="comment">//     fn summarize(&amp;self) -&gt; String {</span></span><br><span class="line"><span class="comment">//         String::from("(Read more...)")</span></span><br><span class="line"><span class="comment">//     }</span></span><br><span class="line"><span class="comment">// }</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> {</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> {</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="type">bool</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> {</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"{}: {}"</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> {</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> {</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"{}, by {} ({})"</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> {</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="type">bool</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> {</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"{}: {}"</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul><ol><li><strong>trait</strong> 作为参数<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! {}"</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trait Bound 语法</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item: &amp;T) {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! {}"</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 + 指定多个 trait bound</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;(<span class="keyword">impl</span> <span class="title class_">Summary</span> + Display)) {}</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display&gt;(item: &amp;T) {}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 where 简化 trait bound</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T: Display + <span class="built_in">Clone</span>, U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span> {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>{}</span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="9-3、生命周期与引用有效性"><a href="#9-3、生命周期与引用有效性" class="headerlink" title="9.3、生命周期与引用有效性"></a>9.3、生命周期与引用有效性</h4><p><strong>生命周期（lifetime）</strong>：也就是引用保持有效的作用域。</p><ol><li><p><strong>悬垂引用</strong>：</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r</span>;</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">            r = &amp;x;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"r: {}"</span>, r);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生命周期展示</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r</span>;                <span class="comment">// ---------+-- 'a</span></span><br><span class="line">        {                     <span class="comment">//          |</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;        <span class="comment">// -+-- 'b  |</span></span><br><span class="line">            r = &amp;x;           <span class="comment">//  |       |</span></span><br><span class="line">        }                     <span class="comment">// -+       |</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"r: {}"</span>, r); <span class="comment">//          |</span></span><br><span class="line">    }                         <span class="comment">// ---------+</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>外部作用域声明了一个没有初值的变量 r，而内部作用域声明了一个初值为 5 的变量x。在内部作用域中，我们尝试将 r 的值设置为一个 x 的引用。接着在内部作用域结束后，尝试打印出 r 的值。这段代码不能编译因为 r 引用的值在尝试使用之前就离开了作用域。</p></li><li><p><strong>生命周期注解语法</strong><br><strong>生命周期注解</strong>：一个不太常见的语法：生命周期参数名称必须以撇号（<strong>‘</strong>）开头，其名称通常全是小写，类似于泛型其名称非常短。<strong>‘a</strong> 是大多数人默认使用的名称。生命周期参数注解位于引用的 &amp; 之后，并有一个<strong>空格</strong>来将引用类型与生命周期注解分隔开。</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="type">i32</span>        <span class="comment">// 引用</span></span><br><span class="line">&amp;<span class="symbol">'a</span> <span class="type">i32</span>     <span class="comment">// 带有显式生命周期的引用</span></span><br><span class="line">&amp;<span class="symbol">'a</span> <span class="keyword">mut</span> <span class="type">i32</span> <span class="comment">// 带有显式生命周期的可变引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数中的使用</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"abcd"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">"xyz"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The longest string is {}"</span>, result);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在函数签名表明对于某些生命周期 'a，函数会获取两个参数，他们都是与生命周期 'a 存在的一样长的字符串 slice。</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="type">str</span>, y: &amp;<span class="symbol">'a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">'a</span> <span class="type">str</span> {</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() {</span><br><span class="line">        x</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        y</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>生命周期省略（Lifetime Elision）</strong></p></li></ol><ul><li><strong>生命周期省略（Lifetime Elision）</strong>：针对一些可预测的并且遵循几个明确的模式的场景，Rust 团队就把这些模式编码进了 Rust 编译器中，如此借用检查器在这些情况下就能推断出生命周期而不再强制程序员显式的增加注解。</li><li><strong>输入生命周期（input lifetimes）</strong>：函数或方法的参数的生命周期。</li><li><strong>输出生命周期（output lifetimes）</strong>：返回值的生命周期。</li><li><strong>生命周期省略规则（lifetime elision rules）</strong>：即编码进 Rust 引用分析的模式。这并不是需要程序员遵守的规则；这些规则是一系列特定的场景，此时编译器会考虑，如果代码符合这些场景，就无需明确指定生命周期。省略规则适用于 fn 定义，以及 impl 块。<ul><li>规则一：每一个是引用的参数都有它自己的生命周期参数。换句话说就是，有一个引用参数的函数有一个生命周期参数：fn foo&lt;’a&gt;(x: &amp;’a i32)，有两个引用参数的函数有两个不同的生命周期参数，fn foo&lt;’a, ‘b&gt;(x: &amp;’a i32, y: &amp;’b i32)，依此类推。</li><li>规则二：如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：fn foo&lt;’a&gt;(x: &amp;’a i32) -&gt; &amp;’a i32。</li><li>规则三：如果方法有多个输入生命周期参数并且其中一个参数是 &amp;self 或 &amp;mut self，说明是个对象的方法(method), 那么所有输出生命周期参数被赋予 self 的生命周期。</li></ul></li></ul><ol><li><p><strong>静态生命周期</strong><br>这里有一种特殊的生命周期值得讨论：<strong>‘static</strong>，其生命周期能够存活于整个程序期间。所有的字符串字面值都拥有 ‘static 生命周期，我们也可以选择像下面这样标注出来：</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="symbol">'static</span> <span class="type">str</span> = <span class="string">"I have a static lifetime."</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>结合泛型类型参数、trait bounds 和生命周期</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"abcd"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">"xyz"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest_with_an_announcement</span>(</span><br><span class="line">        string1.<span class="title function_ invoke__">as_str</span>(),</span><br><span class="line">        string2,</span><br><span class="line">        <span class="string">"Today is someone's birthday!"</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The longest string is {}"</span>, result);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest_with_an_announcement</span>&lt;<span class="symbol">'a</span>, T&gt;(</span><br><span class="line">    x: &amp;<span class="symbol">'a</span> <span class="type">str</span>,</span><br><span class="line">    y: &amp;<span class="symbol">'a</span> <span class="type">str</span>,</span><br><span class="line">    ann: T,</span><br><span class="line">) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">'a</span> <span class="type">str</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Display,</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Announcement! {}"</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() {</span><br><span class="line">        x</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        y</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="十、Rust-中的函数式语言功能"><a href="#十、Rust-中的函数式语言功能" class="headerlink" title="十、Rust 中的函数式语言功能"></a>十、Rust 中的函数式语言功能</h3><p>Rust 的设计灵感来源于很多现存的语言和技术。其中一个显著的影响就是 <strong>函数式编程（functional programming）</strong>。函数式编程风格通常包含将函数作为参数值或其他函数的返回值、将函数赋值给变量以供之后执行等等。</p><ul><li><strong>闭包（Closures）</strong>：一个可以储存在变量里的类似函数的结构。</li><li><strong>迭代器（Iterators）</strong>：一种处理元素序列的方式。</li></ul><h4 id="10-1、闭包（Closures）"><a href="#10-1、闭包（Closures）" class="headerlink" title="10.1、闭包（Closures）"></a>10.1、闭包（Closures）</h4><p>Rust 的 闭包（closures）是可以保存进变量或作为参数传递给其他函数的匿名函数。可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许捕获调用者作用域中的值。</p><ol><li><p>闭包的定义</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">expensive_closure</span> = |num| {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"calculating slowly..."</span>);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">        num</span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 类比函数和闭包的可允许规则</span></span><br><span class="line"><span class="keyword">fn</span>  <span class="title function_">add_one_v1</span>   (x: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> { x + <span class="number">1</span> }</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v2</span> = |x: <span class="type">u32</span>| <span class="punctuation">-&gt;</span> <span class="type">u32</span> { x + <span class="number">1</span> };</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v3</span> = |x|             { x + <span class="number">1</span> };</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v4</span> = |x|               x + <span class="number">1</span>  ;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>规则</strong>：闭包定义是 expensive_closure 赋值的 <strong>=</strong> 之后的部分。闭包的定义以一对竖线（<strong>|</strong>）开始，在竖线中指定闭包的参数；之所以选择这个语法是因为它与 Smalltalk 和 Ruby 的闭包定义类似。这个闭包有一个参数 num；如果有多于一个参数，可以使用逗号分隔，比如 <strong>|param1, param2|</strong>。</p></li><li><p>闭包会捕获其环境<br>闭包还有另一个函数所没有的功能：他们可以捕获其环境并访问其被定义的作用域的变量。</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里，即便 x 并不是 equal_to_x 的一个参数，equal_to_x 闭包也被允许使用变量 x，因为它与 equal_to_x 定义于相同的作用域。</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">equal_to_x</span> = |z| z == x;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错，编译器甚至会提示我们这只能用于闭包！</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">equal_to_x</span>(z: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> {</span><br><span class="line">        z == x</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当闭包从环境中捕获一个值，闭包会在闭包体中储存这个值以供使用。这会使用内存并产生额外的开销，在更一般的场景中，当我们不需要闭包来捕获环境时，我们不希望产生这些开销。因为函数从未允许捕获环境，定义和使用函数也就从不会有这些额外开销。</p></li></ol><p>闭包可以通过三种方式捕获其环境，他们直接对应函数的三种获取参数的方式：<strong>获取所有权</strong>，<strong>可变借用</strong>和<strong>不可变借用</strong>。这三种捕获值的方式被编码为如下三个 Fn trait：</p><ul><li><strong>FnOnce</strong>： 消费从周围作用域捕获的变量，闭包周围的作用域被称为其 <strong>环境（environment）</strong>。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 <strong>Once</strong> 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次。</li><li><strong>FnMut</strong>： 获取可变的借用值所以可以改变其环境。</li><li><strong>Fn</strong>： 从其环境获取不可变的借用值。</li></ul><h4 id="10-2、迭代器"><a href="#10-2、迭代器" class="headerlink" title="10.2、迭代器"></a>10.2、迭代器</h4><p><strong>迭代器模式</strong>：允许你对一个序列的项进行某些处理。<strong>迭代器（iterator）</strong> 负责遍历序列中的每一项和决定序列何时结束的逻辑。当使用迭代器时，我们无需重新实现这些逻辑。在 Rust 中，迭代器是 惰性的（lazy），这意味着在调用方法使用迭代器之前它都不会有效果。</p><h3 id="十一、智能指针"><a href="#十一、智能指针" class="headerlink" title="十一、智能指针"></a>十一、智能指针</h3><p><strong>指针 （pointer）</strong>：是一个包含内存地址的变量的通用概念。<br><strong>智能指针（smart pointers）</strong>：是一类数据结构，他们的表现类似指针，但是也拥有额外的元数据和功能。<br>在 Rust 中，普通引用和智能指针的一个额外的区别是引用是一类只借用数据的指针；相反，在大部分情况下，智能指针 <strong>拥有</strong> 他们指向的数据。如 <strong>String</strong> 和 <strong>Vec<t></t></strong> 。</p><h4 id="10-1、Deref-trait"><a href="#10-1、Deref-trait" class="headerlink" title="10.1、Deref trait"></a>10.1、Deref trait</h4><ol><li><p><strong>通过解引用运算符追踪指针的值</strong><br>实现 <strong>Deref trait</strong> 允许我们重载 <strong>解引用运算符（dereference operator）*</strong>（与乘法运算符或通配符相区别）。通过这种方式实现 Deref trait 的智能指针可以被当作常规引用来对待，可以编写操作引用的代码并用于智能指针。</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y); <span class="comment">//编译通过</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, y); <span class="comment">//编译异常  </span></span><br><span class="line">    <span class="comment">// assert_eq!(5, y);</span></span><br><span class="line">    <span class="comment">// ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`</span></span><br><span class="line">     </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>通过实现 Deref trait 将某类型像引用一样处理</strong><br>为了实现 trait，需要提供 trait 所需的方法实现。<strong>Deref trait</strong> 由标准库提供，要求实现名为 deref 的方法，其借用 self 并返回一个内部数据的引用。</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; {</span><br><span class="line">    <span class="comment">// 语法定义了用于此 trait 的关联类型。关联类型是一个稍有不同的定义泛型参数的方式，</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target {</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>没有 Deref trait 的话，*只会解引用 &amp; 引用类型。deref 方法向编译器提供了获取任何实现了 Deref trait 的类型的值，并且调用这个类型的 deref 方法来获取一个它知道如何解引用的 &amp; 引用的能力。</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = MyBox::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y); <span class="comment">//*y 等价于： *(y.deref())</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>函数和方法的隐式 Deref 强制转换</strong><br><strong>Deref 强制转换（deref coercions）：</strong> 是 Rust 在函数或方法传参上的一种便利。Deref 强制转换只能作用于实现了 Deref trait 的类型。</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>(name: &amp;<span class="type">str</span>) {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, {}!"</span>, name);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Rust"</span>));</span><br><span class="line">    <span class="comment">// 隐式强制转换</span></span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有隐式强制转换</span></span><br><span class="line">    <span class="comment">// hello(&amp;(*m)[..]);</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>&amp;m</strong> 调用 hello 函数过程：    </p></li></ol><ul><li>m 为 MyBox<string> 值的引用，在 MyBox<t> 上实现了 Deref trait，Rust 可以通过 deref 调用将 &amp;MyBox<string> 变为 &amp;String。</string></t></string></li><li>标准库中提供了 String 上的 Deref 实现，其会返回字符串 slice，这可以在 Deref 的 API 文档中看到。Rust 再次调用 deref 将 &amp;String 变为 &amp;str，这就符合 hello 函数的定义了。</li></ul><h4 id="10-2、Drop-trait清理代码"><a href="#10-2、Drop-trait清理代码" class="headerlink" title="10.2、Drop trait清理代码"></a>10.2、Drop trait清理代码</h4><p><strong>Drop trait：</strong> 指定在值离开作用域时应该执行的代码的方式是实现。<br><strong>Drop trait：</strong> 要求实现一个叫做 drop 的方法，它获取一个 self 的可变引用。</p><ol><li><p>实现<strong>Drop trait</strong>来清理代码</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomSmartPointer</span> {</span><br><span class="line">    data: <span class="type">String</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">CustomSmartPointer</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Dropping CustomSmartPointer with data `{}`!"</span>, <span class="keyword">self</span>.data);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = CustomSmartPointer {</span><br><span class="line">        data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"my stuff"</span>),</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = CustomSmartPointer {</span><br><span class="line">        data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"other stuff"</span>),</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"CustomSmartPointers created."</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// $ cargo run。。。</span></span><br><span class="line"><span class="comment">// CustomSmartPointers created.</span></span><br><span class="line"><span class="comment">// Dropping CustomSmartPointer with data `other stuff`!</span></span><br><span class="line"><span class="comment">// Dropping CustomSmartPointer with data `my stuff`!</span></span><br></pre></td></tr></tbody></table></figure><p>变量以被创建时相反的顺序被丢弃，所以 d 在 c 之前被丢弃</p></li><li><p>通过 <strong>std::mem::drop</strong> 提早丢弃值</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = CustomSmartPointer {</span><br><span class="line">        data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"some data"</span>),</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"CustomSmartPointer created."</span>);</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(c);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"CustomSmartPointer dropped before the end of main."</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// $ cargo run。。。</span></span><br><span class="line"><span class="comment">// CustomSmartPointer created.</span></span><br><span class="line"><span class="comment">// Dropping CustomSmartPointer with data `some data`!</span></span><br><span class="line"><span class="comment">// CustomSmartPointer dropped before the end of main.</span></span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="10-3、Rc-引用计数智能指针"><a href="#10-3、Rc-引用计数智能指针" class="headerlink" title="10.3、Rc\ 引用计数智能指针"></a>10.3、Rc\<t> 引用计数智能指针</t></h4><p><strong>Rc\<t></t></strong> ：为 <strong>引用计数（reference counting）</strong> 的缩写。引用计数意味着记录一个值引用的数量来知晓这个值是否仍在被使用。如果某个值有零个引用，就代表没有任何有效引用并可以被清理。<br><strong>Rc\<t></t></strong>: 允许在程序的多个部分之间只读地共享数据。如果 Rc 也允许多个可变引用，则会违反借用规则之一：相同位置的多个可变借用可能造成数据竞争和不一致。  </p><p><font size="5%">总结其特性：</font></p><ul><li>使用 <strong>Rc\<t></t></strong> 共享数据</li><li>克隆 <strong>Rc\<t></t></strong> 会增加引用计数</li><li><strong>Rc\<t></t></strong> 只能用于单线程场景。多线程场景需要使用Arc\<t>（原子引用计数（atomically reference counted）类型）。</t></li><li>通过 <strong>Rc\<t></t></strong> 获取的引用为不可变引用</li></ul><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> {</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::{Cons, Nil};</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">// error[E0382]: use of moved value: `a`</span></span><br><span class="line"><span class="comment">//   --&gt; src/main.rs:11:30</span></span><br><span class="line"><span class="comment">//    |</span></span><br><span class="line"><span class="comment">// 9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));</span></span><br><span class="line"><span class="comment">//    |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait</span></span><br><span class="line"><span class="comment">// 10 |     let b = Cons(3, Box::new(a));</span></span><br><span class="line"><span class="comment">//    |                              - value moved here</span></span><br><span class="line"><span class="comment">// 11 |     let c = Cons(4, Box::new(a));</span></span><br><span class="line"><span class="comment">//    |                              ^ value used here after move</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For more information about this error, try `rustc --explain E0382`.</span></span><br><span class="line"><span class="comment">// error: could not compile `cons-list` due to previous error</span></span><br></pre></td></tr></tbody></table></figure><p>Cons 成员拥有其储存的数据，所以当创建 b 列表时，a 被移动进了 b 这样 b 就拥有了 a。接着当再次尝试使用 a 创建 c 时，这不被允许，因为 a 的所有权已经被移动。<br>此种情况下，必须实现 <strong>a</strong> 同时被 <strong>b</strong> 和 <strong>c</strong> 引用。则可以使用 Rc<t> 代替 Box<t>。如下：<br></t></t></p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> {</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::{Cons, Nil};</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>现在每一个 Cons 变量都包含一个值和一个指向 List 的 Rc<t>。当创建 b 时，不同于获取 a 的所有权，这里会克隆 a 所包含的 Rc<list>，这会将引用计数从 1 增加到 2 并允许 a 和 b 共享 Rc<list> 中数据的所有权。创建 c 时也会克隆 a，这会将引用计数从 2 增加为 3。每次调用 Rc::clone，Rc<list> 中数据的引用计数都会增加，直到有零个引用之前其数据都不会被清理。<p></p><h4 id="10-4、RefCell-和内部可变性模式"><a href="#10-4、RefCell-和内部可变性模式" class="headerlink" title="10.4、RefCell\ 和内部可变性模式"></a>10.4、RefCell\<t> 和内部可变性模式</t></h4><p><strong>内部可变性（Interior mutability）</strong> ：是 Rust 中的一个设计模式，它允许你即使在有不可变引用时也可以改变数据，即：<strong>在不可变值内部改变值</strong>。这通常是借用规则所不允许的。该模式在数据结构中使用 unsafe 代码来模糊 Rust 通常的可变性和借用规则。当可以确保代码在运行时会遵守借用规则，即使编译器不能保证的情况，可以选择使用那些运用内部可变性模式的类型。所涉及的 unsafe 代码将被封装进安全的 API 中，而外部类型仍然是不可变的。</p><ol><li><strong>RefCell\<t></t></strong><br><strong>RefCell\<t></t></strong>：就是内部可变性模式的实现类型之一。与 <strong>Rc\<t></t></strong> 不同的事，它具备数据的唯一所有权。  </li></ol><p>如下为选择 Box<t>，Rc<t> 或 RefCell<t> 的理由：</t></t></t></p><ul><li>Rc<t> 允许相同数据有多个所有者；Box<t> 和 RefCell<t> 有单一所有者。</t></t></t></li><li>Box<t> 允许在编译时执行不可变或可变借用检查；Rc<t>仅允许在编译时执行不可变借用检查；<em> </em> RefCell<t> 允许在运行时执行不可变或可变借用检查。</t></t></t></li><li>因为 RefCell<t> 允许在运行时执行可变借用检查，所以我们可以在即便 RefCell<t> 自身是不可变的情况下修改其内部的值。</t></t></li></ul><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Messenger</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, msg: &amp;<span class="type">str</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">LimitTracker</span>&lt;<span class="symbol">'a</span>, T: Messenger&gt; {</span><br><span class="line">    messenger: &amp;<span class="symbol">'a</span> T,</span><br><span class="line">    value: <span class="type">usize</span>,</span><br><span class="line">    max: <span class="type">usize</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>, T&gt; LimitTracker&lt;<span class="symbol">'a</span>, T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Messenger,</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(messenger: &amp;T, max: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> LimitTracker&lt;T&gt; {</span><br><span class="line">        LimitTracker {</span><br><span class="line">            messenger,</span><br><span class="line">            value: <span class="number">0</span>,</span><br><span class="line">            max,</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_value</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="type">usize</span>) {</span><br><span class="line">        <span class="keyword">self</span>.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">percentage_of_max</span> = <span class="keyword">self</span>.value <span class="keyword">as</span> <span class="type">f64</span> / <span class="keyword">self</span>.max <span class="keyword">as</span> <span class="type">f64</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">1.0</span> {</span><br><span class="line">            <span class="keyword">self</span>.messenger.<span class="title function_ invoke__">send</span>(<span class="string">"Error: You are over your quota!"</span>);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.9</span> {</span><br><span class="line">            <span class="keyword">self</span>.messenger</span><br><span class="line">                .<span class="title function_ invoke__">send</span>(<span class="string">"Urgent warning: You've used up over 90% of your quota!"</span>);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.75</span> {</span><br><span class="line">            <span class="keyword">self</span>.messenger</span><br><span class="line">                .<span class="title function_ invoke__">send</span>(<span class="string">"Warning: You've used up over 75% of your quota!"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests {</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MockMessenger</span> {</span><br><span class="line">        sent_messages: RefCell&lt;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;&gt;,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">MockMessenger</span> {</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> MockMessenger {</span><br><span class="line">            MockMessenger {</span><br><span class="line">                sent_messages: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Messenger</span> <span class="keyword">for</span> <span class="title class_">MockMessenger</span> {</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="type">str</span>) {</span><br><span class="line">            <span class="keyword">self</span>.sent_messages.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(message));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_sends_an_over_75_percent_warning_message</span>() {</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mock_messenger</span> = MockMessenger::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">limit_tracker</span> = LimitTracker::<span class="title function_ invoke__">new</span>(&amp;mock_messenger, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        limit_tracker.<span class="title function_ invoke__">set_value</span>(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">len</span>(), <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>对于 send 方法的实现，第一个参数仍为 self 的不可变借用，这是符合方法定义的。我们调用 self.sent_messages 中 RefCell 的 borrow_mut 方法来获取 RefCell 中值的可变引用，这是一个 vector。接着可以对 vector 的可变引用调用 push 以便记录测试过程中看到的消息。</p><ol><li><strong>RefCell 在运行时记录借用</strong><br>当创建不可变和可变引用时，我们分别使用 &amp; 和 &amp;mut 语法。对于 RefCell<t> 来说，则是 <strong>borrow</strong> 和 <strong>borrow_mut</strong> 方法，这属于 RefCell<t> 安全 API 的一部分。</t></t></li></ol><ul><li>borrow：返回 <strong>Ref<t>（实现了 Deref）</t></strong>。每次调用 borrow，RefCell<t> 将活动的不可变借用计数加一。当 Ref<t> 值离开作用域时，不可变借用计数减一。</t></t></li><li>borrow_mut：方法返回 <strong>RefMut<t>（实现了 Deref）</t></strong>。RefCell<t> 在任何时候只允许有多个不可变借用或一个可变借用。</t></li></ul><ol><li>结合 Rc<t> 和 RefCell<t> 来拥有多个可变数据所有者<br>如果有一个储存了 RefCell<t> 的 Rc<t> 的话，就可以得到有多个所有者 并且 可以修改的值了！<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> {</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(Rc&lt;RefCell&lt;<span class="type">i32</span>&gt;&gt;, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::{Cons, Nil};</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;value), Rc::<span class="title function_ invoke__">new</span>(Nil)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">3</span>)), Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">4</span>)), Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line"></span><br><span class="line">    *value.<span class="title function_ invoke__">borrow_mut</span>() += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a after = {:?}"</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b after = {:?}"</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"c after = {:?}"</span>, c);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></t></t></t></t></li></ol><h4 id="10-4、Weak"><a href="#10-4、Weak" class="headerlink" title="10.4、Weak\"></a>10.4、Weak\<t></t></h4><p><strong>Weak\<t></t></strong>：即 <strong>弱引用（weak reference）</strong> 。调用 Rc::downgrade 时会得到 Weak<t> 类型的智能指针。不同于将 Rc<t> 实例的 strong_count 加 1，调用 Rc::downgrade 会将 weak_count 加 1。Rc<t> 类型使用 weak_count 来记录其存在多少个 Weak<t> 引用，类似于 strong_count。其区别在于 weak_count 无需计数为 0 就能使 Rc<t> 实例被清理。</t></t></t></t></t></p><p>强引用代表如何共享 Rc<t> 实例的所有权，但弱引用并不属于所有权关系。他们不会造成引用循环，因为任何弱引用的循环会在其相关的强引用计数为 0 时被打断。</t></p></list></list></list></t>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper之Watcher机制</title>
      <link href="/posts/f91292b9.html"/>
      <url>/posts/f91292b9.html</url>
      
        <content type="html"><![CDATA[<font size="7">Zookeeper之Watcher</font><p>watcher机制是zookeeper的三大特性之一，它是很多应用场景的前提，比如：集群配置、管理，发布、订阅，资源抢占协调等等。</p><h2 id="watcher原理"><a href="#watcher原理" class="headerlink" title="watcher原理"></a>watcher原理</h2><p>原理框架图：<br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/zookeeper/zookeeper-watcher原理框架.jpeg" alt="zookeeper原理框架">   </p><h2 id="注册和通知"><a href="#注册和通知" class="headerlink" title="注册和通知"></a>注册和通知</h2><p>zookeeper的watcher机制主要由client、server和watcherManager组成，包含注册和通知两个阶段。  </p><h3 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h3><h4 id="客户端注册表"><a href="#客户端注册表" class="headerlink" title="客户端注册表"></a>客户端注册表</h4><p>在 client 端注册表为 ZkWatchManager，ZkWatchManager的存储机制为三种</p><ul><li>dataWatches：针对节点的数据监听。</li><li>existWatches：客户端独有的存储方式，因为节点是否存在需要客户端自己判断。</li><li>childWatches：子节点监听。<br>源码：</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端  其中Set&lt;Watcher&gt;实际复制对象类型为HashSet&lt;Watcher&gt;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ZKWatchManager</span> <span class="keyword">implements</span> <span class="title class_">ClientWatchManager</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;Watcher&gt;&gt; dataWatches =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Set&lt;Watcher&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;Watcher&gt;&gt; existWatches =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Set&lt;Watcher&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;Watcher&gt;&gt; childWatches =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Set&lt;Watcher&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Zoookeeper链接时传入的watcher会赋值到：defaultWatcher</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Watcher defaultWatcher;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>三种存储机制中，Set<watcher>的实现都是HashSet<watcher>，由此可得出：</watcher></watcher></p><ul><li>同一路径下的同一watcher实例，无论注册多少次都只会记录一次，即触发后只通知一次。</li><li>同一路径注册多个不同的watcher，会通知多次。即每个注册watcher都会被通知。</li></ul><h4 id="服务端注册表"><a href="#服务端注册表" class="headerlink" title="服务端注册表"></a>服务端注册表</h4><p>在 server 端注册表为 WatcherWatchManager，WatcherWatchManager的存储机制分为两种：</p><ul><li>dataWatches：针对节点的数据监听。</li><li>childWatches：子节点监听。  </li></ul><p>与 client 比少的 existWatches 也很容易理解，因为节点是否存在需要客户端去判断。<br>两种机制均由 WatchManager 类来实现，WatchManager中包含两个重要的数据结构，分别是：</p><ul><li>watchTable：从数据节点(即路径)的粒度来维护  </li><li>watch2Paths：从watcher的粒度来维护。  </li></ul><p>注意这里的watcher含义表示远程连接，所以watchTable表示一个目录下可能有多个消费者的监听连接，而watch2Paths表示一个消费者可能会对多个目录建立监听，显然多目录的监听会复用一个连接。</p><p>源码：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataTree</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOG</span> <span class="operator">=</span> LoggerFactory.getLogger(DataTree.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This hashtable provides a fast lookup to the datanodes. The tree is the</span></span><br><span class="line"><span class="comment">     * source of truth and is where all the locking occurs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, DataNode&gt; nodes =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, DataNode&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">WatchManager</span> <span class="variable">dataWatches</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WatchManager</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">WatchManager</span> <span class="variable">childWatches</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WatchManager</span>();</span><br><span class="line">    ....</span><br><span class="line">  }</span><br><span class="line"><span class="comment">//dataWatches和childWatches是同一类的不同实例。即：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WatchManager</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOG</span> <span class="operator">=</span> LoggerFactory.getLogger(WatchManager.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, HashSet&lt;Watcher&gt;&gt; watchTable =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, HashSet&lt;Watcher&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Watcher, HashSet&lt;String&gt;&gt; watch2Paths =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Watcher, HashSet&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Set&lt;Watcher&gt; watches : watchTable.values()) {</span><br><span class="line">            result += watches.size();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    ......</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><h4 id="注册方式"><a href="#注册方式" class="headerlink" title="注册方式"></a>注册方式</h4><p>创建Zookeeper链接时会传入的watcher，这个watcher即为注册表中的defaultWatcher。<br>其它注册方式：</p><ul><li>getChildren(String path, Watcher watcher)</li><li>getChildren(String path, boolean watch)</li><li>getData(String path, boolean watch, Stat stat)</li><li>getData(String path, Watcher watcher, AsyncCallback.DataCallback cb, Object ctx)</li><li>exists(String path, boolean watch)</li><li>exists(String path, Watcher watcher)   </li></ul><p>其中Boolean watch表示是否使用上下文中默认的watcher，即创建zk实例时设置的watcher. getData 和 exists 请求可以注册服务端注册表-dataWatches，getChilden 可以注册服务端注册表-childWatches。<br>每个客户端都会维护 2 个线程，SendThread 负责处理客户端与服务端的请求通信，比如发送 getDataRequest，而 EventThread 则负责处理服务端的事件通知，即 watcher 的事件。</p><h4 id="注册流程"><a href="#注册流程" class="headerlink" title="注册流程"></a>注册流程</h4><h5 id="客户端注册流程"><a href="#客户端注册流程" class="headerlink" title="客户端注册流程"></a>客户端注册流程</h5><p>zookeeper客户端watcher注册流程:<br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/zookeeper/zookeeper客户端watcher注册流程.jpeg" alt="zookeeper客户端watcher注册流程"></p><p>几种客户端注册的流程大致相同,我们以exists为例。源码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Stat <span class="title function_">exists</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher)</span></span><br><span class="line">        <span class="keyword">throws</span> KeeperException, InterruptedException</span><br><span class="line">    {</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="type">RequestHeader</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestHeader</span>();</span><br><span class="line">        h.setType(ZooDefs.OpCode.exists);</span><br><span class="line">        <span class="type">ExistsRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExistsRequest</span>();</span><br><span class="line">        request.setPath(serverPath);</span><br><span class="line">        request.setWatch(watcher != <span class="literal">null</span>);</span><br><span class="line">        <span class="type">SetDataResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SetDataResponse</span>();</span><br><span class="line">        <span class="type">ReplyHeader</span> <span class="variable">r</span> <span class="operator">=</span> cnxn.submitRequest(h, request, response, wcb);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>总的来说就是针对不同API进行类似的请求标记，watcher封装，然后将请求放入队列等待(SendThread)调度后发送到服务端。</p><h5 id="服务端注册流程"><a href="#服务端注册流程" class="headerlink" title="服务端注册流程"></a>服务端注册流程</h5><p>server端接收到请求后的处理流程：<br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/zookeeper/zookeeper注册server端流程.jpeg" alt="zookeeper原理框架">   </p><p><em>FinalRequestProcessor</em>：为服务端统一处理类，客户端所有操作及请求最终都会在此进行相应流程处理<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This Request processor actually applies any transaction associated with a</span></span><br><span class="line"><span class="comment"> * request and services any queries. It is always at the end of a</span></span><br><span class="line"><span class="comment"> * RequestProcessor chain (hence the name), so it does not have a nextProcessor</span></span><br><span class="line"><span class="comment"> * member.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This RequestProcessor counts on ZooKeeperServer to populate the</span></span><br><span class="line"><span class="comment"> * outstandingRequests member of ZooKeeperServer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalRequestProcessor</span> <span class="keyword">implements</span> <span class="title class_">RequestProcessor</span>{}</span><br></pre></td></tr></tbody></table></figure><p></p><p>以exists为例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> OpCode.exists: {</span><br><span class="line">    lastOp = <span class="string">"EXIS"</span>;</span><br><span class="line">    <span class="comment">// TODO we need to figure out the security requirement for this!</span></span><br><span class="line">    <span class="type">ExistsRequest</span> <span class="variable">existsRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExistsRequest</span>();</span><br><span class="line">    ByteBufferInputStream.byteBuffer2Record(request.request,</span><br><span class="line">            existsRequest);</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> existsRequest.getPath();</span><br><span class="line">    <span class="keyword">if</span> (path.indexOf(<span class="string">'\0'</span>) != -<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">KeeperException</span>.BadArgumentsException();</span><br><span class="line">    }</span><br><span class="line">    <span class="type">Stat</span> <span class="variable">stat</span> <span class="operator">=</span> zks.getZKDatabase().statNode(path, existsRequest</span><br><span class="line">            .getWatch() ? cnxn : <span class="literal">null</span>);</span><br><span class="line">    rsp = <span class="keyword">new</span> <span class="title class_">ExistsResponse</span>(stat);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由源码可知，这边会通过一些 case 来判断请求类型，watcher最后会经由ZKDatabase的statNode进行操作。根据源码追寻可知：</p><p><em>ZKDatabase</em><br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This class maintains the in memory database of zookeeper</span></span><br><span class="line"><span class="comment"> * server states that includes the sessions, datatree and the</span></span><br><span class="line"><span class="comment"> * committed logs. It is booted up  after reading the logs</span></span><br><span class="line"><span class="comment"> * and snapshots from the disk.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZKDatabase</span>{</span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Stat <span class="title function_">statNode</span><span class="params">(String path, ServerCnxn serverCnxn)</span> <span class="keyword">throws</span> KeeperException.NoNodeException {</span><br><span class="line">      <span class="keyword">return</span> dataTree.statNode(path, serverCnxn);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  .....</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> Stat <span class="title function_">statNode</span><span class="params">(String path, Watcher watcher)</span></span><br><span class="line">        <span class="keyword">throws</span> KeeperException.NoNodeException {</span><br><span class="line">    <span class="type">Stat</span> <span class="variable">stat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line">    <span class="type">DataNode</span> <span class="variable">n</span> <span class="operator">=</span> nodes.get(path);</span><br><span class="line">    <span class="keyword">if</span> (watcher != <span class="literal">null</span>) {</span><br><span class="line">        dataWatches.addWatch(path, watcher);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">KeeperException</span>.NoNodeException();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">synchronized</span> (n) {</span><br><span class="line">        n.copyStat(stat);</span><br><span class="line">        <span class="keyword">return</span> stat;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>ZKDatabase是在zookeeper运行时的数据库，server端注册表就存储在此，最后通过dataTree将watcher存储到dataWatches中。  </p><p>server端正常存储后返回客户端，在 ClientCnxn$SendThread 类的 readResponse-&gt;finishPacket 方法中会对watcher进行存储。<br>可以看到这边调用了 watchRegistration 的 register 方法，而它就是根据请求类型来装入对应的 watchManager 中了(dataWatches、existWatches、childWatches)。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">finishPacket</span><span class="params">(Packet p)</span> {</span><br><span class="line">        <span class="keyword">if</span> (p.watchRegistration != <span class="literal">null</span>) {</span><br><span class="line">            p.watchRegistration.register(p.replyHeader.getErr());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.cb == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (p) {</span><br><span class="line">                p.finished = <span class="literal">true</span>;</span><br><span class="line">                p.notifyAll();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            p.finished = <span class="literal">true</span>;</span><br><span class="line">            eventThread.queuePacket(p);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h3 id="通知-watcher触发"><a href="#通知-watcher触发" class="headerlink" title="通知/watcher触发"></a>通知/watcher触发</h3><h4 id="通知状态和事件类型"><a href="#通知状态和事件类型" class="headerlink" title="通知状态和事件类型"></a>通知状态和事件类型</h4><p>server端通知时主要内容为通知状态(org.apache.zookeeper.Watcher.Event.KeeperState)和事件类型(org.apache.zookeeper.Watcher.Event.EventType)，二者均于WatchedEvent对象内进行传输。<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  A WatchedEvent represents a change on the ZooKeeper that a Watcher</span></span><br><span class="line"><span class="comment"> *  is able to respond to.  The WatchedEvent includes exactly what happened,</span></span><br><span class="line"><span class="comment"> *  the current state of the ZooKeeper, and the path of the znode that</span></span><br><span class="line"><span class="comment"> *  was involved in the event.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WatchedEvent</span> {</span><br><span class="line">  ......</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p></p><h5 id="通知状态"><a href="#通知状态" class="headerlink" title="通知状态"></a>通知状态</h5><div class="table-container"><table><thead><tr><th style="text-align:left">连接状态</th><th style="text-align:left">描述  </th></tr></thead><tbody><tr><td style="text-align:left">KeeperState.Disconnected</td><td style="text-align:left">当客户端断开连接（与集群中的任何一台断开连接）时的状态就是Disconnected  </td></tr><tr><td style="text-align:left">KeeperState.SyncConnected</td><td style="text-align:left">当客户端与zookeeper集群中的任意一台建立连接，这时的事件状态就是SyncConnected  </td></tr><tr><td style="text-align:left">KeeperState.AuthFailed</td><td style="text-align:left">客户端进行连接认证失败时，事件状态为AuthFailed</td></tr><tr><td style="text-align:left">KeeperState.ConnectedReadOnly</td><td style="text-align:left">当前客户端连接到的zookeeper服务是只读的，此时事件状态是ConnectedReadOnly，这时的客户端只可以进行读操作，而不能进行写操作</td></tr><tr><td style="text-align:left">KeeperState.SaslAuthenticated</td><td style="text-align:left">用于通知客户端它们是SASL认证的</td></tr><tr><td style="text-align:left">KeeperState.Expired</td><td style="text-align:left">客户端与zookeeper服务端建立连接后每隔一定时间会发送一次心跳检测，当心跳检测没有收到服务端的响应时即认定断开连接，session失效，此时的事件状态就是Expired，如果客户端想访问服务端，需要重新建立连接。  </td></tr></tbody></table></div><p><font color="red">注意：</font>zookeeper上述状态在触发时，除了SyncConnected会存在包含所有事件的情况，其它状态记录的事件类型都是：EventType.None</p><h5 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h5><div class="table-container"><table><thead><tr><th style="text-align:left">zookeeper事件</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">EventType.NodeCreated</td><td style="text-align:left">当节点被创建时，该事件被触发</td></tr><tr><td style="text-align:left">EventType.NodeChildrenChanged</td><td style="text-align:left">当节点的直接子节点被创建、被删除、子节点数据发生变更时，该事件被触发</td></tr><tr><td style="text-align:left">EventType.NodeDataChanged</td><td style="text-align:left">当节点的数据变化或版本变化时，该事件被触发</td></tr><tr><td style="text-align:left">EventType.NodeDeleted</td><td style="text-align:left">当节点被删除时，该事件被触发</td></tr><tr><td style="text-align:left">EventType.None</td><td style="text-align:left">当zookeeper客户端的连接状态发生变更时（上面连接状态表格中所列），描述的事件类型为EventType.None</td></tr></tbody></table></div><h5 id="API方法与触发事件关联关系"><a href="#API方法与触发事件关联关系" class="headerlink" title="API方法与触发事件关联关系"></a>API方法与触发事件关联关系</h5><p>我们以test节点为例</p><div class="table-container"><table><thead><tr><th style="text-align:left">注册方式</th><th style="text-align:left">NodeCreated</th><th style="text-align:left">NodeChildrenChanged</th><th style="text-align:left">NodeDataChanged</th><th style="text-align:left">NodeDeleted</th></tr></thead><tbody><tr><td style="text-align:left">zk.getChildren(“/test”,watcher)</td><td style="text-align:left"></td><td style="text-align:left">可监控</td><td style="text-align:left"></td><td style="text-align:left">可监控</td></tr><tr><td style="text-align:left">zk.exists(“/test”,watcher)</td><td style="text-align:left">可监控</td><td style="text-align:left"></td><td style="text-align:left">可监控</td><td style="text-align:left">可监控</td></tr><tr><td style="text-align:left">zk.getData(“/test”,watcher)</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">可监控</td><td style="text-align:left">可监控</td></tr></tbody></table></div><p>客户端只能收到服务器发过来的相关事件通知，并不能获取到对应数据节点变化前后的数据。</p><h4 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h4><p>我们以setDate方法为例。server端所有的处理均在FinalRequestProcessor里，当请求处理完成后会进行watcher事件的触发。我们以setDate为例追踪下触发的流程。</p><p>在FinalRequestProcessor中有这么一段代码：<br></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (request.hdr != <span class="literal">null</span>) {</span><br><span class="line">   <span class="type">TxnHeader</span> <span class="variable">hdr</span> <span class="operator">=</span> request.hdr;</span><br><span class="line">   <span class="type">Record</span> <span class="variable">txn</span> <span class="operator">=</span> request.txn;</span><br><span class="line"></span><br><span class="line">   rc = zks.processTxn(hdr, txn);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>追踪下去就会找到 DataTree 类处理 setData 请求的具体逻辑。<br><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Stat <span class="title function_">setData</span><span class="params">(String path, <span class="type">byte</span> data[], <span class="type">int</span> version, <span class="type">long</span> zxid,</span></span><br><span class="line"><span class="params">            <span class="type">long</span> time)</span> <span class="keyword">throws</span> KeeperException.NoNodeException {</span><br><span class="line">    ......</span><br><span class="line">    dataWatches.triggerWatch(path, EventType.NodeDataChanged);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Set&lt;Watcher&gt; <span class="title function_">triggerWatch</span><span class="params">(String path, EventType type, Set&lt;Watcher&gt; supress)</span> {</span><br><span class="line">    <span class="type">WatchedEvent</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WatchedEvent</span>(type,</span><br><span class="line">            KeeperState.SyncConnected, path);</span><br><span class="line">    HashSet&lt;Watcher&gt; watchers;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) {</span><br><span class="line">        watchers = watchTable.remove(path);</span><br><span class="line">        <span class="keyword">if</span> (watchers == <span class="literal">null</span> || watchers.isEmpty()) {</span><br><span class="line">            <span class="keyword">if</span> (LOG.isTraceEnabled()) {</span><br><span class="line">                ZooTrace.logTraceMessage(LOG,</span><br><span class="line">                        ZooTrace.EVENT_DELIVERY_TRACE_MASK,</span><br><span class="line">                        <span class="string">"No watchers for "</span> + path);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (Watcher w : watchers) {</span><br><span class="line">            HashSet&lt;String&gt; paths = watch2Paths.get(w);</span><br><span class="line">            <span class="keyword">if</span> (paths != <span class="literal">null</span>) {</span><br><span class="line">                paths.remove(path);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (Watcher w : watchers) {</span><br><span class="line">        <span class="keyword">if</span> (supress != <span class="literal">null</span> &amp;&amp; supress.contains(w)) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        w.process(e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> watchers;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p></p><p>可以看到逻辑处理完会调用triggerWatch方法，此方法的作用就是从server端的watchManager中获取watcher并在watchTable 和 watch2Paths 中移除自身，所以 watcher 是单次的。  </p><p>最后将封装好的通知即源码中的 e 对象放入watcher的process方法中，process的作用其实就是去发送通知。以 Watcher的一个实现类NioServerCnxn 为例就是调用了其 sendResponse 方法将通知事件发送到客户端，发送前会将 watchedEvent 转换成 watcherEvent 进行发送。</p><p>客户端最后会将通知交由EventThread进行对应watcher的process方法调用。</p><p>至此，zookeeper 的整个 watcher 交互逻辑就已经结束了。</p>]]></content>
      
      
      <categories>
          
          <category> zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode快捷键</title>
      <link href="/posts/ea22a33a.html"/>
      <url>/posts/ea22a33a.html</url>
      
        <content type="html"><![CDATA[<h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><p>Command + Shift + P / F1 显示命令面板<br>Command + P 快速打开<br>Command + Shift + N 打开新窗口<br>Command + W 关闭窗口</p><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><p>Command + X 剪切（未选中文本的情况下，剪切光标所在行）<br>Command + C 复制（未选中文本的情况下，复制光标所在行）<br>Option + Up 向上移动行<br>Option + Down 向下移动行<br>Option + Shift + Up 向上复制行<br>Option + Shift + Down 向下复制行<br>Command + Shift + K 删除行<br>Command + Enter 下一行插入<br>Command + Shift + Enter 上一行插入<br>Command + Shift + \ 跳转到匹配的括号<br>Command + [ 减少缩进<br>Command + ] 增加缩进<br>Home 跳转至行首<br>End 跳转到行尾<br>Command + Up 跳转至文件开头<br>Command + Down 跳转至文件结尾<br>Ctrl + PgUp 按行向上滚动<br>Ctrl + PgDown 按行向下滚动<br>Command + PgUp 按屏向上滚动<br>Command + PgDown 按屏向下滚动<br>Command + Shift + [ 折叠代码块<br>Command + Shift + ] 展开代码块<br>Command + K Command + [ 折叠全部子代码块<br>Command + K Command + ] 展开全部子代码块<br>Command + K Command + 0 折叠全部代码块<br>Command + K Command + J 展开全部代码块<br>Command + K Command + C 添加行注释<br>Command + K Command + U 移除行注释<br>Command + / 添加、移除行注释<br>Option + Shift + A 添加、移除块注释<br>Option + Z 自动换行、取消自动换行</p><h3 id="多光标与选择"><a href="#多光标与选择" class="headerlink" title="多光标与选择"></a>多光标与选择</h3><p>Option + 点击 插入多个光标<br>Command + Option + Up 向上插入光标<br>Command + Option + Down 向下插入光标<br>Command + U 撤销上一个光标操作<br>Option + Shift + I 在所选行的行尾插入光标<br>Command + I 选中当前行<br>Command + Shift + L 选中所有与当前选中内容相同部分<br>Command + F2 选中所有与当前选中单词相同的单词<br>Command + Ctrl + Shift + Left 折叠选中<br>Command + Ctrl + Shift + Right 展开选中<br>Alt + Shift + 拖动鼠标 选中代码块<br>Command + Shift + Option + Up 列选择 向上<br>Command + Shift + Option + Down 列选择 向下<br>Command + Shift + Option + Left 列选择 向左<br>Command + Shift + Option + Right 列选择 向右<br>Command + Shift + Option + PgUp 列选择 向上翻页<br>Command + Shift + Option + PgDown 列选择 向下翻页</p><h3 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h3><p>Command + F 查找<br>Command + Option + F 替换<br>Command + G 查找下一个<br>Command + Shift + G 查找上一个<br>Option + Enter 选中所有匹配项<br>Command + D 向下选中相同内容<br>Command + K Command + D 移除前一个向下选中相同内容</p><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>Ctrl + Space 打开建议<br>Command + Shift + Space 参数提示<br>Tab Emmet插件缩写补全<br>Option + Shift + F 格式化<br>Command + K Command + F 格式化选中内容<br>F12 跳转到声明位置<br>Option + F12 查看具体声明内容<br>Command + K F12 分屏查看具体声明内容<br>Command + . 快速修复<br>Shift + F12 显示引用<br>F2 重命名符号<br>Command + Shift + . 替换为上一个值<br>Command + Shift + , 替换为下一个值<br>Command + K Command + X 删除行尾多余空格<br>Command + K M 更改文件语言</p><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><p>Command + T 显示所有符号<br>Ctrl + G 跳转至某行<br>Command + P 跳转到某个文件<br>Command + Shift + O 跳转到某个符号<br>Command + Shift + M 打开问题面板<br>F8 下一个错误或警告位置<br>Shift + F8 上一个错误或警告位置<br>Ctrl + Shift + Tab 编辑器历史记录<br>Ctrl + - 后退<br>Ctrl + Shift + - 前进<br>Ctrl + Shift + M Tab 切换焦点</p><h3 id="编辑器管理"><a href="#编辑器管理" class="headerlink" title="编辑器管理"></a>编辑器管理</h3><p>Command + W 关闭编辑器<br>Command + K F 关闭文件夹<br>Command + \ 编辑器分屏<br>Command + 1 切换到第一分组<br>Command + 2 切换到第二分组<br>Command + 3 切换到第三分组<br>Command + K Command + Left 切换到上一分组<br>Command + K Command + Right 切换到下一分组<br>Command + K Command + Shift + Left 左移编辑器<br>Command + K Command + Shift + Right 右移编辑器<br>Command + K Left 激活左侧编辑组<br>Command + K Right 激活右侧编辑组</p><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>Command + N 新建文件<br>Command + O 打开文件<br>Command + S 保存文件<br>Command + Shift + S 另存为<br>Command + Option + S 全部保存<br>Command + W 关闭<br>Command + K Command + W 全部关闭<br>Command + Shift + T 重新打开被关闭的编辑器<br>Command + K Enter 保持打开<br>Ctrl + Tab 打开下一个<br>Ctrl + Shift + Tab 打开上一个<br>Command + K P 复制当前文件路径<br>Command + K R 在资源管理器中查看当前文件<br>Command + K O 新窗口打开当前文件</p><h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><p>Command + Ctrl + F 全屏、退出全屏<br>Command + Option + 1 切换编辑器分屏方式（横、竖）<br>Command + + 放大<br>Command + - 缩小<br>Command + B 显示、隐藏侧边栏<br>Command + Shift + E 显示资源管理器 或 切换焦点<br>Command + Shift + F 显示搜索框<br>Ctrl + Shift + G 显示Git面板<br>Command + Shift + D 显示调试面板<br>Command + Shift + X 显示插件面板<br>Command + Shift + H 全局搜索替换<br>Command + Shift + J 显示、隐藏高级搜索<br>Command + Shift + C 打开新终端<br>Command + Shift + U 显示输出面板<br>Command + Shift + V Markdown预览窗口<br>Command + K V 分屏显示 Markdown预览窗口</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>F9 设置 或 取消断点<br>F5 开始 或 继续<br>F11 进入<br>Shift + F11 跳出<br>F10 跳过<br>Command + K Command + I 显示悬停信息</p><h3 id="集成终端"><a href="#集成终端" class="headerlink" title="集成终端"></a>集成终端</h3><p>Ctrl + 显示终端 Ctrl + Shift + 新建终端<br>Command + Up 向上滚动<br>Command + Down 向下滚动<br>PgUp 向上翻页<br>PgDown 向下翻页<br>Command + Home 滚动到顶部<br>Command + End 滚动到底部</p>]]></content>
      
      
      <categories>
          
          <category> vscode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis持久化</title>
      <link href="/posts/dcfaa904.html"/>
      <url>/posts/dcfaa904.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><ul><li>Redis作为一个键值对内存数据库(Nosql)，它的强大性能很大程度上是因为所有数据都存储在内存当中，很显然<br>如果服务器重启(各种因素导致)，内存中存储的所有数据都会丢失，而且不光是重启，守护进程退出，数据一样会<br>丢失，现在Redis用作存储的业务场景变多，数据丢失对业务是致命的影响，如：<ol><li>缓存的应用场景，如果大量缓存数据丢失，往往导致后端存储组件”打死“，应用程序雪崩的情况。</li><li>Redis存储的应用场景，数据丢失是不能接受的;</li></ol></li></ul><h1 id="Redis持久化方案"><a href="#Redis持久化方案" class="headerlink" title="Redis持久化方案"></a>Redis持久化方案</h1><h3 id="redis提供了两种持久化的方案，分别是RDB和AOF"><a href="#redis提供了两种持久化的方案，分别是RDB和AOF" class="headerlink" title="redis提供了两种持久化的方案，分别是RDB和AOF"></a>redis提供了两种持久化的方案，分别是RDB和AOF</h3><h2 id="RDB："><a href="#RDB：" class="headerlink" title="RDB："></a>RDB：</h2><h5 id="RDB是一种快照存储持久化方式，将Redis内存中的数据保存到硬盘的文件中，生产的RDB文件是一个经过压缩的二进制文件，默认保存的文件名为dump-rdb，redis启动时会自动载入。"><a href="#RDB是一种快照存储持久化方式，将Redis内存中的数据保存到硬盘的文件中，生产的RDB文件是一个经过压缩的二进制文件，默认保存的文件名为dump-rdb，redis启动时会自动载入。" class="headerlink" title="RDB是一种快照存储持久化方式，将Redis内存中的数据保存到硬盘的文件中，生产的RDB文件是一个经过压缩的二进制文件，默认保存的文件名为dump.rdb，redis启动时会自动载入。"></a>RDB是一种快照存储持久化方式，将Redis内存中的数据保存到硬盘的文件中，生产的RDB文件是一个经过压缩的二进制文件，默认保存的文件名为dump.rdb，redis启动时会自动载入。</h5><h6 id="RDB实现方式有两种，手动执行和服务器配置定期执行"><a href="#RDB实现方式有两种，手动执行和服务器配置定期执行" class="headerlink" title="RDB实现方式有两种，手动执行和服务器配置定期执行"></a>RDB实现方式有两种，手动执行和服务器配置定期执行</h6><ul><li>手动执行有两个命令可用于生成RDB文件，SAVE和BGSAVE<ol><li>SAVE命令，但SAVE命令会阻塞服务进程，阻塞其它命令，直到RDB文件创建完成，才执行。如若数据量较大不建议使用该命令。</li><li>BGSAVE命令，与SAVE不同，BGSAVE是通过派生子进程来实现的，主进程依旧可以接收命令，但派生子进程是同步的，所以派生子进程过程较长(一版很快)也会出现阻塞的情况。</li></ol></li><li>BGSAVE命令执行过程中，无法同时执行SAVE和BESAVE，避免产生竞争条件。</li><li>服务器配置定时执行<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">save 900 1      // 900内,有1条写入,则产生快照 </span><br><span class="line">save 300 1000   // 如果300秒内有1000次写入,则产生快照</span><br><span class="line">save 60 10000  // 如果60秒内有10000次写入,则产生快照</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>通过配置文件进行触发，如上所示，根据操作次数进行触发，redis服务器的周期性函数serverCorn会每一百毫秒进行一次，它的工作之前就是判断是否满足配置参数条件，如果满足就执行BGSAVE命令。<br>RDB其它相关配置<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stop-writes-on-bgsave-error yes  // 后台备份进程出错时,主进程停不停止写入?</span><br><span class="line">   rdbcompression yes    // 导出的rdb文件是否压缩</span><br><span class="line">   Rdbchecksum   yes //  导入rbd恢复时数据时,要不要检验rdb的完整性</span><br><span class="line">   dbfilename dump.rdb  //导出来的rdb文件名</span><br><span class="line">   dir ./  //rdb的放置路径</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><h5 id="AOF-Append-Only-File-，与RDB某个时刻的快照不同，AOF持久化会记录每次操作，形成后缀为aof的文件，类似mysql的binlog。在重启后会通过运行aof文件，以达到回复文件的目的。相较而言会对redis性能有些影响，但大部分情况是可接受的"><a href="#AOF-Append-Only-File-，与RDB某个时刻的快照不同，AOF持久化会记录每次操作，形成后缀为aof的文件，类似mysql的binlog。在重启后会通过运行aof文件，以达到回复文件的目的。相较而言会对redis性能有些影响，但大部分情况是可接受的" class="headerlink" title="AOF(Append-Only File)，与RDB某个时刻的快照不同，AOF持久化会记录每次操作，形成后缀为aof的文件，类似mysql的binlog。在重启后会通过运行aof文件，以达到回复文件的目的。相较而言会对redis性能有些影响，但大部分情况是可接受的."></a>AOF(Append-Only File)，与RDB某个时刻的快照不同，AOF持久化会记录每次操作，形成后缀为aof的文件，类似mysql的binlog。在重启后会通过运行aof文件，以达到回复文件的目的。相较而言会对redis性能有些影响，但大部分情况是可接受的.</h5><ul><li>Redis默认不开启AOF持久化方式，我们可以在配置文件中开启  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly no # 是否打开 aof日志功能</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>AOF持久化的实现可分为三步，追加(append)、文件写入、文件同步(sync)</p><ol><li>命令追加，服务器每次操作都会以redis的协议方式形成二进制文件，追加到aof_buf缓冲区的末尾。<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer{</span><br><span class="line">    sds aof_buf;/* AOF buffer, written before entering the event loop */</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>文件写入与同步<br>redis服务器进程就是一个事件循环函数，每次循环结束前，都会调用<br>flushAppendOnlyFile()，考虑是否将aof缓冲区中的内容写入到aof文件当中，flushAppendOnlyFile()函数的行为由配置appendfsync参数控制，一共如下三种策略，缺省情况下默认为everysec策略。<br>缓冲区确实提高了效率，但也存在一定安全问题，如果发生停机，那么缓冲区的数据也会丢失，为此redis提供了两个同步函数，fsync和fdatasync，强制将缓冲区的数据写入到硬盘文件。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always   # 每1个命令,都立即同步到aof. 安全,速度慢</span><br><span class="line">appendfsync everysec # 折衷方案,每秒写1次</span><br><span class="line">appendfsync no #写入工作交给操作系统,由操作系统判断缓冲区大小,统一写入到aof. 同步频率低,速度快</span><br></pre></td></tr></tbody></table></figure></li><li><p>AOF文件载入与还原<br>aof文件已经包含所有操作命令，所以数据还原其实就是再次执行一次aof中的命令。步骤：<br>1) 创建一个不带网络伪客户端，因为redis命令只能在客户端执行，并且执行命令来源于aof文件。<br>2) 从aof文件中读取一条命令<br>3) 在伪客户端执行<br>4) 反复执行二三步，直至aof文件中的命令执行完毕</p></li></ol></li><li><p>AOF重写</p><ol><li><p>因为aof会把每一步操作都记录到文件，aof文件会越来越大，数据还原时间会越来越长。<br>如下命令操作为了记录list键的状态，aof文件就保存了五条命令，为了解决aof文件膨胀的问题，redis提供了重写(rewrite)机制，通过重写aof，可以生成一个恢复当前redis中数据的最少命令集，比如上面五条就可以合为一条。虽然功能命名为”aof文件重写”，但实际不会对aof文件进行分析处理，而是根据数据库状态来实现的。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RPUSH enlist "A" "B"</span><br><span class="line">RPUSH enlist "C" "V"</span><br><span class="line">RPUSH enlist "D" "G"</span><br><span class="line">LPOP enlist "G"</span><br><span class="line">LPOP list "A"</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>重写策略<br>2.1配置文件方式：<br>默认情况下是不开启重写的,打开后每次fsync都会进行rewrite</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>当然单独配置会比较影响服务器性能，所以可以与另外两个参数一起配置，三个参数一起配置就可以控制rewrite的运行时机，此逻辑也是通过serverCron()函数进行判断控制的</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100 #aof文件大小比起上次重写时的大小</span><br><span class="line">                                增长率100%时,重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb #aof文件,至少超过64M时,重写</span><br></pre></td></tr></tbody></table></figure><p>2.2 手动触发<br>客户端向服务器发送BGREWRITEAOF命令，也可以让服务器进行AOF重写。并且是异步进行<br>注：BGREWRITEAOF正在执行，客户端发送BGSAVE命令会被服务器拒绝，BGSAVE正在执行，客户端发送BGREWRITEAOF，两者在操作上没有冲突，只是都是由子进程进行工作，不能同时执行只是性能方面的考虑——并发两个线程，并且都是大量磁盘写入工作。</p></li></ol></li><li>AOF文件破损<br>因服务宕机会造成aof文件格式紊乱，这种情况下服务会拒绝加载aof文件，出现文件损坏的情况可以通过以下命令进行修复  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-check-aof -fix file.aof</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>  重启服务后可重新载入aof文件进行数据恢复。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li><li>RDB<ol><li>RDB相较AOF而言，恢复数据快，数据紧凑</li><li>SAVE命令容易阻塞服务器，影响性能，BGSAVE虽然由子进行进行工作，但数据量较大时，也会有影响</li><li>容易造成某时间段数据丢失</li></ol></li><li>AOF<ol><li>AOF为追加操作记录形式，对服务器影响小，速度快</li><li>数据量大时，AOF文件体积太大，恢复慢，即使通过重写，文件体积依然较大。</li></ol></li><li>具体选择哪种方式就需要根据具体场景需求进行选择，当然也可以两种方式配合进行，但redis会优先使用AOF文件方式恢复数据，因为AOF文件保存数据比较完整。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/6/26/16b918cd860b0ffd?imageslim" alt="Alt"></p><hr><h3 id="源码资料"><a href="#源码资料" class="headerlink" title="源码资料"></a>源码资料</h3><p><a href="https://github.com/huangz1990/redis-3.0-annotated.git">https://github.com/huangz1990/redis-3.0-annotated.git</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/5d09a9ff51882577eb133aa9#heading-7">https://juejin.im/post/5d09a9ff51882577eb133aa9#heading-7</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
